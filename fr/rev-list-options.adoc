Limitation de commit
~~~~~~~~~~~~~~~~~~~~

En plus de spécifier une plage de commits qui doivent être listés en utilisant les notations spéciales expliquées dans la description, des limitations supplémentaires de commits peuvent être appliquées.

L'utilisation d'un plus grand nombre d'options filtre généralement plus la sortie (par exemple `--since=<date1>` limite aux commits plus récents que _<date1>_, et son utilisation avec `--grep=<motif>` limite aux commits dont le message de journal a une ligne qui correspond _<motif>_), sauf indication contraire.

Notez que celles-ci sont appliquées avant les options de classement et de formatage des commits, telles que `--reverse`.

`-<nombre>`::
`-n <nombre>`::
`--max-count==<nombre>`::
	Limiter la sortie à _<nombre>_ commits.

`--skip=<nombre>`::
	Sauter _<nombre>_ commits avant de commencer à afficher la sortie de journal.

`--since=<date>`::
`--after=<date>`::
	Afficher les commits plus récents que _<date>_.

`--since-as-filter=<date>`::
	Afficher tous les commits plus récents que _<date>_. Cela visite tous les commits dans la plage, plutôt que de s'arrêter au premier commit qui est plus ancien que _<date>_.

`--until=<date>`::
`--before=<date>`::
	Afficher les commits plus anciens que _<date>_.

ifdef::git-rev-list[]
`--max-age=<horodatage>`::
`--min-age=<horodatage>`::
	Limiter la sortie des commits à une plage de temps spécifiée.
endif::git-rev-list[]

`--author=<motif>`::
`--committer=<motif>`::
	Limiter la sortie des commits à ceux dont les lignes d'en-tête auteur/validateur correspondent à _<motif>_ (expression régulière). Avec plus d'un `--author=<motif>`, les commits dont l'auteur correspond à l'un des paramètres _<motif>_ sont choisis (de même pour plusieurs `--committer=<motif>`).

`--grep-reflog=<motif>`::
	Limiter la sortie des commits à ceux dont les entrées de reflog correspondent à _<motif>_ (expression régulière). Avec plus d'un `--grep-reflog`, les commits dont le message de reflog correspond à l'un des modèles donnés sont choisis. C'est une erreur d'utiliser cette option à moins que `--walk-reflogs` ne soit utilisé.

`--grep=<motif>`::
	Limiter la sortie des commits à ceux dont un message de validation correspond à _<motif>_ spécifié (expression régulière). Avec plus d'un `--grep=<motif>`, les commits dont le message correspond à l'un des paramètres _<motif>_ sont choisis (mais voir `--all-match`).
ifndef::git-rev-list[]
+
Lorsque `--notes` est en vigueur, le message des notes est vérifié comme s'il faisait partie du message du journal.
endif::git-rev-list[]

`--all-match`::
	Limiter la sortie des commits à ceux qui correspondent à la fois à tous les `--grep` donnés, au lieu de ceux qui correspondent à au moins un.

`--invert-grep`::
	Limiter la sortie des commits à ceux dont un message de validation ne correspond pas à _<motif>_ spécifié avec `--grep=<motif>`.

`-i`::
`--regexp-ignore-case`::
	Faites correspondre les expressions régulières sans tenir compte de la casse des lettres.

`--basic-regexp`::
	Considérer les motifs limitatifs comme des expressions régulières de base ; c'est la valeur par défaut.

`-E`::
`--extended-regexp`::
	Considérer les motifs limitatifs comme des expressions régulières étendues au lieu des expressions régulières par défaut de base.

`-F`::
`--fixed-strings`::
	Considérer les motifs limitatifs comme des chaînes de caractères fixes (ne pas interpréter le motif comme une expression régulière).

`-P`::
`--perl-regexp`::
	Considérer les motifs limitatifs comme des expressions régulières compatibles Perl.
+
La prise en charge de ces types d'expressions régulières est une dépendance optionnelle à la compilation. Si Git n'a pas été compilé avec ce support et que cette option est activée, la commande se termine immédiatement.

`--remove-empty`::
	Arrêter lorsqu'un chemin donné disparaît de l'arbre.

`--merges`::
	N'afficher que les commits de fusion. C'est exactement la même chose que `--min-parents=2`.

`--no-merges`::
	Ne pas afficher les commits avec plus d'un parent. C'est exactement la même chose que `--max-parents=1`.

`--min-parents=<nombre>`::
`--max-parents=<nombre>`::
`--no-min-parents`::
`--no-max-parents`::
	Afficher uniquement les commits qui ont au moins (ou au plus) autant de commits parents. En particulier, `--max-parents=1` est la même chose que `--no-merges`, `--min-parents=2` est la même chose que `--merges`. `--max-parents=0` donne tous les commits racine et `--min-parents=3` toutes les fusions octopus.
+
`--no-min-parents` et `--no-max-parents` réinitialisent ces limites (à sans limite). Les formes équivalentes sont `--min-parents=0` (tout commit a 0 ou plus de parents) et `--max-parents=-1` (les nombres négatifs dénotent l'absence de limite supérieure).

`--first-parent`::
	Lors de la recherche de commits à inclure, ne suivre que le premier commit parent lors d'un commit de fusion. Cette option peut donner une meilleure vue d'ensemble lors de l'affichage de l'évolution d'une branche de sujet particulière, parce que la fusion dans une branche de sujet a tendance à n'être que des mises à jour avec l'amont de temps en temps, et cette option permet d'ignorer les commits individuels apportés dans votre historique par de telles fusions.
ifdef::git-log[]
+
Cette option change également le format de diff par défaut pour les commits de fusion à `first-parent`, voir `--diff-merges=first-parent` pour plus de détails.
endif::git-log[]

`--exclude-first-parent-only`::
	Lors de la recherche de commits à exclure (avec un '{caret}' ;), ne suivre que le premier commit parent lorsqu'un commit de fusion est vu. Cela peut être utilisé pour trouver l'ensemble des changements dans une branche de sujet à partir du point où elle a divergé de la branche distante, étant donné que des fusions arbitraires peuvent être des changements de branches thématiques valides.

`--not`::
	Inverse le sens du préfixe '{caret}' (ou son absence) pour tous les spécificateurs de révision suivants, jusqu'au prochain `--not`. Lorsqu'il est utilisé sur la ligne de commande avant --stdin, les révisions passées par stdin ne seront pas affectées. Inversement, lorsqu'il est passé par l'entrée standard, les révisions passées sur la ligne de commande ne seront pas affectées.

`--all`::
	Faire comme si toutes les refs de `refs/`, ainsi que `HEAD`, étaient listées sur la ligne de commande comme _<commit>_.

`--branches[=<motif>]`::
	Faire comme si toutes les refs de `refs/heads` étaient listées sur la ligne de commande comme _<commit>_. Si _<motif>_ est fourni, limiter les branches à celles qui correspondent au _<motif>_ glob shell donné. Si le motif ne présente pas de '?', '{asterisk}', ni '[', '/{asterisk}' à la fin est implicite.

`--tags[=<motif>]`::
	Faire comme si toutes les refs de `refs/tags` étaient listées sur la ligne de commande comme _<commit>_. Si _<motif>_ est fournir, limiter les étiquettes à celles qui correspondent à un glob shell donné. Si le motif ne présente pas de '?', '{asterisk}', ni '[', '/{asterisk}' à la fin est implicite.

`--remotes[=<motif>]`::
	Faire comme si toutes les refs de `refs/remotes' étaient listées sur la ligne de commande comme _<commit>_. Si _<motif>_ est donné, limiter les branches de suivi à distance à celles qui correspondent à un glob shell donné. Si le motif ne présent pas '?', '{asterisk}', ni '[', '/{asterisk}' à la fin est implicite.

`--glob=<motif-glob>`::
	Faire comme si toutes les réfs correspondant au shell glob _<motif-glob>_ étaient listées sur la ligne de commande comme _<commit>_. Le préfixe 'refs/', est automatiquement ajouté s'il n'y en a pas. Si le motif ne présente pas de '?', '{asterisk}', ni '[', '/{asterisk}' à la fin est implicite.

`--exclude=<motif-glob>`::

	Ne pas inclure les références correspondant à _<glob-pattern>_ que les `--all`, `--branches`, `--tags`, `--remotes`, ou `--glob` suivantes considéreraient autrement. Les répétitions de cette option accumulent les motifs d'exclusion jusqu'à la prochaine option `--all`, `--branches`, `--tags`, `--remotes` ou `--glob` (les autres options ou arguments n'éliminent pas les motifs accumulés).
+
Les motifs donnés ne doivent pas commencer par `refs/heads`, `refs/tags`, ou `refs/remotes` lorsqu'ils sont appliqués à `--branches`, `--tags`, ou `--remotes`, respectivement, et ils doivent commencer par `refs/` lorsqu'ils sont appliqués à `--glob` ou `--all`. Si un'/{asterisk}' final est intentionnel, il doit être donné explicitement.

`--exclude-hidden=(fetch|receive|uploadpack)`::
	Ne pas inclure les références qui seraient cachées par `git-fetch`, `git-receive-pack` ou `git-upload-pack` en consultant la configuration `fetch.hideRefs`, `receive.hideRefs` ou `uploadpack.hideRefs`correspondante ainsi que `transfer.hideRefs` (voir linkgit:git-config[1]). Cette option affecte l'option de pseudo-référence suivante `--all` ou `--glob` et est effacée après leur traitement.

`--reflog`::
	Faire comme si tous les objets mentionnés par les reflogs étaient listés sur la ligne de commande comme _<commit>_.

`--alternate-refs`::
	Faire comme si tous les objets mentionnés en tant que sommets de référence des dépôts alternatifs étaient listés sur la ligne de commande. Un dépôt alternatif est tout dépôt dont le répertoire d'objets est spécifié dans `objects/info/alternates`. L'ensemble des objets inclus peut être modifié par `core.alternateRefsCommand`, etc. Voir linkgit:git-config[1].

`--single-worktree`::
	Par défaut, tous les arbres de travail seront examinés par les options suivantes lorsqu'il y en a plusieurs (voir linkgit:git-worktree[1]) : `--all`, `--reflog` et `--indexed-objects`. Cette option les oblige à n'examiner que l'arbre de travail actuel.

`--ignore-missing`::
	En voyant un nom d'objet invalide dans l'entrée, faire comme si la mauvaise entrée n'avait pas été donnée.

ifndef::git-rev-list[]
`--bisect`::
	Faire comme si le mauvais bissection ref `refs/bisect/bad` a été inscrite comme si elle a été suivie par `--not` et que les bonnes refs de bissection `refs/bisect/good-*` sur la ligne de commande.
endif::git-rev-list[]

`--stdin`::
	En plus d'obtenir des arguments de la ligne de commande, les lire aussi depuis l'entrée standard. Cela accepte des commits et des pseudo-options comme `--all` et `--glob=`. Lorsqu'un séparateur `--` est vu, les entrées suivantes sont traitées comme des chemins et utilisées pour limiter le résultat. Les drapeaux comme `--not` qui sont lus via l'entrée standard ne sont respectés que pour les arguments passés de la même manière et n'influenceront aucun argument de ligne de commande suivant.

ifdef::git-rev-list[]
`--quiet`::
	Ne rien imprimer en sortie standard. Cette forme est principalement destinée à permettre à l'appelant de tester l'état de sortie pour voir si une série d'objets est entièrement connectée (ou non). C'est plus rapide que de rediriger stdout vers `/dev/null` car la sortie n'a pas besoin d'être formatée.

`--disk-usage`::
`--disk-usage=human`::
	Supprimer la sortie normale ; afficher plutôt la somme des octets utilisés pour le stockage sur disque par les commits ou les objets sélectionnés. Cela équivaut à envoyer la sortie dans `git cat-file --batch-check='%(objectsize:disk)'`, sauf que cela fonctionne beaucoup plus vite (surtout avec `--use-bitmap-index`). Voir la section `AVERTISSEMENTS` dans linkgit:git-cat-file[1] pour les limitations de ce que signifie "stockage sur disque". Avec la valeur optionnelle `human`, la taille du stockage sur disque est affichée par une chaîne de caractères lisible par l'homme (par exemple 12,24 Kio, 3,50 Mio).
endif::git-rev-list[]

`--cherry-mark`::
	Comme `--cherry-pick` (voir ci-dessous) mais marquer les commits équivalents avec `==` plutôt que de les omettre, et les différents avec `+`.

`--cherry-pick`::
	Omettre tout commit qui introduit le même changement qu'un autre commit de l'"autre côté" lorsque l'ensemble des commits est limité avec une différence symétrique.
+
Par exemple, si vous avez deux branches, `A` et `B`, une façon habituelle de lister tous les commits d'un seul côté d'entre elles est avec `--left-right` (voir l'exemple ci-dessous dans la description de l'option `--left-right`). Cependant, cela montre les commits qui ont été picorés sur l'autre branche (par exemple, ``3rd on b'' peut être trié sur la branche A). Avec cette option, ces paires de commits sont exclues de la sortie.

`--left-only`::
`--right-only`::
	Ne lister que les commits du côté respectif d'une différence symétrique, c'est-à-dire seulement ceux qui seraient marqués `<` resp. `>` par `--left-right`.
+
Par exemple, `--cherry-pick --right-only A...B` omet les commits de `B` qui sont dans `A` ou sont équivalents en rustine à un commit en `A`. En d'autres termes, cela liste les commits `+` de `git cherry A B`. Plus précisément, `--cherry-pick --right-only --no-merges` donne la liste exacte.

`--cherry`::
	Un synonyme pour `--right-only --cherry-mark --no-merges` ; utile pour limiter la sortie aux commits de notre côté et marquer ceux qui ont été appliqués de l'autre côté d'un historique en fourche avec `git log --cherry amont...mabranche`, similaire à `git cherry upstream mabranche`.

`-g`::
`--walk-reflogs`::
	Au lieu de marcher dans la chaîne des commits ancêtres, parcourir les entrées de reflog du plus récent au plus ancien. Lorsque cette option est utilisée, vous ne pouvez pas spécifier de commits à exclure (c'est-à-dire que les notations `^<commit>`, `<commit1>..<commit2>` et`<commit1>...<commit2>` ne peuvent pas être utilisées).
+
Avec un format `--pretty` autre que `online` et `reference` (pour des raisons évidentes), cela fait que la sortie a deux lignes supplémentaires d'informations tirées du reflog. L'indicateur de reflog dans la sortie peut être affiché comme `ref@{<Nième>}` (où _<Nième>_ est l'index chronologique inverse dans le reflog) ou comme `ref@{<horodatage>}` (avec l'_<horodatage>_ pour cette entrée), selon quelques règles :
+
--
1. Si le point de départ est spécifié comme `ref@{<Nième>}`, afficher le format de l'index.
+
2. Si le point de départ a été spécifié comme `ref@{now}`, afficher le format de l'horodatage.
+
3. Si ni l'un ni l'autre n'a été utilisé, mais que `--date` a été donné sur la ligne de commande, afficher l'horodatage dans le format demandé par `--date`.
+
4. Sinon, afficher le format de l'index.
--
+
Sous `--pretty=oneline`, le message de commit est préfixé avec cette information sur la même ligne. Cette option ne peut pas être combinée avec `--reverse`. Voir aussi linkgit:git-reflog[1].
+
Sous l'option `--pretty=reference`, ces informations ne seront pas affichées du tout.

`--merge`::
	Afficher les commits touchant les chemins conflictuels dans la plage `HEAD... <autre>`, où `<autre>` est la première pseudo-ref existante dans `MERGE_HEAD`, `CHERRY_PICK_HEAD`, `REVERT_HEAD` ou `REBASE_HEAD`. Fonctionne seulement lorsque l'index a des entrées non fusionnées. Cette option peut être utilisée pour montrer les commits pertinents lors de la résolution des conflits à partir d'une fusion à 3 voies.

`--boundary`::
	Afficher les commits de limite exclus. Les limites sont préfixées par `-`.

ifdef::git-rev-list[]
`--use-bitmap-index`::

	Essayer d'accélérer la traversée en utilisant l'index bitmap empaqueté (si disponible). Notez que lorsque vous parcourez avec `--objects`, les arbres et les blobs n'auront pas leur chemin associé affiché.

`--progress=<entête>`::
	Afficher les rapports d'avancement sur stderr au fur et à mesure que les objets sont pris en compte. Le texte "<en-tête>" sera affiché à chaque mise à jour de l'état d'avancement.

`-z`::
	Au lieu d'être délimité par la nouvelle ligne, chaque objet sorti et ses métadonnées complémentaires est délimité en utilisant des octets NUL. La sortie est affichée sous la forme suivante :
+
-----------------------------------------------------------------------
<OID> NUL [<jeton>=<valeur> NUL]...
-----------------------------------------------------------------------
+
Des métadonnées d'objets supplémentaires, comme des chemins d'objets ou des objets de limite, sont affichées à l'aide de la forme `<jeton>=<valeur>`. Les valeurs de jeton sont affichées tel quelles sans encodage/truncation. Une entrée OID ne contient jamais un caractère '=' et est donc utilisé pour signaler le début d'un enregistrement de nouvel objet. Exemples :
+
-----------------------------------------------------------------------
<OID> NUL
<OID> NUL path=<chemin> NUL
<OID> NUL boundary=yes NUL
<OID> NUL missing=yes NUL [<jeton>=<valeur> NUL]...
-----------------------------------------------------------------------
+
Ce mode est uniquement compatible avec les options de sortie `--objects`, `--boundary` et `--missing`.
endif::git-rev-list[]

Simplification de l'historique
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Parfois vous n'êtes intéressé que par certaines parties de l'historique, par exemple les commits qui modifient un <chemin> particulier. Mais il y a deux parties dans la 'Simplification de l'historique', une partie est la sélection des commits et l'autre la manière de le faire, car il existe différentes stratégies pour simplifier l'historique.

Les options suivantes sélectionnent les commits à afficher :

_<chemins>_::
	Les commits qui modifient les <chemins> donnés sont sélectionnés.

`--simplify-by-decoration`::
	Les commits qui sont liés à une branche ou une étiquette sont sélectionnés.

Notez que des commits supplémentaires peuvent être affichés pour donner un historique significatif.

Les options suivantes influent sur la façon dont la simplification est effectuée :

Mode par défaut::
	Simplifie l'historique jusqu'à l'historique le plus simple en expliquant l'état final de l'arbre. Le plus simple parce qu'il taille certaines branches latérales si le résultat final est le même (c'est-à-dire qu'il fusionne des branches avec le même contenu)

`--show-pulls`::
	Inclure tous les commits du mode par défaut, mais aussi tous les commits de fusion qui ne sont pas MEMEARBRE au premier parent mais qui sont MEMEARBRE à un parent ultérieur. Ce mode est utile pour montrer les commits de fusion qui ont "introduit en premier" une modification dans une branche.

`--full-history`::
	Identique au mode par défaut, mais ne pas élaguer l'historique.

`--dense`::
	Seuls les commits sélectionnés sont affichés, plus certains pour avoir un historique significatif.

`--sparse`::
	Tous les commits de l'historique simplifié sont affichés.

`--simplify-merges`::
	Option supplémentaire à `--full-history` pour supprimer certaines fusions inutiles de l'historique résultant, car il n'y a pas de commits sélectionnés contribuant à cette fusion.

`--ancestry-path[=<commit>]`::
	When given a range of commits to display (e.g. `<commit1>..<commit2>` or `<commit2> ^<commit1>`), and a commit _<commit>_ in that range, only display commits in that range that are ancestors of _<commit>_, descendants of _<commit>_, or _<commit>_ itself. If no commit is specified, use _<commit1>_ (the excluded part of the range) as _<commit>_. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.

Une explication plus détaillée suit.

Suppose you specified `foo` as the _<paths>_. We shall call commits that modify `foo` !TREESAME, and the rest TREESAME. (In a diff filtered for `foo`, they look different and equal, respectively.)

Dans ce qui suit, nous nous référerons toujours au même exemple d'historique pour illustrer les différences entre les paramètres de simplification. Nous supposons que vous filtrez pour un fichier `foo` dans ce graphe de commits :

-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /   /
	I     B   C   D   E   Y
	 \   /   /   /   /   /
	  `-------------'   X
-----------------------------------------------------------------------

La ligne horizontale de l'historique A---Q est prise pour être le premier parent de chaque fusion. Les commits sont :

* `I` is the initial commit, in which `foo` exists with contents `asdf`, and a file `quux` exists with contents `quux`. Initial commits are compared to an empty tree, so `I` is !TREESAME.

* In `A`, `foo` contains just `foo`.

* `B` contient le même changement que `A`. Sa fusion `M` est triviale et donc MEMEARBRE pour tous les parents.

* `C` does not change `foo`, but its merge `N` changes it to `foobar`, so it is not TREESAME to any parent.

* `D` sets `foo` to `baz`. Its merge `O` combines the strings from `N` and `D` to `foobarbaz`; i.e., it is not TREESAME to any parent.

* `E` changes `quux` to `xyzzy`, and its merge `P` combines the strings to `quux xyzzy`. `P` is TREESAME to `O`, but not to `E`.

* `X` est un commit racine indépendant qui a ajouté un nouveau fichier `side`, et `Y` l'a modifié. `Y` est MEMEARBRE à `X`. Sa fusion `Q` a ajouté `side` à `P`, et `Q` est MEMEARBRE à `P`, mais pas à `Y`.

`rev-list` traverse en arrière l'historique, y compris ou en excluant les commits en fonction de si `--full-history` et / ou la réécriture des parents (par l'intermédiaire de `--parents` ou `--children`) sont utilisés. Les paramètres suivants sont disponibles.

Mode par défaut::
	Les commits sont inclus s'ils ne sont pas MEMEARBRE à un parent (bien que ceci puisse être changé, voir `--sparse` ci-dessous). Si le commit était une fusion, et que c'était MEMEARBRE à un des parents, ne suivez que ce parent. (Même s'il y a plusieurs parents MEMEARBRE, ne suivez qu'un seul d'entre eux.) Sinon, suivez tous les parents.
+
Il en résulte :
+
-----------------------------------------------------------------------
	  .-A---N---O
	 /     /   /
	I---------D
-----------------------------------------------------------------------
+
Notez que la règle de ne suivre que le parent MEMEARBRE, s'il y en a un disponible, a entièrement supprimé `B` de la considération. `C` a été pris en compte via `N`, mais il est MEMEARBRE. Les commits racines sont comparés à un arbre vide, donc `I` est !MEMEARBRE.
+
Les relations parents/enfants ne sont visibles qu'avec `--parents`, mais cela n'affecte pas les commits sélectionnés en mode par défaut, nous avons donc montré les lignes parentales.

`--full-history` sans réécriture des parents::
	Ce mode diffère du mode par défaut en un point : toujours suivre tous les parents d'une fusion, même si c'est MEMEARBRE à l'un d'eux. Même si plus d'un côté de la fusion a des commits qui sont inclus, cela ne signifie pas que la fusion elle-même l'est ! Dans l'exemple, nous obtenons
+
-----------------------------------------------------------------------
	I  A  B  N  D  O  P  Q
-----------------------------------------------------------------------
+
`M` a été exclu parce qu'il s'agit d'un MEMEARBRE pour les deux parents. `E`, `C` et `B` ont tous été parcourus, mais seul `B` était un !MEMEARBRE, donc les autres n'apparaissent pas.
+
Notez que sans réécriture des parents, il n'est pas vraiment possible de parler des relations parent/enfant entre les commits, donc nous les montrons déconnectés.

`--full-history` avec réécriture des parents::
	Les commits ordinaires ne sont inclus que s'ils le sont !MEMEARBRE (bien que cela puisse être changé, voir `--sparse` ci-dessous).
+
Les fusions sont toujours incluses. Cependant, leur liste de parents est réécrite : à côté de chaque parent, élaguer les commits qui ne sont pas inclus eux-mêmes. Il en résulte
+
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /
	I     B   /   D   /
	 \   /   /   /   /
	  `-------------'
-----------------------------------------------------------------------
+
À comparer avec `--full-history` sans réécrire ci-dessus. Notez que `E` a été élagué parce que c'est MEMEARBRE, mais la liste parent de P a été réécrite pour contenir le parent `I` de `E`. Il en a été de même pour `C` et `N`, et `X`, `Y` et `Q`.

En plus des paramètres ci-dessus, vous pouvez modifier si MEMEARBRE affecte l'inclusion :

`--dense`::
	Les commits qui sont parcourus sont inclus s'ils ne sont pas MEMEARBRE pour aucun parent.

`--sparse`::
	Tous les commits qui sont parcourus sont inclus.
+
Notez que sans `--full-history`, cela simplifie encore les fusions : si l'un des parents est MEMEARBRE, nous ne suivons que celui-là, donc les autres côtés de la fusion ne sont jamais parcourus.

`--simplify-merges`::
	Tout d'abord, construire un graphe d'historique de la même manière que `--full-history` avec la réécriture des parents (voir ci-dessus).
+
Puis simplifier chaque commit `C` à son remplacement `C'` dans l'historique final selon les règles suivantes :
+
--
* Définir `C'` sur `C`.
+
* Remplacer chaque parent `P` de `C'` par sa simplification `P'`. Dans le processus, déposer les parents qui sont les ancêtres d'autres parents ou qui sont des commits racines MEMEARBRE à un arbre vide, et supprimer les doublons, mais prendre soin de ne jamais laisser tomber tous les parents auxquels nous sommes MEMEARBRE.
+
* Si après cette réécriture des parents, `C'` est un commit racine ou de fusion (qui a zéro ou >1 parents), un commit limite, ou !MEMEARBRE, il est conservé. Sinon, il est remplacé par son seul parent.
--
+
L'effet de ceci est mieux montré en comparant avec `--full-history` avec la réécriture des parents. L'exemple se transforme en :
+
-----------------------------------------------------------------------
	  .-A---M---N---O
	 /     /       /
	I     B       D
	 \   /       /
	  `---------'
-----------------------------------------------------------------------
+
Notez les principales différences entre `N`, `P` et `Q` par rapport à `--full-history` :
+
--
* 'La liste des parents de `N` a été supprimée, parce qu'elle est un ancêtre de l'autre parent `M`. Pourtant, `N` est resté parce qu'il est !MEMEARBRE.
+
* De même, la liste des parents de `P` a eu `I` supprimé. `P` a ensuite été complètement enlevé, parce qu'il avait un parent et qu'il est MEMEARBRE.
+
* La liste des parents de `Q` a rendu `Y` simplifié en `X`. `X` a ensuite été supprimé, parce que c'était une racine MEMEARBRE. `Q` a ensuite été complètement supprimée, parce qu'elle avait un parent et qu'il est MEMEARBRE.
--

Il existe un autre mode de simplification :

`--ancestry-path[=<commit>]`::
	Limit the displayed commits to those which are an ancestor of _<commit>_, or which are a descendant of _<commit>_, or are _<commit>_ itself.
+
À titre d'exemple, considérons l'historique de commits suivant :
+
-----------------------------------------------------------------------
	    D---E-------F
	   /     \       \
	  B---C---G---H---I---J
	 /                     \
	A-------K---------------L--M
-----------------------------------------------------------------------
+
A regular 'D..M' computes the set of commits that are ancestors of `M`, but excludes the ones that are ancestors of `D`. This is useful to see what happened to the history leading to `M` since `D`, in the sense that "what does `M` have that did not exist in `D`". The result in this example would be all the commits, except `A` and `B` (and `D` itself, of course).
+
When we want to find out what commits in `M` are contaminated with the bug introduced by `D` and need fixing, however, we might want to view only the subset of `D..M` that are actually descendants of `D`, i.e. excluding `C` and `K`. This is exactly what the `--ancestry-path` option does. Applied to the `D..M` range, it results in:
+
-----------------------------------------------------------------------
		E-------F
		 \       \
		  G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
We can also use `--ancestry-path=D` instead of `--ancestry-path` which means the same thing when applied to the `D..M` range but is just more explicit.
+
Si nous sommes plutôt intéressés par un sujet donné dans cette plage, et tous les commits affectés par ce sujet, nous pouvons seulement vouloir voir ceux du sous-ensemble de `D..M` qui contiennent ce sujet dans leur chemin d'ascendance. Ainsi, en utilisant `--ancestry-path=H D..M` par exemple, on obtiendrait le résultat suivant :
+
-----------------------------------------------------------------------
		E
		 \
	      C---G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
Alors que `--ancestry-path=K D...M` donnerait comme résultat
+
-----------------------------------------------------------------------
		K---------------L--M
-----------------------------------------------------------------------

Avant de discuter d'une autre option, `--show-pulls`, nous devons créer un nouvel exemple d'historique.

Un problème courant auquel les utilisateurs sont confrontés lorsqu'ils consultent l'historique simplifié est qu'un commit dont ils savent qu'il a modifié un fichier n'apparaît pas dans l'historique simplifié du fichier. Prenons un nouvel exemple et montrons comment des options telles que `--full-history` et `--simplify-merges` fonctionnent dans ce cas :

-----------------------------------------------------------------------
	  .-A---M-----C--N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`-Z'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `---Y--'
-----------------------------------------------------------------------

Pour cet exemple, supposons que `I` a créé `fichier.txt` qui a été modifié par `A`, `B` et `X` de différentes manières. Les commits à parent unique `C`, `Z` et `Y` ne modifient pas `fichier.txt`. Le commit de fusion `M` a été créé en résolvant le conflit de fusion pour inclure les deux modifications de `A` et `B` et n'est donc pas MEMEARBRE pour l'un ou l'autre. Le commit de fusion `R`, cependant, a été créé en ignorant le contenu du fichier `fichier.txt` à `M` et en prenant seulement le contenu du fichier `fichier.txt` à `X`. Par conséquent, `R` est MEMEARBRE à `X` mais pas à `M`. Enfin, la résolution de fusion naturelle pour créer `N` est de prendre le contenu du `fichier.txt` à `R`, donc `N` est MEMEARBRE à `R` mais pas à `C`. La fusion engage `O` et `P` sont MEMEARBRE à leurs premiers parents, mais pas à leurs seconds parents, `Z` et `Y` respectivement.

En utilisant le mode par défaut, `N` et `R` ont tous deux un parent MEMEARBRE, donc ces bords sont parcourus et les autres sont ignorés. Le graphique d'historique qui en résulte est :

-----------------------------------------------------------------------
	I---X
-----------------------------------------------------------------------

Lors de l'utilisation de `--full-history`, Git parcourt toutes les arêtes . Il découvrira les commits `A` et `B` et la fusion `M`, mais aussi les commits de fusion `O` et `P`. Avec la réécriture des parents, le graphe résultant est :

-----------------------------------------------------------------------
	  .-A---M--------N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`--'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `------'
-----------------------------------------------------------------------

Ici, les commits de fusion `O` et `P` apportent un bruit supplémentaire, car ils n'ont pas réellement apporté de modification à `fichier.txt`. Ils ont seulement fusionné une branche thématique qui était basée sur une ancienne version de `fichier.txt`. C'est un problème courant dans les dépôts utilisant une organisation où de nombreux contributeurs travaillent en parallèle et fusionnent leurs branches thématiques le long d'un seul tronc : de nombreuses fusions sans rapport apparaissent dans les résultats de `--full-history`.

Lorsque l'on utilise l'option `--simplify-merges`, les valeurs `O` et `P` disparaissent des résultats. Cela est dû au fait que les seconds parents réécrits de `O` et `P` sont accessibles depuis leurs premiers parents. Ces arêtes sont supprimées et les commits ressemblent alors à des commits monoparentaux qui sont MEMEARBRE pour leur parent. C'est également le cas pour le commit `N`, ce qui donne l'historique suivant :

-----------------------------------------------------------------------
	  .-A---M--.
	 /     /    \
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------

Dans cette optique, nous voyons toutes les modifications monoparentales de `A`, `B` et `X`. Nous voyons également la fusion `M`, soigneusement résolue, et la fusion `R`, pas si soigneusement résolue. Ces informations sont généralement suffisantes pour déterminer pourquoi les commits `A` et `B` ont « disparu » de l'historique dans la vue par défaut. Cependant, cette approche pose quelques problèmes.

La première question est celle de la performance. Contrairement à toutes les options précédentes, l'option `--simplify-merges` nécessite de parcourir l'historique complet des commits avant de renvoyer un seul résultat. Cela peut rendre l'option difficile à utiliser pour les très grands dépôts.

La deuxième question est celle de l'audit. Lorsque plusieurs contributeurs travaillent sur le même dépôt, il est important de savoir quels commits de fusion ont introduit un changement dans une branche importante. La fusion problématique `R` ci-dessus n'est probablement pas le commit de fusion qui a été utilisé pour fusionner dans une branche importante. Au lieu de cela, la fusion `N` a été utilisée pour fusionner `R` et `X` dans la branche importante. Ce commit peut avoir des informations sur la raison pour laquelle la modifcation `X` est venu remplacer les changements de `A` et `B` dans son message de commit.

`--show-pulls`::
	En plus des commits indiqués dans l’historique par défaut, montrer chaque commit de fusion qui n’est pas MEMEARBRE à son premier parent, mais qui est MEMEARBRE à un parent ultérieur.
+
Quand un commit de fusion est inclus par `--show-pulls`, cette fusion est traitée comme si elle avait "tiré" le changement d'une autre branche. Lorsque l'on utilise `--show-pulls` sur cet exemple (et aucune autre option), le graphe résultant est :
+
-----------------------------------------------------------------------
	I---X---R---N
-----------------------------------------------------------------------
+
Ici, les commits de fusion `R` et `N` sont inclus, car ils ont tiré les commits `X` et `R` dans la branche de base, respectivement. Ces fusions sont les raisons pour lesquelles les commits `A` et `B` n'apparaissent pas dans l'historique par défaut.
+
Lorsque l'option `--show-pulls` est associée à l'option `--simplify-merges`, le graphe comprend toutes les informations nécessaires :
+
-----------------------------------------------------------------------
	  .-A---M--.   N
	 /     /    \ /
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------
+
Remarquez que puisque `M` est accessible à partir de `R`, l'arête entre `N` et `M` a été simplifiée. Cependant, `N` apparaît toujours dans l'historique comme un commit important parce qu'il a « tiré » le changement `R` dans la branche principale.

L'option `--simplify-by-decoration` vous donne une vue d'ensemble de la topologie de l'historique, en omettant les commits qui ne sont pas référencés par des étiquettes. Les commits sont marqués comme !MEMEARBRE(en d'autres termes, conservés après les règles de simplification de l'historique décrites ci-dessus) si (1) ils sont référencés par des étiquettes, ou (2) ils changent le contenu des chemins donnés sur la ligne de commande. Tous les autres commits sont marqués comme MEMEARBRE (soumis à une possible simplification).

ifndef::git-shortlog[]
ifdef::git-rev-list[]
Assistants de bissection
~~~~~~~~~~~~~~~~~~~~~~~~

`--bisect`::
	Limiter la sortie à l'objet commit qui est à peu près à mi-chemin entre les commits inclus et les commits exclus. Notez que la référence mauvaise de bissection `refs/bisect/bad` est ajoutée aux commits inclus (si elle existe) et la référence bonne de bissection `refs/bisect/good-*` est ajoutée aux commits exclus (s'ils existent). Ainsi, en supposant qu'il n'y ait pas de références dans `refs/bisect/`, si
+
-----------------------------------------------------------------------
	$ git rev-list --bisect foo ^bar ^baz
-----------------------------------------------------------------------
+
affiche 'midpoint', la sortie des deux commandes
+
-----------------------------------------------------------------------
	$ git rev-list foo ^midpoint
	$ git rev-list midpoint ^bar ^baz
-----------------------------------------------------------------------
+
seraient à peu près de la même longueur. Trouver le changement qui introduit une régression se réduit donc à une recherche binaire : générer et tester à plusieurs reprises de nouveaux 'midpoint' jusqu'à ce que la chaîne de commits soit de longueur un.

`--bisect-vars`::
	Cela calcule la même chose que `--bisect`, sauf que les références dans `refs/bisect/` ne sont pas utilisées, et sauf que cela affiche un texte prêt à être évalué par le shell. Ces lignes attribueront le nom de la révision à mi-parcours à la variable `bisect_rev`, et le nombre prévu de commits à tester après `bisect_rev` est testé à `bisect_nr`, le nombre prévu de commits à tester si `bisect_rev` s'avère être bon à `bisect_good`, le nombre prévu de commits à tester si `bisect_rev` s'avère être mauvais à `bisect_bad`, et le nombre de commits que nous sommes en train de bissecter en ce moment à `bisect_all`.

`--bisect-all`::
	Ceci affiche tous les objets commit entre les commits inclus et exclus, classés selon leur distance par rapport aux commits inclus et exclus. Les références dans `refs/bisect/` ne sont pas utilisées. Le plus éloigné d'eux est affiché en premier. (C'est le seul affiché par `--bisect`.)
+
Ceci est utile car il est facile de choisir un bon commit à tester lorsque vous voulez éviter de tester certains d'entre eux pour une raison quelconque (ils peuvent ne pas compiler par exemple).
+
Cette option peut être utilisée avec `--bisect-vars`, dans ce cas, après tous les objets commit triés, le texte sera le même que si `--bisect-vars` avait été utilisé seul.
endif::git-rev-list[]
endif::git-shortlog[]

ifndef::git-shortlog[]
Ordre des commits
~~~~~~~~~~~~~~~~~

Par défaut, les commits sont affichés dans l'ordre chronologique inverse.

`--date-order`::
	N'afficher aucun parent avant que tous ses enfants ne soient affichés, mais sinon montrer les commits dans l'ordre de l'horodatage des commits.

`--author-date-order`::
	N'afficher aucun parent avant que tous ses enfants ne soient affichés, mais autrement afficher les commits dans l'ordre d'horodatage de l'auteur.

`--topo-order`::
	N'afficher aucun parent avant que tous ses enfants ne soient affichés, et éviter d'afficher des commits entremêlés sur plusieurs lignes d'historique.
+
Par exemple, dans un historique de commit comme celui-ci :
+
----------------------------------------------------------------

    ---1----2----4----7
	\	       \
	 3----5----6----8---

----------------------------------------------------------------
+
où les nombres indiquent l'ordre des horodatages de commit, `git rev-list` et consorts avec `--date-order` affichent les commits dans l'ordre d'horodatage : 8 7 6 5 4 3 2 1.
+
Avec `--topo-order`, ils afficheraient 8 6 5 5 3 3 7 4 7 4 2 1 (ou 8 7 4 2 2 6 5 5 3 1) ; certains commits plus anciens sont affichés avant les plus récents afin d'éviter de montrer mélangés ensemble les commits de deux pistes de développement parallèles.

`--reverse`::
	Output the commits chosen to be shown (see 'Commit Limiting' section above) in reverse order. Cannot be combined with `--walk-reflogs`.
endif::git-shortlog[]

ifndef::git-shortlog[]
Traversée d'objets
~~~~~~~~~~~~~~~~~~

Ces options sont principalement destinées à l'empaquetage des dépôts Git.

ifdef::git-rev-list[]
`--objects`::
	Print the object IDs of any object referenced by the listed commits. `--objects foo ^bar` thus means "send me all object IDs which I need to download if I have the commit object `bar` but not `foo`". See also `--object-names` below.

`--in-commit-order`::
	Imprimer les identifiants des arbres et des blobs dans l'ordre des commits. Les identifiants des arbres et des blobs sont imprimés que lors qu'ils sont référencés la première fois par un commit.

`--objects-edge`::
	Similar to `--objects`, but also print the IDs of excluded commits prefixed with a "`-`" character. This is used by linkgit:git-pack-objects[1] to build a ``thin'' pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic.

`--objects-edge-aggressive`::
	Similaire à `--objects-edge`, mais s'efforce de trouver les commits exclus au prix d'un temps plus long de traitement. Ceci est utilisé à la place de `--objects-edge` pour construire des paquets ``thin'' pour les dépôts superficiels.

`--indexed-objects`::
	Faire comme si tous les arbres et tous les blobs utilisés par l'index étaient listés sur la ligne de commande. Notez que vous voudrez probablement utiliser aussi `--objects`.

`--unpacked`::
	Uniquement utile avec `--objects` ; afficher les ID d'objets qui ne sont pas dans les paquets.

`--object-names`::
	Uniquement utile avec `--objects` ; affiche les noms des IDs d'objets trouvés. C'est le comportement par défaut. Notez que le "nom" de chaque objet est ambigu, et qu'il est principalement destiné à servir d'indice pour l'empaquetage des objets. En particulier : aucune distinction n'est faite entre les noms des étiquettes, des arbres et des blobs ; les noms des chemins peuvent être modifiés pour supprimer les nouvelles lignes ; et si un objet apparaît plusieurs fois avec des noms différents, un seul nom est affiché.

`--no-object-names`::
	Uniquement utile avec `--objects` ; ne pas afficher les noms des ID des objets trouvés. Ceci inverse `--object-names`. Ce drapeau permet à la sortie d'être plus facilement analysée par des commandes telles que linkgit:git-cat-file[1].

`--filter=<spéc. du filtre>`::
	Only useful with one of the `--objects*`; omits objects (usually blobs) from the list of printed objects. The _<filter-spec>_ may be one of the following:
+
The form `--filter=blob:none` omits all blobs.
+
The form `--filter=blob:limit=<n>[kmg]` omits blobs of size at least _<n>_ bytes or units. _<n>_ may be zero. The suffixes `k`, `m`, and `g` can be used to name units in KiB, MiB, or GiB. For example, `blob:limit=1k` is the same as 'blob:limit=1024'.
+
The form `--filter=object:type=(tag|commit|tree|blob)` omits all objects which are not of the requested type.
+
The form `--filter=sparse:oid=<blob-ish>` uses a sparse-checkout specification contained in the blob (or blob-expression) _<blob-ish>_ to omit blobs that would not be required for a sparse checkout on the requested refs.
+
The form `--filter=tree:<depth>` omits all blobs and trees whose depth from the root tree is >= _<depth>_ (minimum depth if an object is located at multiple depths in the commits traversed). _<depth>_=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when `--stdin` is used). _<depth>_=1 will include only the tree and blobs which are referenced directly by a commit reachable from _<commit>_ or an explicitly-given object. _<depth>_=2 is like <depth>=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.
+
Note that the form `--filter=sparse:path=<path>` that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.
+
Multiple `--filter=` flags can be specified to combine filters. Only objects which are accepted by every filter are included.
+
The form `--filter=combine:<filter1>+<filter2>+...<filterN>` can also be used to combined several filters, but this is harder than just repeating the `--filter` flag and is usually not necessary. Filters are joined by '{plus}' and individual filters are %-encoded (i.e. URL-encoded). Besides the '{plus}' and '%' characters, the following characters are reserved and also must be encoded: `~!@#$^&*()[]{}\;",<>?`+&#39;&#96;+ as well as all characters with ASCII code &lt;= `0x20`, which includes space and newline.
+
Other arbitrary characters can also be encoded. For instance, `combine:tree:3+blob:none` and `combine:tree%3A3+blob%3Anone` are equivalent.

`--no-filter`::
	Désactiver tout argument `--filter=` précédent.

`--filter-provided-objects`::
	Filtrer la liste des objets explicitement fournis, qui autrement seraient toujours imprimés même s'ils ne correspondent à aucun des filtres. Seulement utile avec `--filter=`.

`--filter-print-omitted`::
	Uniquement utile avec `--filter=` ; imprimer une liste des objets omis par le filtre. Les ID d'objet sont préfixés par un caractère "~".

`--missing=<missing-action>`::
	Une option de débogage pour aider au développement futur de "clones partiels". Cette option spécifie comment les objets manquants sont traités.
+
The form `--missing=error` requests that rev-list stop with an error if a missing object is encountered. This is the default action.
+
The form `--missing=allow-any` will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.
+
The form `--missing=allow-promisor` is like `allow-any`, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.
+
The form `--missing=print` is like `allow-any`, but will also print a list of the missing objects. Object IDs are prefixed with a ``?'' character.
+
La forme `--missing=print-info` est comme `print`, mais il va également afficher des informations supplémentaires sur l'objet manquant inféré de son objet contenant. Les informations sont toutes affichées sur la même ligne avec l'identifiant de l'objet manquant dans la forme: `? <oid> [<jeton>=<valeur>]...` . Les paires `<jeton>=<valeur>` contenant des informations supplémentaires sont séparées les unes des autres par un caractères _SP_. La valeur est encodée d'une manière spécifique, mais les _SP_ ou _LF_ contenus une valeur sont toujours censés être représentés de telle sorte que la valeur encodée résultante n'ait pas l'un de ces deux octets problématiques. Chaque `<jeton>=<valeur>` peut être :
+
--
* The `path=<path>` shows the path of the missing object inferred from a containing object. A path containing _SP_ or special characters is enclosed in double-quotes in the C style as needed.
+
* Le terme `type=<type>` montre le type de l'objet manquant inféré d'un objet contenant.
--
+
Si quelques sommets passés à la traversée sont manquants, ils seront considérés comme manquants aussi, et la traversée les ignorera. Dans le cas où nous ne pouvons pas obtenir leur ID Objet, une erreur sera soulevée.

`--exclude-promisor-objects`::
	(Pour usage interne seulement.) Préfiltrer la traversée de l'objet à la limite du promettant. Ceci est utilisé avec un clone partiel. C'est plus fort que `--missing=allow-promisor` parce qu'il limite la traversée, plutôt que de simplement réduire au silence les erreurs sur les objets manquants.
endif::git-rev-list[]

`--no-walk[=(sorted|unsorted)]`::
	Montrer seulement les commits donnés, mais ne pas traverser leurs ancêtres. Ceci n'a aucun effet si une plage est spécifiée. Si l'argument `unsorted` est donné, les commits sont affichés dans l'ordre dans lequel ils ont été donnés sur la ligne de commande. Sinon (si `sorted` ou aucun argument n'a été donné), les commits sont affichés dans l'ordre chronologique inverse par date de validation. Ne peut pas être combiné avec `--graph`.

`--do-walk`::
	Remplacer un `--no-walk` précédent.
endif::git-shortlog[]

ifndef::git-shortlog[]
Formatage des commits
~~~~~~~~~~~~~~~~~~~~~

ifdef::git-rev-list[]
En utilisant ces options, linkgit:git-rev-list[1] agira de la même manière que la famille plus spécialisée d'outils de journaux de validation :
ifndef::with-breaking-changes[]
linkgit:git-log[1], linkgit:git-show[1] et linkgit:git-whatchanged[1].
endif::with-breaking-changes[]
ifdef::with-breaking-changes[]
linkgit:git-log[1] et linkgit:git-show[1].
endif::with-breaking-changes[]
endif::git-rev-list[]

include::pretty-options.adoc[]

`--relative-date`::
	Synonyme de `--date=relative`.

`--date=<format>`::
	Ne prendre effet que pour les dates indiquées dans un format lisible par l'homme, par exemple lors de l'utilisation de `--pretty`. La variable config `log.date` définit une valeur par défaut pour l'option `--date` de la commande log. Par défaut, les dates sont affichées dans le fuseau horaire d'origine (soit celui du validateur ou celui de l'auteur). Si `-local` est ajouté au format (p. ex., `iso-local`), le fuseau horaire local de l'utilisateur est utilisé à la place.
+
--
`--date=relative` affiche les dates relatives à l'heure actuelle, par exemple ``Il y a 2 heures''. L'option `-local` n'a aucun effet pour `--date=relative`.

`--date=local` est un alias pour `--date=default-local`.

`--date=iso` (ou `--date=iso8601`) montre les horodatages dans un format similaire à ISO 8601. Les différences par rapport au format strict ISO 8601 sont :

	- une espace au lieu du délimiteur date/heure `T`
	- une espace entre l'heure et le fuseau horaire
	- pas de deux points entre les heures et les minutes du fuseau horaire

`--date=iso-strict` (ou `--date=iso8601-strict`) affiche les horodatages au format ISO 8601 strict.

`--date=rfc` (ou `--date=rfc2822`) montre les horodatages au format RFC 2822, souvent trouvés dans les messages électroniques.

`--date=short` montre seulement la date, mais pas l'heure, au format `AAA-MM-JJ`.

`--date=raw` montre la date en secondes depuis l'époque (1970-01-01 00:00:00 UTC), suivi d'une espace, puis le fuseau horaire en décalage par rapport à UTC (un `+` ou `-` avec quatre chiffres ; les deux premiers sont des heures, et les deux seconds des minutes), c'est-à-dire comme si l'horodatage était formaté avec `strftime("%s %z")`). Notez que l'option `-local` n'affecte pas la valeur des secondes depuis l'écho (qui est toujours mesurée en UTC), mais commute la valeur du fuseau horaire qui l'accompagne.

`--date=human` montre le fuseau horaire si le fuseau horaire ne correspond pas au fuseau horaire actuel, et n'affiche pas la date complète s'il y a correspondance (c'est-à-dire ne pas afficher l'année pour les dates qui sont "cette année", mais aussi sauter la date complète elle-même si elle est dans les derniers jours et que nous pouvons juste indiquer le jour de la semaine passée). Pour les dates plus anciennes, l'heure et la minute sont également omises.

`--date=unix` affiche la date sous forme d'un horodatage d'époque Unix (secondes depuis 1970). Comme dans le cas de `--raw`, c'est toujours en UTC et donc `-local` n'a aucun effet.

`--date=format:<format>` feeds the _<format>_ to your system `strftime`, except for `%s`, `%z`, and `%Z`, which are handled internally. Use `--date=format:%c` to show the date in your system locale's preferred format. See the `strftime`(3) manual for a complete list of format placeholders. When using `-local`, the correct syntax is `--date=format-local:<format>`.

`--date=default` est le format par défaut, et est basé sur la sortie de ctime(3). Il affiche une seule ligne avec le jour de la semaine à trois lettres, le mois à trois lettres, le jour du mois, l'heure, la minute et la seconde au format "HH:MM:SS", suivi de l'année à 4 chiffres, plus les informations du fuseau horaire, à moins que le fuseau horaire local ne soit utilisé, par exemple `Thu Jan 1 00:00:00 1970 +0000`.
--

ifdef::git-rev-list[]
`--header`::
	Afficher le contenu du commit en format brut ; chaque enregistrement est séparé par un caractère NUL.

`--no-commit-header`::
	Supprime la ligne d'en-tête contenant "commit" et l'ID de l'objet affiché avant le format spécifié. Ceci n'a aucun effet sur les formats intégrés ; seuls les formats personnalisés sont concernés.

`--commit-header`::
	Remplacer un `--no-commit-header` précédent.
endif::git-rev-list[]

`--parents`::
	Afficher aussi les parents du commit (sous la forme "parent du commit..."). Permet également la réécriture des parents, voir " Simplification de l'historique " ci-dessus.

`--children`::
	Afficher aussi les enfants du commit (sous la forme "commit child..."). Permet également la réécriture des parents, voir " Simplification de l'historique " ci-dessus.

ifdef::git-rev-list[]
`--timestamp`::
	Imprimer l'horodatage brut du commit.
endif::git-rev-list[]

`--left-right`::
	Indiquer de quel côté d'une différence symétrique un commit est accessible. Les commits de gauche sont préfixés par " < " et ceux de droite par " > ". Si on combine avec `--boundary`, ces commits sont préfixés par `-`.
+
Par exemple, si vous avez cette topologie :
+
-----------------------------------------------------------------------
	     y---b---b  branche B
	    / \ /
	   /   .
	  /   / \
	 o---x---a---a  branche A
-----------------------------------------------------------------------
+
vous obtiendriez une sortie comme celle-ci :
+
-----------------------------------------------------------------------
	$ git rev-list --left-right --boundary --pretty=oneline A...B

	>bbbbbbb... 3rd on b
	>bbbbbbb... 2nd on b
	<aaaaaaa... 3rd on a
	<aaaaaaa... 2nd on a
	-yyyyyyy... 1st on b
	-xxxxxxx... 1st on a
-----------------------------------------------------------------------

`--graph`::
	Dessiner une représentation graphique en texte de l'historique du commit sur la gauche de la sortie. Cela peut entraîner l'impression de lignes supplémentaires entre les validations, afin que l'historique du graphique soit correctement tracé. Ne peut pas être combiné avec `--no-walk`.
+
Cela permet la réécriture des parents, voir « Simplification de l'historique » ci-dessus.
+
Cela implique l'option `--topo-order` par défaut, mais l'option `--date-order` peut aussi être spécifiée.

`--show-linear-break[=<barrier>]`::
	When `--graph` is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If _<barrier>_ is specified, it is the string that will be shown instead of the default one.

ifdef::git-rev-list[]
`--count`::
	Imprimer un nombre indiquant combien de commits auraient été listés, et supprimer toutes les autres sorties. Lorsqu'il est utilisé avec `--left-right`, imprimer à la place les comptes des commits gauche et droite, séparés par une tabulation. Lorsqu'utilisé avec `--cherry-mark`, omettre les commits équivalents de rustines de ces comptes et imprimer le compte des commits équivalents séparés par une tabulation.
endif::git-rev-list[]
endif::git-shortlog[]
