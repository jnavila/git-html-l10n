git-checkout(1)
===============

NOM
---
git-checkout - Bascule sur une autre branche ou restaure des fichiers de l'arbre de travail

SYNOPSIS
--------
[synopsis]
git checkout [-q] [-f] [-m] [<branche>]
git checkout [-q] [-f] [-m] --detach [<branche>]
git checkout [-q] [-f] [-m] [--detach] <commit>
git checkout [-q] [-f] [-m] [[-b|-B|--orphan] <nouvelle-branche>] [<point-de-départ>]
git checkout <arbre-esque> [--] <spec-de-chemin>...
git checkout <arbre-esque> --pathspec-from-file=<fichier> [--pathspec-file-nul]
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [--] <spec-de-chemin>...
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] --pathspec-from-file=<fichier> [--pathspec-file-nul]
git checkout (-p|--patch) [<arbre-esque>] [--] [<spec-de-chemin>...]

DESCRIPTION
-----------

`git checkout` a deux modes principaux :

1. **Basculer de branche**, avec `git checkout <branche>`
2. **Restaurer une autre version d'un fichier**, par exemple avec `git checkout <commit> <nom-de-fichier>` ou `git checkout <nom-de-fichier>`

Voir DÉSAMBIGUÏSATION D'ARGUMENT ci-dessous pour la façon dont Git décide lequel utiliser.

`git checkout [<branche>]`::
	Passage à _<branche>_. Cela définit la branche actuelle à _ <branche>_ et met à jour les fichiers dans votre répertoire de travail. L'extraction échouera s'il n'y a des changements non validés dans les fichiers où _< branche>_ et votre commit actuel ont un contenu différent. Les changements non validés seront conservés sinon.
+
Si la _<branche>_ n'est pas trouvée mais qu'il existe une branche de suivi pour un dépôt distant unique (appelé _<distant>_) avec un nom correspondant et `--no-guess` n'est pas spécifié, le traiter comme équivalent à
+
------------
$ git checkout -b <branche> --track <distant>/<branche>
------------
+
Lancer `git checkout` sans spécifier une branche n'a aucun effet sauf pour afficher les informations de suivi pour la branche actuelle.

`git checkout -b <nouvelle-branche> [<point-de-départ>]`::

	Créer une nouvelle branche nommée _<nouvelle-branche>_, la commencer à _<point-de-départ>_ (par défaut le commit actuel), et basculer sur cette nouvelle branche. Vous pouvez utiliser les options `--track` ou `--no-track` pour renseigner l'information de suivi amont de cette branche.
+
Cela échouera s'il y a une erreur lors de l'extraction de _<nouvelle-branche>, par exemple si extraire le commit _<point-de-départ>_ écraserait vos changements non validés.

`git checkout -B <nouvelle-branche> [<point-de-départ>]`::

	La même chose que `-b`, sauf que si la branche existe déjà, Git réinitialise _<branche>_ au point de départ au lieu d'échouer.

`git checkout --detach [<branche>]`::
`git checkout [--detach] <commit>`::

	La même chose que `git checkout <branche>`, sauf que, au lieu de pointer `HEAD` sur la branche, pointe `HEAD` à l'ID de commit. Voir la section HEAD DÉTACHÉE ci-dessous pour plus de détails.
+
Omettre _<branche>_ détache `HEAD` au sommet de la branche actuelle.

`git checkout <arbre-esque> [--] <spéc-de-chemin>...`::
`git checkout <arbre-esque> --pathspec-from-file=<fichier> [--pathspec-file-nul]`::

	Remplacer les fichiers et/ou les répertoires spécifiés par la version du commit ou de l'arbre donné et les ajouter à l'index (également connu sous le nom de « zone de préparation »).
+
Par exemple, `git checkout main fichier.txt` remplacera `fichier.txt` par sa version dans `main`.

`git checkout [-f | --ours | --theirs | -m | --conflict=<style>] [--] <spéc-de-chemin>...`::
`git checkout [-f|--ours|--theirs|-m|--conflict=<style>] --pathspec-from-file=<fichier> [--pathspec-file-nul]`::

	Remplacer les fichiers et/ou les répertoires spécifiés par la version de l'index.
+
Par exemple, si vous extrayez un commit, puis modifiez `fichier.txt`, puis décidez que ces changements étaient une erreur, `git checkout fichier.txt` va supprimer tout changement non indexé dans `fichier.txt`.
+
Cela échouera si le fichier a un conflit de fusion et vous n'avez pas encore lancé `git add fichier.txt` (ou quelque chose d'équivalent) pour le marquer comme résolu. Vous pouvez utiliser `-f` pour ignorer les fichiers non fusionnés au lieu d'échouer, utiliser `--ours` ou `--theirs` pour les remplacer par la version d'un côté spécifique de la fusion, ou utiliser `-m` pour les remplacer par le résultat original du conflit de fusion.

`git checkout (-p|--patch) [<arbre-esque>] [--] [<spéc. de chemin>...]`::
	C'est similaire aux deux modes précédents, mais vous laisse utiliser l'interface interactive pour afficher la sortie « diff » et choisir quelles sections utiliser dans le résultat. Voir plus bas la description de l'option `--patch`.

OPTIONS
-------
`-q`::
`--quiet`::
	Silencieux, supprimer les messages d'état.

`--progress`::
`--no-progress`::
	L'état d'avancement est affiché sur la sortie standard d'erreur par défaut quand elle est attachée à un terminal, à moins que `--quiet` ne soit spécifié. Cette bascule active l'état d'avancement même sans être attaché à un terminal, indépendamment de `--quiet`.

`-f`::
`--force`::
	Lors du basculement de branche, continuer même si l'index ou l'arbre de travail sont différents de `HEAD`, et même s'il y a des fichiers non-suivis qui bloquent.Ceci peut servir à éliminer des modifications locales ainsi que tous les fichiers ou répertoires non-suivis qui gênent.
+
Lors de l'extraction de chemins depuis l'index, ne pas échouer sur des entrées non fusionnées ; à la place, les entrées non fusionnées sont ignorées.

`--ours`::
`--theirs`::
	Lors de l'extraction de chemins depuis l'index, extraire l'état #2 (`ours`, le nôtre) ou #3 (`theirs`, le leur) pour les chemins non fusionnés.
+
Veuillez noter que pendant `git rebase` et `git pull --rebase`, `ours` et `theirs` peuvent sembler échangés ; `--ours` fournit la version depuis la branche sur laquelle les modifications sont rebasées, tandis que `--theirs` fournit la version de la branche qui contient le travail rebasé.
+
C'est parce que `rebase` est utilisé dans une approche qui traite l'historique distant comme la référence canonique partagée, et traite le travail sur la branche que vous rebasez comme un travail tiers à intégrer, et vous endossez temporairement le rôle du gardien de l'historique canonique quand vous rebasez. En tant que gardien de l'historique canonique, vous devez voir l'historique distant comme le vôtre ('ours', c'est-à-dire « notre historique partagé canonique »), tandis que votre travail sur l'autre branche devient le tiers ('theirs', c'est-à-dire « le travail d'un contributeur sur le canonique »).

`-b <nouvelle-branche>`::
	Créer une nouvelle branche nommée _<nouvelle-branche>_, la commencer à _<point-de-départ>_ et extraire la branche résultante ; voir linkgit:git-branch[1] pour plus de détails.

`-B <nouvelle-branche>`::
	La même chose que `-b`, sauf que si la branche existe déjà, Git réinitialise _<branche>_ au point de départ au lieu d'échouer.

`-t`::
`--track[=(direct|inherit)]`::
	À la création d'une nouvelle branche, établir la configuration 'upstream' (branche amont). Voir `--track` dans linkgit:git-branch[1] pour plus de détails. Par commodité, `--track` sans `-b` implique la création de la branche.
+
Si aucune option `-b` n'est fournie, le nom de la nouvelle branche sera dérivé de la branche de suivi à distance, en regardant la partie locale de la spécification de référence configurée pour le distant correspondant et en enlevant la partie initiale jusqu'au "*". Cela indiquerait d'utiliser le nom « `hack` » comme branche locale créée à partir de `origin/hack` (ou `remotes/origin/hack`, ou même `refs/remotes/origin/hack`). Si le nom fourni ne contient pas de barre oblique, ou si le résultat de la dérivation est un nom vide, la dérivation échoue. Vous pouvez spécifier explicitement un nom avec `-b` dans ce cas.

`--no-track`::
	Ne pas renseigner la configuration « amont », même si la configuration `branch.autoSetupMerge` est true.

`--guess`::
`--no-guess`::
	Si la _<branche>_ n'est pas trouvée mais qu'il existe une branche de suivi pour un dépôt distant unique (appelé _<distant>_) avec un nom correspondant, le traiter comme équivalent à
+
------------
$ git checkout -b <branche> --track <distant>/<branche>
------------
+
Si la branche existe dans plus d'un distant et que l'un d'entre eux est la valeur de la variable de configuration `checkout.defaultRemote`, celui-ci sera utilisé pour désambiguïser, même si la _<branche>_ n'est pas unique parmi tous les distants. Réglez la variable `checkout.defaultRemote=origin` par exemple pour extraire toujours les branches distantes depuis celle-ci si _<branche>_ est ambigüe mais existe sur le distant 'origin'. Voir aussi `checkout.defaultRemote` dans linkgit:git-config[1].
+
`--guess` est le comportement par défaut. Utilisez `--no-guess` pour le désactiver.
+
Le comportement par défaut peut être défini via la variable de configuration `checkout.guess`.

`-l`::
	Créer le reflog de la nouvelle branche ; voir linkgit:git-branch[1] pour plus de détails.

`-d`::
`--detach`::
	Plutôt que d'extraire une branche pour travailler dessus, extraire un commit pour l'inspecter et faire des expériences jetables. C'est le comportement par défaut de `git checkout <commit>` quand _<commit>_ n'est pas un nom de branche. Voir la section « HEAD DÉTACHÉE » plus bas pour plus de détails.

`--orphan <nouvelle-branche>`::
	Créer une nouvelle branche non née, nommée _<nouvelle-branche>_, commençant depuis _<point-de-départ>_ et basculer dessus. Le premier commit réalisé sur cette branche n'aura pas de parent et il sera la racine du nouvel historique totalement déconnecté de toutes les autres branches et des autres commits.
+
L'index et l'arbre de travail sont ajustés comme si vous aviez déjà lancé `git checkout <point-de-départ>`. Cela vous permet de démarrer un nouvel historique qui enregistre un ensemble de chemins similaires à _<point-de-départ>_ en lançant simplement `git commit -a` pour créer le commit racine.
+
Ceci peut être utile quand vous souhaitez publier un arbre depuis un commit sans exposer tout son historique. Vous pourriez souhaiter le faire pour publier une branche open source d'un projet dont l'arbre présent est « propre », mais dont l'historique complet contient des morceaux de code propriétaire ou autrement non publiables.
+
Si vous voulez démarrer un historique déconnecté qui enregistre un ensemble de chemins qui sont totalement différents de celui de _<point-de-départ>_, vous devriez effacer l'index et l'arbre de travail juste après avoir créé la branche orpheline en lançant `git rm -rf .` depuis la racine de l'arbre de travail. Après, vous pourrez préparer vos nouveaux fichiers, pour repeupler l'arbre de travail, en les copiant depuis un autre endroit, en les extrayant depuis une archive, etc.

`--ignore-skip-worktree-bits`::
	En mode d'extraction clairsemé, `git checkout -- <chemin>...` mettrait seulement à jour les entrées correspondant à _<chemins>_ et aux motifs clairsemés dans `$GIT_DIR/info/sparse-checkout`. Cette option ignore les motifs clairsemés et ré-ajoute tous les fichiers de _<chemins>_.

`-m`::
`--merge`::
	Lors d'un basculement de branche, si vous avez des modifications locales sur un fichier ou plus qui sont différentes entre la branche actuelle et celle sur laquelle vous basculez, la commande refuse le basculement pour préserver vos modifications dans leur contexte. Cependant, avec cette option, une fusion à trois points entre la branche actuelle, le contenu de votre arbre de travail et la nouvelle branche est opérée et vous serez sur la nouvelle branche.
+
Quand un conflit de fusion apparaît, les entrées d'index pour les chemins en conflit sont laissées non-fusionnées et vous devez résoudre les conflits et les marquer résolus pour les chemins concernés avec `git add` (ou `git rm` si la fusion doit aboutir à la suppression du chemin).
+
Lors de l'extraction de chemins depuis l'index, cette option vous permet de récréer la fusion en conflit dans les chemins spécifiés. Cette option ne peut pas être utilisée lors de l'extraction des chemins depuis un arbre-esque.
+
Lors du basculement de branche avec `--merge`, les modifications indexées peuvent être perdues.

`--conflict=<style>`::
	Identique à l'option `--merge` ci-dessus, mais la manière dont les sections en conflits sont présentées est modifiée, en surchargeant la variable de configuration `merge.conflictStyle`. Les valeurs possibles sont `merge` (fusion, par défaut), `diff3` et `zdiff3`.

`-p`::
`--patch`::
	Sélectionner interactivement les sections dans la différence entre l'_<arbre-esque>_ (ou l'index, si non spécifié) et l'arbre de travail. Les sections choisies sont ensuite appliquées en ordre inversé à l'arbre de travail (et si un _<arbre-esque>_ a été spécifié, à l'index).
+
Ceci signifie que vous pouvez utiliser `git checkout -p` pour supprimer sélectivement les éditions depuis votre arbre de travail actuel. Voir la section « Mode Interactif » de linkgit:git-add[1] pour apprendre à utiliser le mode `--patch`.
+
Notez que cette option utilise par défaut le mode sans superposition (voir aussi `--overlay`), et ne supporte pas actuellement le mode superposition.

include::diff-context-options.adoc[]

`--ignore-other-worktrees`::
	`git checkout` échoue quand la branche voulue est déjà extraite ou utilisée dans un autre arbre de travail. Cette option force quand même l'extraction de la branche. En d'autres termes, la branche peut être utilisée par plus d'un arbre de travail.

`--overwrite-ignore`::
`--no-overwrite-ignore`::
	Écraser silencieusement les fichiers ignorés lors du basculement de branche. C'est le comportement par défaut. Utilisez `--no-overwrite-ignore` pour annuler l'opération lorsque la nouvelle branche contient des fichiers ignorés.

`--recurse-submodules`::
`--no-recurse-submodules`::
	L'utilisation de `--recurse-submodules` permet de mettre à jour le contenu de tous les sous-modules actifs en fonction du commit enregistré dans le super-projet. Si des modifications locales au sous-modules seraient écrasées, l'extraction échoue à moins d'utiliser `-f`. Si l'option n'est pas spécifiée (ou si `--no-recurse-submodules` est spécifié), les arbres de travail des sous-modules ne sont pas mis à jour. Comme linkgit:git-submodule[1], la `HEAD` des sous-modules sera détachée.

`--overlay`::
`--no-overlay`::
	Dans le mode de superposition par défaut, `git checkout` ne supprime jamais les fichiers de l’index ou de l’arbre de travail. Lorsque vous spécifiez `--no-overlay`, les fichiers qui apparaissent dans l’index et l’arbre de travail, mais pas dans _<arbre-esque>_ sont supprimés, pour les faire correspondre à _<arbre-esque>_ exactement.

`--pathspec-from-file=<fichier>`::
	Le spécificateur de chemin est passé dans _<fichier>_ au lieu des arguments de la ligne de commande. Si _<fichier>_ vaut `-` alors l'entrée standard est utilisée. Les éléments du spécificateur de chemin sont séparés par _LF_ ou _CR_/_LF_. Les éléments du spécificateur de chemin peuvent être cités comme expliqué pour la variable de configuration `core.quotePath` (voir linkgit:git-config[1]). Voir aussi l'option `--pathspec-file-nul` et l'option globale `--literal-pathspecs`.

`--pathspec-file-nul`::
	Uniquement significatif avec `--pathspec-from-file`. Les éléments du spécificateur de chemin sont séparés par le caractère _NUL_ et tous les autres caractères sont utilisés littéralement (y compris les retours à la ligne et les guillemets).

`<branche>`::
	Branche à extraire ; si c'est une référence à une branche (c'est-à-dire un nom qui, préfixé par « refs/heads/ » est une référence valide), alors cette branche est extraite. Sinon, si c'est une référence à un commit valide, votre `HEAD` devient « détachée » et vous n'êtes plus sur aucune branche (voir plus bas pour plus de détails).
+
Vous pouvez utiliser la syntaxe `@{-N}` pour faire référence à la N-ième dernière branche ou commit extrait en utilisant une opération « git checkout ». Vous pouvez aussi spécifier `-` qui est synonyme de `@{-1}`.
+
Autre cas spécial, vous pouvez utiliser « `<rév-a>...<rév-b>` » comme raccourci pour la base de fusion de _<rév-a>_ et _<rév-b>_ s'il y a exactement une seule base de fusion. Vous pouvez ne pas spécifier _<rév-a>_ ou _<rév-b>_, auquel cas ce sera `HEAD` par défaut.

_<nouvelle-branche>_::
	Nom pour une nouvelle branche.

_<point_de_départ>_::
	Le nom du commit auquel démarrer la nouvelle branche ; voir linkgit:git-branch[1] pour plus de détails. `HEAD` par défaut.
+
Autre cas spécial, vous pouvez utiliser « `<rév-a>...<rév-b>` » comme raccourci pour la base de fusion de _<rév-a>_ et _<rév-b>_ s'il y a exactement une seule base de fusion. Vous pouvez ne pas spécifier _<rév-a>_ ou _<rév-b>_, auquel cas ce sera `HEAD` par défaut.

_<arbre-esque>_::
	Arbre depuis lequel extraire (quand des chemins sont indiqués). Si non spécifié, l'index est utilisé.
+
Autre cas spécial, vous pouvez utiliser « `<rév-a>...<rév-b>` » comme raccourci pour la base de fusion de _<rév-a>_ et _<rév-b>_ s'il y a exactement une seule base de fusion. Vous pouvez ne pas spécifier _<rév-a>_ ou _<rév-b>_, auquel cas ce sera `HEAD` par défaut.

`--`::
	Ne pas interpréter les arguments qui suivent comme options.

`<spécificateur-de-chemin>...`::
	Limite les chemins affectés par l'opération.
+
Pour plus de détail, voir l'entrée 'spécificateur de chemin' dans linkgit:gitglossary[7].

HEAD DÉTACHÉE
-------------
`HEAD` fait normalement référence à une branche nommée (par exemple, `master`). Dans le même temps, chaque branche pointe sur un commit spécifique. Regardons un dépôt avec trois commits, dont un est étiqueté, et avec la branche `master` extraite :

------------
           HEAD (se réfère à la branche 'master')
            |
            v
a---b---c  branch 'master' (se réfère au commit 'c')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')
------------

Quand un commit est créé dans cet état, la branche est mise à jour pour faire référence au nouveau commit. Plus précisément, `git commit` crée un nouveau commit `d`, dont le parent est le commit `c`, et ainsi elle met à jour la branche `master` pour faire référence au nouveau commit `d`. `HEAD` fait toujours référence à la branche `master` et donc fait maintenant référence indirectement au commit `d` :

------------
$ edit; git add; git commit

               HEAD (se réfère à la branche 'master')
                |
                v
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')
------------

Il est parfois utile de permettre l'extraction d'un commit qui n'est sommet d'aucune branche ou même de créer un nouveau commit qui n'est pas référencé par une branche nommée. Regardons ce qui arrive quand on extrait le commit `b` (ici, deux manières de faire sont montrées) :

------------
$ git checkout v2.0  # ou
$ git checkout master^^

   HEAD (se réfère au commit 'b')
    |
    v
a---b---c---d  branch 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')
------------

Veuillez noter que quelle que soit la commande d'extraction utilisée, `HEAD` pointe maintenant directement sur le commit `b`. C'est connu comme étant l'état `HEAD` détachée. Ceci signifie simplement que `HEAD` fait référence à un commit spécifique, par opposition à une référence à une branche nommée. Voyons ce qui arrive quand un commit est créé :

------------
$ edit; git add; git commit

     HEAD (se réfère au commit 'e')
      |
      v
      e
     /
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')
------------

Il y a maintenant un nouveau commit `e` mais il est référencé seulement par `HEAD`. Un autre commit peut bien sûr être ajouté dans cet état :

------------
$ edit; git add; git commit

	 HEAD (se réfère au commit 'f')
	  |
	  v
      e---f
     /
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')
------------

En fait, toutes les opérations normales de Git peuvent être exécutées. Mais, regardons ce qui arrive quand `master` est extraite :

------------
$ git checkout master

               HEAD (se réfère au branch 'master')
      e---f     |
     /          v
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')
------------

Il est important de réaliser qu'à ce moment, rien ne fait référence au commit `f`. Finalement, le commit `f` (et par extension le commit `e`) sera supprimé par le processus de ramasse-miette régulier de Git, à moins de créer une référence avant que cela n'arrive. Si vous n'avez pas encore quitté le commit `f`, une des commandes suivantes permet de créer une référence sur lui :

------------
$ git checkout -b foo  # ou "git switch -c foo"  <1>
$ git branch foo                                 <2>
$ git tag foo                                    <3>
------------
<1> crée une nouvelle branche `foo` qui fait référence au commit `f`, puis met à jour `HEAD` pour faire référence à la branche `foo`. En d'autres termes, l'état ne sera plus en `HEAD` détachée après cette commande.
<2> crée aussi une nouvelle branche `foo` qui fait référence au commit `f` mais laisse `HEAD` détachée.
<3> crée une nouvelle étiquette `foo` qui fait référence au commit `f`, en laissant `HEAD` détachée.

Si nous ne sommes plus sur `f`, alors nous devons d'abord retrouver son nom d'objet (typiquement en utilisant git reflog), puis nous pouvons créer une référence dessus. Par exemple, pour voir les deux derniers commits sur lesquels `HEAD` pointait, nous pouvons utiliser l'une des commandes suivantes :

------------
$ git reflog -2 HEAD # ou
$ git log -g -2 HEAD
------------

DÉSAMBIGUÏSATION D'ARGUMENT
---------------------------

Quand vous lancez `git checkout <quelque-chose>`, Git essaye de deviner si _<quelque-chose>_ est destiné à être une branche, un commit, ou un ensemble de fichier(s), et ensuite soit se déplace vers cette branche, ou valide ou restaure les fichiers spécifiés.

S'il y a une ambiguïté, Git traitera _<quelque-chose>_ en tant que branche ou commit, mais vous pouvez utiliser le double tiret `--` pour forcer Git à traiter le paramètre comme une liste de fichiers et/ou de répertoires, comme ceci :

----------
git checkout -- file.txt
----------

EXEMPLES
--------

=== 1. Chemins

La séquence suivante extrait la branche `master`, ramène le fichier `Makefile` à deux révisions en arrière, supprime `hello.c` par erreur et le récupère de l'index.

------------
$ git checkout master             <1>
$ git checkout master~2 Makefile  <2>
$ rm -f hello.c
$ git checkout hello.c            <3>
------------
<1> bascule de branche
<2> prend un fichier depuis un autre commit
<3> restaure `hello.c` depuis l'index

Si vous souhaitez extraire _tous_ les fichiers source C de l'index, vous pouvez lancer

------------
$ git checkout -- '*.c'
------------

Notez les guillemets autour de `*.c`. Le fichier `hello.c` sera aussi extrait, même s'il n'est plus dans l'arbre de travail, parce que le patron de fichier est utilisé pour trouver les entrées dans l'index (et non dans l'arbre de travail par le shell).

Si vous avez une branche qui s'appelle malheureusement `hello.c`, cette étape pourrait être confondue avec une instruction de basculer sur cette branche. Vous devriez alors plutôt écrire :

------------
$ git checkout -- hello.c
------------

=== 2. Fusion

Après avoir travaillé dans la mauvaise branche, basculer sur la branche correcte serait réalisé par :

------------
$ git checkout monsujet
------------

Cependant, votre « fausse » branche et votre branche correcte `monsujet` peuvent être différentes par les fichiers que vous avez modifiés localement, auquel cas l'extraction ci-dessus échouerait comme ceci :

------------
$ git checkout monsujet
error: Vos modifications locales aux fichiers suivants seraient écrasées par l'extraction :
------------

Vous pouvez fournir l'option `-m` à la commande, ce qui essaierait une fusion à trois points :

------------
$ git checkout -m monsujet
Fusion automatique de frotz
------------

Après cette fusion à trois points, les modifications locales ne sont _pas_ enregistrées dans votre index, donc `git diff` vous montrerait ce qui a changé depuis le sommet de la nouvelle branche.

=== 3. Conflit de fusion

Quand un conflit de fusion arrive pendant un basculement de branche avec l'option `-m`, vous devriez voir quelque chose comme :

------------
$ git checkout -m mytopic
Fusion automatique de frotz
CONFLIT (contenu): Conflit de fusion dans frotz
fatal: merge program failed
------------

À ce stade, `git diff` affiche les modifications proprement fusionnées comme dans l'exemple précédent, ainsi que les modifications en conflit. Éditez et résolvez le conflit et marquez-le résolu avec `git add` comme d'habitude :

------------
$ edit frotz
$ git add frotz
------------

CONFIGURATION
-------------

include::includes/cmd-config-section-all.adoc[]

include::config/checkout.adoc[]

VOIR AUSSI
----------
linkgit:git-switch[1], linkgit:git-restore[1]

GIT
---
Fait partie de la suite linkgit:git[1]

TRADUCTION
----------
Cette  page de manuel a été traduite par Jean-Noël Avila <jn.avila AT free DOT fr> et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site https://github.com/jnavila/git-manpages-l10n .
