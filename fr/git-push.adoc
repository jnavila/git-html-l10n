git-push(1)
===========

NOM
---
git-push - Met à jour les références distantes ainsi que les objets associés


SYNOPSIS
--------
[verse]
'git push' [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
	   [--repo=<dépôt>] [-f | --force] [-d | --delete] [--prune] [-q | --quiet] [-v | --verbose]
	   [-u | --set-upstream] [-o <chaîne> | --push-option=<chaîne>]
	   [--[no-]signed|--signed=(true|false|if-asked)]
	   [--force-with-lease[=<nom-de-réf>[:<attendu>]] [--force-if-includes]]
	   [--no-verify] [<dépôt> [<spéc-de-réf>...]]

DESCRIPTION
-----------

Met à jour d'une ou de plusieurs branches, étiquettes ou autres références dans un dépôt distant depuis votre dépôt local, et envoie toutes les données nécessaires qui ne sont pas déjà sur le distant.

Le moyen le plus simple de pousser est `git push <distant> <branche>`. `git push origin main` va pousser la branche locale `main` à la branche `main` sur le distant appelé `origin`.

L'argument `<dépôt>` vaut par défaut l'amont pour la branche actuelle, ou `origin` s'il n'y a pas d'amont configuré.

Pour décider quelles branches, étiquettes ou autres réfs pousser, Git utilise (dans l'ordre de priorité) :

1. L'argument _<spéc-de-réf>_ (par exemple `main` dans `git push origin main`) ou les options `--all`, `--mirror` ou `--tags`
2. La configuration `remote.<nom>.push` pour le dépôt vers lequel on pousse
3. La configuration `push.default`. La valeur par défaut est `push.default=simple`, qui va pousser sur une branche avec le même nom que la branche actuelle. Voir la section <<CONFIGURATION,CONFIGURATION>> ci-dessous pour plus sur `push.default` .

`git push` peut échouer si vous n'avez pas défini un amont pour la branche actuelle, selon la valeur de `push.default`. Consultez la section <<UPSTREAM-BRANCHES,BRANCHµES AMONT>>ci-dessous pour en savoir plus sur la façon de configurer et d'utiliser les amonts.

Vous pouvez faire arriver des choses intéressantes à un dépôt chaque fois que vous poussez vers lui, en y mettant en place des « crochets ». Voir la documentation pour linkgit:git-receive-pack[1].


OPTIONS[[OPTIONS]]
------------------
<dépôt>::
	Le dépôt "distant" qui est la destination d'une opération de poussée. Ce paramètre peut être soit une URL (voir la section <<URLS, URLS GIT >> ci-dessous) ou le nom d'un dépôt distant (voir la section <<REMOTES, DISTANTS >> ci-dessous).

<réf-de-spéc>...::
	Spécifier quelle réf destination pour mettre à jour avec quel objet source.
+
Le format d'un spéc de réf est `[+]<src>[:<dst>]`, par exemple `main`, `main:other`, or `HEAD^:refs/heads/main`.
+
Le _<src>_ est souvent le nom de la branche locale à pousser, mais il peut s'agir de n'importe quelle "expression SHA-1" arbitraire (voir linkgit:gitrevisions[7]) .
+
La `<dst>` détermine quelle réf mettre à jour du côté distant. Elle doit être le nom d'une branche, d'une étiquette ou d'une autre réf, et non d'une expression arbitraire.
+
Le `+` est optionnel et fait la même chose que `--force`.
+
Vous pouvez écrire un spéc-de-réf en utilisant la forme totale étendu (par exemple `refs/heads/main:refs/heads/main`) qui spécifie les source et destination exactes, ou avec une forme plus courte (par exemple `main` ou `main:other`). Voici les règles pour l'expansion des spéc-de-réf ainsi que celles de diverses autres formes de spéc-de-réf spéciales :
+
 *  `<src>` , sans `:<dst>` signifie mettre à jour la même réf que `<src>`, à moins que la configuration `remote.<dépôt>.push` specifie une _<dst>_ différente. Par exemple, si `main` est une branche, la spéc-de-réf `main` s'étend en `main:refs/heads/main`.
 *  Si _<dst>_ fait référence sans ambiguïté à une référence sur le _<dépôt>_ distant, alors elle est étendue à cette ref. Par exemple, si `v1.0` est une étiquette sur le distant, alors `HEAD:v1.0` s'étend à `HEAD:refs/tags/v1.0`.
 *  Si _<src>_ se résout en une réf commençant par `refs/heads/` ou `refs/tags/`, alors préfixer ceci à <dst>. Par exemple, si `main` est une branche, alors `main:other` s'étend en `main:refs/heads/other`
 *  La spéc-de-réf spéciale `:` (ou `+:` pour permettre des mises à jour pas en avance rapide) ordonne à Git de pousser les branches "correspondantes" : pour chaque branche qui existe du côté local, le côté distant est mis à jour si une branche du même nom existe déjà du côté distant.
 *  _<src>_ peut contenir un `*` pour indiquer une simple correspondance de motif. Cela fonctionne comme un motif glob qui correspond à n'importe quelle ref qui correpond au motif. Il ne doit y avoir qu'un et un seul `*` dans les deux _<src>_ et _<dst>_. Il va faire correspondre les références à la destination en remplaçant le `*` par le contenu correspondant de la source. Par exemple, `refs/heads/*:refs/heads/*` va pousser toutes les branches.
 *  Un refspec commençant par `^` est un réfspec négatif. Ceci spécifie les réfs à exclure. Une réf sera considérée comme correspondante si elle correspond à au moins un réfspec positif, et ne correspond à aucun réfspec négatif. Les réfspecs négatifs peuvent être des refspecs motif. Ils ne doivent contenir qu'un `<src>`. Les noms d'objets hexadécimaux ne sont pas pris en charge. Par exemple, `git push origin 'refs/heads/*' '^refs/heads/dev-*'` va pousser toutes les branches sauf celles commençant par `dev- `
 *  Si `<src>` est vide, la réf `<dst>` est supprimée du dépôt distant. Par exemple, `git push origin:dev` supprimera la branche `dev`.
 *  `tag <étiquette>` subit une expansion vers `refs/tags/<étiquette>:refs/tags/<étiquette>`.
	C'est techniquement une syntaxe spéciale pour `git push` et non une refspec, puisque dans `git push origin tag v1.0` les arguments `tag` et `v1.0` sont séparés.
 *  Si la spéc-de-réf ne peut pas subir d'expansion non ambiguë, génère un erreur indiquant ce qui a été essayé, et en fonction de la configuration `advice.pushUnqualifiedRefname` (voir linkgit:git-config[1]) suggérer vers quel espace de nom refs/ vous avez pu vouloir pousser.

Toutes les mises à jour ne sont pas permises : voir RÈGLES DE POUSSÉE ci-dessous pour les détails.

--all::
--branches::
	Pousser toutes les branches (c'est-à-dire les références sous `refs/heads/`) ; ne peut pas être utilisé avec d'autres <spéc-de-réf>.

--prune::
	Supprimer les branches distantes qui n'ont pas d'équivalent local. Par exemple, une branche distante `tmp` sera supprimée si une branche locale du même nom n'existe plus. Cela respecte également les spécificateurs de référence, par exemple `git push --prune remote refs/heads/*:refs/tmp/*` s'assurera que la branche distante `refs/tmp/foo` sera supprimée si `refs/heads/foo` n'existe plus.

--mirror::
	Au lieu de nommer chaque réf à pousser, spécifier que toutes les réfs sous `refs/` (ce qui inclut mais n'est pas limité à `refs/heads/`, `refs/remotes/`, et `refs/tags/`) soient reflétées dans le dépôt distant. Les réfs locales nouvellement créées seront poussées vers l'autre extrémité, les réfs mises à jour localement seront mises à jour de force sur l'extrémité distante, et les réfs supprimées seront supprimées de l'extrémité distante. C'est la valeur par défaut si l'option de configuration `remote.<distant>.mirror` est définie.

-n::
--dry-run::
	Fait tout sauf envoyer les mises à jour.

--porcelain::
	Produire une sortie lisible par machine. La ligne d'état de sortie pour chaque référence sera séparée par des tabulations et envoyée à stdout au lieu de stderr. Les noms symboliques complets des réfs seront donnés.

-d::
--delete::
	Toutes les références listées sont supprimées du dépôt distant. Cela revient à préfixer toutes les références par deux points.

--tags::
	Toutes les références sous `refs/tags` sont poussées, en plus des spéc-de-réfs explicitement listés sur la ligne de commande.

--follow-tags::
	Pousser tous les réfs qui seraient poussées sans cette option, et pousser aussi les étiquettes annotées dans `refs/tags` qui sont manquantes du distant mais qui pointent vers le commit-esque qui sont accessibles depuis les réfs poussées. Cela peut également être spécifié avec la variable de configuration `push.followTags`. Pour plus d'informations, voir `push.followTags` dans linkgit:git-config[1].

--signed::
--no-signed::
--signed=(true|false|if-asked)::
	Signer avec GPG la demande de poussée pour mettre à jour les références du côté réception, pour lui permettre d'être vérifié par les crochets et/ou d'être enregistrée. Si `false` ou `--no-signed`, aucune signature ne sera tentée. Si `true` ou `--signed`, la poussée échouera si le serveur ne prend pas en charge les poussées signées. S'il est défini sur `if-asked`, signer si et seulement si le serveur prend en charge les poussées signées. La poussée échouera également si l'appel réel à `gpg --sign` échoue. Voir linkgit:git-receive-pack[1] pour les détails sur l'extrémité réceptrice.

--atomic::
--no-atomic::
	Utiliser une transaction atomique à distance, si possible. Soit toutes les références sont mises à jour, soit, en cas d'erreur, aucune référence n'est mise à jour. Si le serveur ne prend pas en charge les poussées atomiques, la poussée échouera.

-o <option>::
--push-option=<option>::
	Transmettre la chaîne donnée au serveur, qui les transmet au crochet pre-receive ainsi qu'au crochet post-receive. La chaîne donnée ne doit pas contenir de caractère NUL ou LF. Lorsque plusieurs `--push-option=<option>` sont donnés, ils sont tous envoyés de l'autre côté dans l'ordre indiqué sur la ligne de commande. Lorsqu'aucun `--push-option=<option>` n'est donné en ligne de commande, les valeurs de la variable de configuration `push.pushOption` sont utilisées à la place.

--receive-pack=<git-receive-pack>::
--exec=<git-receive-pack>::
	Chemin d'accès au programme 'git-receive-pack' sur l'extrémité distante. Parfois utile lorsque vous poussez vers un dépôt distant via ssh, et que vous n'avez pas le programme dans un répertoire sur le $PATH par défaut.

--force-with-lease::
--no-force-with-lease::
--force-with-lease=<nom-de-réf>::
--force-with-lease=<nom-de-réf>:<attendu>::
	Habituellement, "git push" refuse de mettre à jour une référence distante qui n'est pas un ancêtre de la référence locale utilisée pour la remplacer.
+
Cette option passe outre cette restriction si la valeur actuelle de la référence distante est la valeur attendue. "git push" échoue sinon.
+
Imaginez que vous devez rebaser ce que vous avez déjà publié. Vous devrez contourner la règle "doit avancer rapidement" afin de remplacer l'historique que vous avez initialement publié par l'historique rebasé. Si quelqu'un d'autre a construit sur votre historique d'origine pendant que vous rebasez, le sommet de la branche distante peut avoir avancé avec son commit, et pousser aveuglément avec `--force` éliminera son travail.
+
Cette option vous permet de dire que vous vous attendez à ce que l'historique que vous mettez à jour est ce que vous avez rebasé et que vous souhaitez remplacer. Si la référence distante pointe toujours sur le commit que vous avez spécifié, vous pouvez être sûr qu'aucune autre personne n'a fait quoi que ce soit à la référence. C'est comme prendre un "contrat" sur la référence sans la verrouiller explicitement, et la référence distante n'est mise à jour que si le "contrat" est toujours valide.
+
Seul `--force-with-lease`, sans préciser les détails, protégera toutes les références distantes qui vont être mises à jour en exigeant leur valeur actuelle à être la même que la branche de suivi à distance que nous avons pour eux.
+
`--force-with-lease=<nom-de-réf>`, sans spécifier la valeur attendue, protégera (seulement) la référence nommée, si elle va être mise à jour, en exigeant que sa valeur actuelle soit la même que la branche de suivi à distance que nous avons pour elle.
+
`--force-with-lease=<nom-de-réf>:<attendu>` protégera (seulement) la référence nommée, si elle va être mise à jour, en exigeant que sa valeur actuelle soit la même que la valeur spécifiée `<attendu >` (qui peut être différente de la branche de suivi à distance que nous avons pour le nom de référence, ou si nous n'avons même pas besoin d'avoir une telle branche de suivi à distance lorsque cette forme est utilisée). Si `<attendu>` est la chaîne vide, alors la référence nommée ne doit pas déjà exister.
+
Notez que toutes les formes autres que `--force-with-lease=<nom-de-réf>:<attendu>` qui spécifie explicitement la valeur actuelle attendue de la référence sont toujours expérimentales et leur sémantique peut changer à mesure que nous acquérons de l'expérience avec cette fonctionnalité.
+
"--no-force-with-lease" annulera tous les précédents --force-with-lease sur la ligne de commande.
+
Une note générale sur la sécurité : fournir cette option sans valeur attendue, c'est-à-dire que `--force-with-lease` ou `--force-with-lease=<nom-de-réf>` interagit très mal avec tout ce qui exécute implicitement `git fetch` sur le distant pour être poussé en arrière-plan, par exemple `git fetch origin` sur votre dépôt dans un job cron.
+
La protection qu'il offre par rapport à `--force` est d'assurer que les modifications ultérieures sur lesquelles votre travail n'était pas basé ne sont pas supprimées, mais elle est trivialement réduite à néant si un processus de mise à jour des références est effectué en arrière-plan. Nous n'avons rien d'autre que les informations de suivi à distance à utiliser comme heuristique pour les références que vous êtes censé avoir vues et que vous êtes prêt à supprimer.
+
Si votre éditeur ou un autre système exécute `git fetch` en arrière-plan pour vous, un moyen d'atténuer cela est simplement de configurer un autre distant :
+
	git remote add origin-push $(git config remote.origin.url)
	git fetch origin-push
+
Maintenant, lorsque le processus d'arrière-plan exécute `git fetch origin`, les références sur` origin-push` ne seront pas mises à jour, et donc des commandes comme :
+
	git push --force-with-lease origin-push
+
Échouera à moins que vous ne lanciez manuellement `git fetch origin-push`. Cette méthode est bien sûr entièrement contrecarrée par quelque chose qui lance `git fetch --all`, auquel cas vous devrez soit la désactiver soit faire quelque chose de plus fastidieux comme :
+
	git fetch              # mettre à jour 'master' depuis le distant
	git tag base master    # étiqueter notre point de base
	git rebase -i master   # réécrire quelques commits
	git push --force-with-lease=master:base master:master
+
C'est-à-dire créer une étiquette `base` pour les versions du code amont que vous avez vues et que vous êtes prêt à écraser, puis réécrire l'historique, et enfin forcer la poussée des modification vers `master` si la version distante est toujours à `base`, indépendamment de ce que votre `remotes/origin/master` local a été mis à jour en arrière-plan.
+
Alternativement, spécifier `--force-if-includes` comme une option auxiliaire avec `--force-with-lease[=<nom-de-réf>]` (c'est-à-dire sans dire vers quel commit exact la réf du côté distant doit pointer, ou quelles réfs du côté distant sont protégées) au moment de "push" vérifiera si les mises à jour des réfs du côté distant qui peuvent avoir été implicitement mises à jour en arrière-plan sont intégrées localement avant d'autoriser une mise à jour forcée.

-f::
--force::
	Habituellement, `git push` refuse de mettre à jour une branche qui n'est pas un ancêtre du commit en train d'être poussé.
+
Ce drapeau désactive ce contrôle, les autres vérifications de sécurité listées dans RÈGLES DE POUSSÉE ci-dessous, et les vérifications dans `--force-with-lease`. Il peut entraîner la perte de commits dans le dépôt distant ; utilisez-le avec précaution.
+
Notez que `--force` s'applique à toutes les refs qui sont poussées, donc l'utiliser avec `push.default` réglé sur `matching` ou avec plusieurs destinations de poussée configurées avec `remote.*.push` peut écraser les refs autres que la branche courante (y compris les refs locales qui sont strictement derrière leur homologue distante). Pour forcer un push vers une seule branche, utilisez un " + " devant le spécificateur de référence à pousser (par exemple `git push origin +master` pour forcer une poussée vers la branche `master`). Voir la section `<spéc-de-réf>...` ci-dessus pour plus de détails.

--force-if-includes::
--no-force-if-includes::
	Ne forcer une mise à jour que si le sommet de la référence de suivi à distance a été intégré localement.
+
Cette option permet de vérifier si le sommet de la référence de suivi à distance est accessible depuis l'une des entrées "reflog" de la branche locale qui est basée dessus pour une réécriture. Cette vérification permet de s'assurer que toutes les mises à jour du distant ont été incorporées localement en rejetant la mise à jour forcée si ce n'est pas le cas.
+
Si l'option est passée sans spécifier `--force-with-lease`, ou spécifiée avec `--force-with-lease=<nom-de-réf>:<attendu>`, c'est un "no-op".
+
Spécifier `--no-force-if-includes` désactive ce comportement.

--repo=<dépôt>::
	Cette option est équivalente à l'argument <dépôt>. Si les deux sont spécifiés, l'argument de la ligne de commande a la priorité.

-u::
--set-upstream::
	Pour chaque branche qui est à jour ou poussée avec succès, ajoutet une référence de suivi amont, utilisée par les commandes sans argument linkgit:git-pull[1] et autres. Pour plus d'informations, voir `branch.<nom>.merge` dans linkgit:git-config[1].

--thin::
--no-thin::
	Ces options sont passées à linkgit:git-send-pack[1]. Un transfert fin réduit considérablement la quantité de données envoyées lorsque l'expéditeur et le destinataire ont de nombreux objets identiques en commun. La valeur par défaut est `--thin`.

-q::
--quiet::
	Supprimer toutes les sorties, y compris la liste des références mises à jour, à moins qu'une erreur ne se produise. Les progrès ne sont pas signalés dans le flux d'erreurs standard.

-v::
--verbose::
	Mode bavard.

--progress::
	L'état d'avancement est affiché sur la sortie d'erreur standard quand elle est attachée à un terminal, à moins que -q soit spécifié. Ce drapeau force l'état d'avancement même si le flux d'erreur standard n'est pas dirigé vers un terminal.

--no-recurse-submodules::
--recurse-submodules=check|on-demand|only|no::
	Peut être utilisé pour s'assurer que tous les commits de sous-module utilisés par les révisions à pousser sont disponibles sur une branche de suivi à distance. Si 'check' est utilisé, Git vérifiera que tous les commits de sous-module qui ont changé dans les révisions à pousser sont disponibles sur au moins une branche distante du sous-module. S'il manque des validations, la poussée sera interrompue et sortira avec un statut non nul. Si 'on-demand' est utilisé, tous les sous-module qui ont été modifiés dans les révisions à pousser seront poussés. Si 'on-demand' n'a pas pu pousser toutes les révisions nécessaires, il sera également interrompu et sortira avec un statut non nul. Si 'only' est utilisé, tous les sous-modules seront poussés alors que le superprojet est laissé sans poussée. La valeur 'no' ou l'utilisation de `--no-recurse-submodules` peut être utilisée pour remplacer la variable de configuration push.recurseSubmodules lorsqu'aucune récursion de sous-module n'est nécessaire.
+
Lors de l'utilisation de 'on-demand' ou 'only', si un sous-module possède une configuration "push.recurseSubmodules={on-demand,only}" ou "submodule.recurse", une récursion supplémentaire se produira. Dans ce cas, "only" est traité comme "on-demand".

--verify::
--no-verify::
	Basculer le crochet de pré-poussée 'pre-push' (voir linkgit:githooks[5]). La valeur par défaut est --verify, ce qui donne au crochet une chance d'empêcher la poussée. Avec --no-verify, le crochet est complètement contourné.

-4::
--ipv4::
	Utiliser uniquement les adresses IPv4, en ignorant les adresses IPv6.

-6::
--ipv6::
	Utiliser uniquement les adresses IPv6, en ignorant les adresses IPv4.

include::urls-remotes.adoc[]

SORTIE
------

La sortie de "git push" dépend de la méthode de transport utilisée ; cette section décrit la sortie lors du passage par protocole Git (soit localement soit via ssh).

L'état de la poussée est affiché sous forme de tableau, chaque ligne représentant l'état d'une seule référence. Chaque ligne est de la forme :

-------------------------------
 <drapeau> <résumé> <de> -> <à> (<raison>)
-------------------------------

Si --porcelain est utilisé, alors chaque ligne de la sortie est de la forme :

-------------------------------
 <drapeau> \t <de>:<à> \t <résumé> (<raison>)
-------------------------------

L'état des références à jour n'est indiqué que si l'option --porcelaine ou --verbose est utilisée.

drapeau::
	Un seul caractère indiquant le statut de la référence :
(espace);; pour une poussée en avance rapide réussie ;
`+`;; pour une mise à jour forcée avec succès ;
`-`;; pour une réf. supprimée avec succès ;
`*`;; pour une nouvelle référence poussée avec succès ;
`!`;; pour une référence qui a été rejetée ou qui n'a pas réussi à être poussée ; et
`=`;; pour une référence qui était à jour et n'avait pas besoin d'être poussée.

résumé::
	Pour une réf poussée avec succès, le résumé montre les anciennes et les nouvelles valeurs de la réf sous une forme qui peut être utilisée comme argument pour `git log` (c'est `<ancien>..<nouveau>` dans la plupart des cas, et `<ancien>...<nouveau>` pour les mises à jour forcées pas en avance rapide).
+
En cas d'échec de la mise à jour, de plus amples détails sont donnés :
+
--
rejeté::
	Git n'a pas du tout essayé d'envoyer la référence, généralement parce que ce n'est pas une avance rapide et que vous n'avez pas forcé la mise à jour.

le distant a rejeté::
	Le serveur distant a refusé la mise à jour. Généralement causé par un crochet du côté distant, ou parce que le dépôt distant a l'une des options de sécurité suivantes en vigueur : `receive.denyCurrentBranch` (pour les poussées vers la branche extraite), `receive.denyNonFastForwards` (pour les mises à jour forcées mais pas en avance rapide), `receive.denyDeletes` ou `receive.denyDeleteCurrent`. Voir linkgit:git-config[1].

échec distant::
	Le serveur distant n'a pas signalé la mise à jour réussie de la référence, peut-être en raison d'une erreur temporaire du côté distant, d'une rupture de la connexion réseau ou d'une autre erreur transitoire.
--

de::
	Le nom de la référence locale qui est poussée, moins son préfixe `refs/<type>/`. En cas de suppression, le nom de la référence locale est omis.

à::
	Le nom de la référence distante en cours de mise à jour, moins son préfixe `refs/<type>/`.

raison::
	Une explication compréhensible. Dans le cas des références qui ont été poussées avec succès, aucune explication n'est nécessaire. Dans le cas d'une référence en échec, la raison de l'échec est décrite.

RÈGLES DE POUSSÉE
-----------------

Par mesure de sécurité, la commande `git push` permet seulement certains types de mises à jour pour vous empêcher de perdre accidentellement des données sur le distant.

Comme les branches et les étiquettes sont destinées à être utilisées différemment, les règles de sécurité pour pousser sur une branche sont différentes des règles pour pousser sur une étiquette. Dans les règles suivantes "mise à jour" signifie toute modification sauf les suppressions et les créations. Les suppressions et les créations sont toujours autorisées, sauf si elles sont interdites par la configuration ou les crochets.

1. Si la destination de poussée est une **branche** (`refs/heads/*`) : seules les mises à jour en avance rapide sont permises, ce qui signifie que la destination doit être un ancêtre du commit source. La source doit être un commit.
2. Si la destination de poussée est une **étiquette** (`refs/tags/*`) : toutes les mises à jour seront rejetées. La source peut être n'importe quel objet.
3. Si la destination de poussée n'est pas une branche ou une étiquette :
   * Si la source est un objet arbre ou blob, toute mise à jour sera rejetée
   * Si la source est un objet étiquette ou commit, toute mise à jour en avance rapidement est permise, mais lorsque ce qui n'est en avance rapide n'est pas un commit, mais un objet étiquette qui pointe vers un nouveau commit qui est une avance rapide de la dernière étiquette (ou commit) qu'il remplace. Le remplacement d'une étiquette par une étiquette entièrement différente est également autorisé, si elle pointe vers le même commit, ainsi que le fait de pousser une étiquette pelée, c'est-à-dire de pousser le commit vers lequel l'objet étiquette existant pointe, ou un nouvel objet étiquette vers lequel un commit existant pointe.

Vous pouvez contourner ces règles en passant `--force` ou en ajoutant le préfixe optionnel `+` à un refspec. Les seules exceptions sont qu'on ne peut pas forcer une branche à accepter un objet non-commit, et qu'aucun forçage ne fera accepter une poussée à un dépôt distant s'il est configuré pour la rejeter.

Les crochets et la configuration peuvent également remplacer ou modifier ces règles, voir par exemple `receive.denyNonFastForwards` et `receive.denyDeletes` dans linkgit:git-config[1] et `pre-receive` et `update` dans linkgit:githooks[5].

NOTE SUR LES AVANCES RAPIDES
----------------------------

Lorsqu'une mise à jour modifie une branche (ou plus généralement, une réf) qui pointait auparavant vers le commit A pour pointer vers un autre commit B, on parle de mise à jour en avance rapide si et seulement si B est un descendant de A.

Dans une mise à jour rapide de A à B, l'ensemble des commits sur lesquels le commit original A s'appuyait est un sous-ensemble des commits sur lesquels le nouveau commit B s'appuie. Ainsi, il ne perd pas d'historique.

En revanche, une mise à jour pas en avance rapide fera perdre de l'historique. Par exemple, supposons que vous et quelqu'un d'autre ayez commencé au même commit X, et que vous ayez construit un historique menant au commit B alors que l'autre personne a construit un historique menant au commit A. L'historique ressemble à ceci :

----------------

      B
     /
 ---X---A

----------------

Supposons en outre que l'autre personne ait déjà poussé les modifications menant à A vers le dépôt original dont vous avez tous deux obtenu le commit X original.

La poussée effectuée par l'autre personne a mis à jour la branche qui pointait sur le commit X pour pointer sur le commit A. Il s'agit d'une avance rapide.

Mais si vous essayez de pousser, vous essaierez de mettre à jour la branche (qui pointe maintenant vers A) avec le commit B. Cela ne fait _pas_ d'avance rapide. Si vous le faites, les modifications introduits par le commit A seront perdues, car tout le monde va maintenant commencer à construire sur B.

La commande par défaut ne permet pas une mise à jour qui ne soit pas une avance rapide pour éviter une telle perte d'historique.

Si vous ne voulez pas perdre votre travail (historique de X à B) ou le travail de l'autre personne (historique de X à A), vous devez d'abord récupérer l'historique du dépôt, créer un historique qui contient les modifications effectuées par les deux parties et repousser le résultat.

Vous pouvez effectuer un "git pull", résoudre les conflits potentiels et "git push" le résultat. Un "git pull" créera un commit de fusion C entre les commit A et B.

----------------

      B---C
     /   /
 ---X---A

----------------

La mise à jour de A avec le commit de fusion résultant sera une avance rapide et votre poussée sera acceptée.

Vous pouvez également rebaser votre modification entre X et B sur A, avec "git pull --rebase", et pousser le résultat. Le rebasage créera un nouveau commit D qui construit la modification entre X et B sur A.

----------------

      B   D
     /   /
 ---X---A

----------------

Là encore, la mise à jour de A avec ce commit sera en avance rapide et votre poussée sera acceptée.

Il existe une autre situation courante dans laquelle vous pouvez rencontrer un rejet du fait d'absence d'avance rapide lorsque vous essayez de pousser, et c'est possible même lorsque vous poussez dans un dépôt dans lequel personne d'autre ne pousse. Après avoir vous-même poussé le commit A (dans la première image de cette section), remplacez-le par "git commit --amend" pour produire le commit B, et vous essayez de le pousser, parce que vous avez oublié que vous avez déjà poussé A. Dans un tel cas, et seulement si vous êtes certain que personne n'a récupéré votre commit A précédent (et a commencé à construire dessus), vous pouvez lancer "git push --force" pour l'écraser. En d'autres termes, "git push --force" est une méthode réservée aux cas où vous voulez vraiment perdre l'historique.


EXEMPLES
--------

`git push`::
	Fonctionne comme `git push <distant>`, où <distant> est le distant de la branche actuelle (ou `origin`, si aucun distant n'est configuré pour la branche actuelle).

`git push origin`::
	Sans configuration supplémentaire, pousse la branche en cours vers l'amont configuré (variable de configuration `branch.<nom>.merge`) si elle a le même nom que la branche actuelle et génère des erreurs sans pousser autrement.
+
Le comportement par défaut de cette commande quand aucun <spec-de-réf> n'est donné peut être configuré en définissant l'option `push` du distant, ou la variable de configuration `push.default`.
+
Par exemple, pour pousser par défaut uniquement la branche actelle vers `origin`, utilisez `git config remote.origin.push HEAD`. Tout <spec-de-réf> valide (comme ceux des exemples ci-dessous) peut être configuré par défaut pour `git push origin`.

`git push origin :`::
	Pousse les branches "correspondantes" sur `originè. Voir <spec-de-réf> dans la section <<OPTIONS,OPTIONS>> ci-dessus pour une description des branches "correspondantes".

`git push origin master`::
	Trouve une réf qui correspond à `master` dans le dépôt source (le plus souvent, trouvera `refs/heads/master`), et met à jour la même réf (par exemple `refs/heads/master`) dans le dépôt `origin` avec elle. Si `master` n'existait pas à distance, elle serait créée.

`git push origin HEAD`::
	Un moyen pratique de pousser la branche actuelle vers le même nom sur le distant.

`git push vaisseaumere master:satellite/master dev:satellite/dev`::
	Utiliser la référence source qui correspond à `master` (par exemple `refs/heads/master`) pour mettre à jour la référence qui correspond à `satellite/master` (très probablement `refs/remotes/satellite/master`) dans le dépôt `vaisseaumere` ; faire de même pour `dev` et `satellite/dev`.
+
Voir la section décrivant `<spéc-de-réf>...` ci-dessus pour une discussion sur la sémantique de correspondance.
+
Il s'agit d'émuler `git fetch` exécuté sur le `vaisseaumere` en utilisant `git push` qui est exécuté dans la direction opposée afin d'intégrer le travail effectué sur `satellite`, et est souvent nécessaire lorsque vous ne pouvez établir la connexion que dans un seul sens (c'est-à-dire que le satellite peut ssh dans vaisseaumere mais que le vaisseaumere ne peut pas établir de connexion avec satellite parce que ce dernier se trouve derrière un pare-feu ou n'exécute pas sshd).
+
Après avoir lancé ce `git push` sur la machine `satellite`, vous ouvririez un ssh sur le `vaisseaumere` et y lanceriez `git merge` pour compléter l'émulation de `git pull` qui était lancée sur `vaisseaumere` afin de tirer les modifications faites sur `satellite`.

`git push origin HEAD:master`::
	Pousser la branche actuelle vers la référence distante correspondant à `master` dans le dépôt `origin`. Cette forme est pratique pour pousser la branche actuelle sans avoir à penser à son nom local.

`git push origin master:refs/heads/experimental`::
	Créer la branche `experimental` dans le dépôt `origin` en copiant la branche `master` actuelle. Cette forme n'est nécessaire que pour créer une nouvelle branche ou étiquette dans le dépôt distant lorsque le nom local et le nom distant sont différents ; sinon, le nom de la réf seul fonctionnera.

`git push origin :experimental`::
	Trouver une ref qui correspond à `experimental` dans le dépôt `origin` (par exemple `refs/heads/experimental`), et la supprimer.

`git push origin +dev:master`::
	Mettre à jour la branche master du dépôt origin avec la branche dev, ce qui permet des mises à jour en mode non avance rapide. *Ceci peut laisser des commits non référencés dans le dépôt origin.* Considérez la situation suivante, où une avance rapide n'est pas possible :
+
----
	    o---o---o---A---B  origin/master
		     \
		      X---Y---Z  dev
----
+
La commande ci-dessus changerait le dépôt origin en
+
----
		      A---B  (branche sans nom)
		     /
	    o---o---o---X---Y---Z  master
----
+
Les commits A et B n'appartiendraient plus à une branche portant un nom symbolique, et seraient donc injoignables. Dans cet état, ces commits seraient supprimés par une commande `git gc` sur le dépôt origin.

include::transfer-data-leaks.adoc[]

[[CONFIGURATION]]
CONFIGURATION
-------------

include::includes/cmd-config-section-all.adoc[]

include::config/push.adoc[]

GIT
---
Fait partie de la suite linkgit:git[1]

TRADUCTION
----------
Cette  page de manuel a été traduite par Jean-Noël Avila <jn.avila AT free DOT fr> et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site https://github.com/jnavila/git-manpages-l10n .
