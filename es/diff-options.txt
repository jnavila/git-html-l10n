// Please don't remove this comment as asciidoc behaves badly when
// the first non-empty line is ifdef/ifndef. The symptom is that
// without this comment the <git-diff-core> attribute conditionally
// defined below ends up being defined unconditionally.
// Last checked with asciidoc 7.0.2.

ifndef::git-format-patch[]
ifndef::git-diff[]
ifndef::git-log[]
:git-diff-core: 1
endif::git-log[]
endif::git-diff[]
endif::git-format-patch[]

ifdef::git-format-patch[]
-p::
--no-stat::
	General parches planos sin estadísticas de diff.
endif::git-format-patch[]

ifndef::git-format-patch[]
-p::
-u::
--patch::
	Genera parche (ver sección titulada
ifdef::git-log[]
<<generate_patch_text_with_p, "Generando texto de parche con -p">>).
endif::git-log[]
ifndef::git-log[]
"Generando texto de parche con -p").
endif::git-log[]
ifdef::git-diff[]
	Este es el predeterminado
endif::git-diff[]

-s::
--no-patch::
	Suprime la salida de diff. Útil para comandos como `git show` que muestra predeterminadamente el parche, o para cancelar el efecto de `--patch`.
endif::git-format-patch[]

ifdef::git-log[]
--diff-merges=(off|none|on|first-parent|1|separate|m|combined|c|dense-combined|cc|remerge|r)::
--no-diff-merges::
	Especifica el formato de diff a usar para commits de fusión. El predeterminado es {diff-merges-default} a menos que se use `--first-parent`, en tal caso `first-parent` es el predeterminado.
+
--diff-merges=(off|none):::
--no-diff-merges:::
	Deshabilita la salida de diff para commits de fusión. Útil para sobreescribir el valor implicado.
+
--diff-merges=on:::
--diff-merges=m:::
-m:::
	Esta opción hace que se muestre la salida de diff para commits de fusión en el formato predeterminado. `-m` producirá la salida sólo si también de proporciona `-p`. Se puede cambiar el formato predeterminado usando el parámetro de configuración `log.diffMerges`, cuyo valor predeterminado es `separate`.
+
--diff-merges=first-parent:::
--diff-merges=1:::
	Esta opción hace que los commits de fusión muestren el diff completo con respecto al primer antecesor únicamente.
+
--diff-merges=separate:::
	Este hace que los commits de fusión muestren el diff completo con respecto a cada uno de los padres. Para cada padre por separado se generan entrada en la bitácora y diff.
+
--diff-merges=remerge:::
--diff-merges=r:::
--remerge-diff:::
	Con esta opción, commits de fusión de dos padres son re-fusionados para crear un objeto árbol temporal -- potencialmente conteniendo ficheros con marcadores de conflicto y similares. Entonces se muestra un diff entre ese árbol temporal y el commit de fusión actual.
+
La salida emitida cuando se usa esta opción es sujeta a cambios, y también lo es su interacción con otras opciones (a menos que esté explícitamente documentado).
+
--diff-merges=combined:::
--diff-merges=c:::
-c:::
	Con esta opción, la salida del diff para un commit de fusión muestra las diferencias entre cada uno de los padres al resultado de la fusión simultáneamente en lugar de mostrar por pares la diferencia entre un padre y el resultado uno a la vez. Mas allá, lista sólo los ficheros que fueron modificados de todos los padres. `-c` implica `-p`.
+
--diff-merges=dense-combined:::
--diff-merges=cc:::
--cc:::
	Con esta opción la salida producida por `--diff-merges=combined` es además comprimida al omitir fragmentos no-interesantes cuyo contenido en los padres sólo tienen dos variantes y la fusión resulta elegir una de ellas sin modificación. `--cc` implica `-p`.

--combined-all-paths::
	Esta bandera causa diffs combinados (usados para commits de fusión) para listar el nombre del fichero de todos los padres. Por lo tanto sólo tiene efecto cuando se usa `--diff-merges=[dense-]combined`, y es probable que sólo sea útil si se detectan cambios de nombre de fichero (ej. cuando se ha solicitado detección ya sea de renombre o de copia).
endif::git-log[]

-U<n>::
--unified=<n>::
	Genera diffs con <n> líneas de contexto en lugar de las 3 usuales.
ifndef::git-format-patch[]
	Implica `--patch`.
endif::git-format-patch[]

--output=<fichero>::
	Salida a un fichero en específico en lugar de la salida estándar.

--output-indicator-new=<caracter>::
--output-indicator-old=<caracter>::
--output-indicator-context=<caracter>::
	Especifica el caracter usado para indicar líneas nuevas, antiguas o de contexto en el parche generado. Normalmente son '+', '-' y ' ' respectivamente.

ifndef::git-format-patch[]
--raw::
ifndef::git-log[]
	Generar las diferencias en formato bruto.
ifdef::git-diff-core[]
	Este es el predeterminado
endif::git-diff-core[]
endif::git-log[]
ifdef::git-log[]
	Para cada commit, muestra un resumen de cambios usando el formato
	diff bruto. Ver la sección de "FORMATO DE SALIDA BRUTO" de
	linkgit:git-diff[1]. Esto es distinto de mostrar la bitácora misma
	en formato bruto, lo cual puedes conseguir con
	`--format=raw`.
endif::git-log[]
endif::git-format-patch[]

ifndef::git-format-patch[]
--patch-with-raw::
	Sinónimo de `-p --raw`.
endif::git-format-patch[]

ifdef::git-log[]
-t::
	Mostrar los objetos del árbol en el resultado de las diferencias.
endif::git-log[]

--indent-heuristic::
	Habilita la heurística que aumenta los límites de fragmentos de diff para hacer los parches mas fáciles de leer. Este es el predeterminado.

--no-indent-heuristic::
	Deshabilita la heurística de indentación.

--minimal::
	Ocupa tiempo extra para asegurarse que se produce el diff más pequeño posible.

--patience::
	Generar diferencias mediante el algoritmo «patience diff».

--histogram::
	Generar diferencias mediante el algoritmo «histogram diff».

--anchored=<texto>::
	Generar diferencias mediante el algoritmo «anchored diff».
+
Esta opción puede ser especificada más de una vez.
+
Si una línea existe tanto en fuente como en destino, existe sólo una vez, y comienza con éste texto, éste algoritmo intenta prevenir que aparezca en la salida como un borrado o adición. Usa internamente el algoritmo "diff paciente".

--diff-algorithm={patience|minimal|histogram|myers}::
	Elige un algoritmo de diff. La variantes son las siguientes:
+
--
`default`, `myers`;;
	El algoritmo diff básico avaro. Actualmente, éste es el predeterminado.
`minimal`;;
	Ocupa tiempo extra para asegurarse que se produce el diff más pequeño posible.
`patience`;;
	Usa el algoritmo "diff paciente" al generar parches.
`histogram`;;
	Este algoritmo extiende el algoritmo paciente para "soportar elementos comunes de baja ocurrencia".
--
+
Por lo tanto, si configuraste la variable `diff.algorithm` a un valor no predeterminado y quieres usar el predeterminado, entonces tienes que usar la opción `--diff-algorithm=default`.

--stat[=<anchura>[,<anchura-nombre>[,<recuento>]]]::
	Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by `<width>`. The width of the filename part can be limited by giving another width `<name-width>` after a comma. The width of the graph part can be limited by using `--stat-graph-width=<width>` (affects all commands generating a stat graph) or by setting `diff.statGraphWidth=<width>` (does not affect `git format-patch`). By giving a third parameter `<count>`, you can limit the output to the first `<count>` lines, followed by `...` if there are more.
+
Estos parámetros también se puedes asignar individualmente con `--stat-width=<ancho>`, `--stat-name-width=<nombre-ancho>` y `--stat-count=<conteo>`.

--compact-summary::
	Da salida en el diffstat a un resumen condensado de información de encabezado extendido, como creaciones o eliminaciones de ficheros ("new" or "gone", opcionalmente "+l" si es un enlace simbólico) y cambios de modo ("+x" o "-x" para añadir o quitar el bit de ejecución respectivamente). La información se coloca entre la parte del nombre del fichero y la parte del grafo. Implica `--stat`.

--numstat::
	Similar a `--stat`, pero muestra el número de líneas añadidas y borradas en notación decimal y el nombre de ruta sin abreviación, para hacerlo más amigable a la máquina. Para ficheros binarios, saca dos `-` en lugar de decir `00`.

--shortstat::
	Da salida sólo a la última línea del formato `--stat` conteniendo el número total de ficheros modificados, así como el número de líneas añadidas y borradas.

-X[<parametro1,parametro2,...>]::
--dirstat[=<parametro1,parametro2,...>]::
	Da salida a la distribución de la cantidad relativa de cambios por cada sub-directorio. El comportamiento de `--dirstat` puede ser personalizado pasando una lista de parámetros separados por coma. Los predeterminados se controlan con la variable de configuración `diff.dirstat` (ver linkgit:git-config[1]). Están disponibles los parámetros siguientes:
+
--
`changes`;;
	Calcula los números de dirstat contando las líneas que han sido eliminadas del origen, o agregadas en el destino. Esto ignora la cantidad de movimientos de código puro dentro del fichero. En otras palabras, el re-acomodo de líneas en un fichero no cuenta tanto como otros cambios. Este es el comportamiento predeterminado cuando no se dan parámetros.
`lines`;;
	Calcula los números de dirstat haciendo el análisis de diferencias regular basado en líneas, y sumando los conteos de líneas quitadas/agregadas. (Para ficheros binarios, cuenta en cambio pedazos de 64 bytes, ya que los ficheros binarios no tienen el concepto natural de líneas). Este es un funcionamiento de `--dirstat` mas costoso que `changes`, pero el re-acomodo de líneas dentro de un fichero cuenta tanto como otros cambios. La salida resultante es consistente con lo que obtienes de las otras opciones `--*stat`.
`files`;;
	Calcula los números de dirstat contando el número de ficheros modificados. Cada fichero modificado cuenta igualmente en el análisis de dirstat. Este es el funcionamiento `--dirstat` computacionalmente más barato, ya que no tiene que mirar el contenido del fichero en absoluto.
`cumulative`;;
	Cuenta cambios en un directorio hijo también para el directorio padre. Nota que cuando se usa `cumulative`, la suma de los porcentajes reportados puede exceder 100%. El comportamiento predeterminado (no-acumulativo) se puede especificar con el parámetro `noncumulative`.
<límite>;;
	Un parámetro entero especifica un porcentaje de corte (predeterminado a 3%). Directorios que contribuyan menos que éste porcentaje de cambios no se muestran en la salida.
--
+
Ejemplo: El siguiente contará ficheros modificados, ignorando directorios con menos del 10% de la cantidad total de ficheros modificados, y acumulando conteos en directorios hijo en los directorios padre: `--dirstat=files,10,cumulative`.

--cumulative::
	Sinónimo de --dirstat=cumulative

--dirstat-by-file[=<parámetro1,parámetro2>...]::
	Sinónimo de --dirstat=archivos,parám1,parám2...

--summary::
	Muestra un resumen condensado de información de encabezado extendido como creaciones, renombrados y cambios de modo.

ifndef::git-format-patch[]
--patch-with-stat::
	Sinónimo de `-p --stat`.
endif::git-format-patch[]

ifndef::git-format-patch[]

-z::
ifdef::git-log[]
	Separa los commits con NULs en lugar de saltos de línea.
+
Además, cuando se da `--raw` o `--numstat`, no manipula los nombres de ruta y usa NULs como salida de terminadores de campo.
endif::git-log[]
ifndef::git-log[]
	Cuando se da `--raw`, `--numstat`, `--name-only` o `--name-status`,
	no manipula los nombres de ruta y usa NULs como salida de terminadores de campo.
endif::git-log[]
+
Sin esta opción, los nombres de ruta con caracteres "inusuales" son entrecomillados como se explica para la variable de configuración `core.quotePath` (ver linkgit:git-config[1]).

--name-only::
	Muestra sólo nombres de ficheros modificados. Los nombres de ficheros suelen codificarse con UTF-8. Para mas información ver la discusión sobre codificación en la página del manual de linkgit:git-log[1].

--name-status::
	Muestra sólo nombres y estatus de ficheros modificados. Ver la descripción de la opción `--diff-filter` donde se explica el significado de las letras de estatus. Así como `--name-only` los nombres de fichero se suelen codificar en UTF-8.

--submodule[=<formato>]::
	Especifica cómo se muestran las diferencias en submódulos. Cuando se especifica `--submodule=short` se usa el formato 'short'. Este formato sólo muestra nombres de los commits al principio y al fin del rango. Cuando se especifica `--submodule` o `--submodule=log` se usa el formato 'log'. Este formato lista los commits en el rango como lo hace linkgit:git-submodule[1] `summary`. Cuando se especifica `--submodule=diff` se usa el formato 'diff'. Este formato muestra un diff en-linea de los cambios en el contenido del submódulo entre el rango del commit. Se predetermina a `diff.submodule` o al formato 'short' si la opción de configuración no es asignada.

--color[=<cuando>]::
	Muestra diff coloreado. `--color` (ej. sin '=<cuando>') es lo mismo que `--color=always`. '<cuando>' puede ser uno de `always`, `never` o `auto`.
ifdef::git-diff[]
	Puede se modificado por las configuraciones `color.ui` y 
	`color.diff`.
endif::git-diff[]

--no-color::
	Desactiva diff coloreado.
ifdef::git-diff[]
	Puede ser usado para sobre-escribir configuraciones.
endif::git-diff[]
	Es lo mismo que `--color=never`.

--color-moved[=<modo>]::
	Los renglones de código trasladados se señalan con un color distinto.
ifdef::git-diff[]
	Puede ser modificado por la configuración `diff.colorMoved`.
endif::git-diff[]
	El <modo> se predetermina a 'no' si no se da la opción
	y a 'zebra' si se da la opción sin modo.
	El modo debe ser uno de:
+
--
no::
	Lineas movidas no son resaltadas.
default::
	Es un sinónimo para `zebra`. Esto puede cambiar a un modo mas sensible en el futuro.
plain::
	Cualquier linea añadida en una ubicación y que haya sido removida en otra ubicación será coloreada con 'color.diff.newMoved'. Similarmente 'color.diff.oldMoved' será usado para líneas removidas que fueron añadidas en algún otro lado en el diff. Este modo toma cualquier línea movida, pero no es muy útil en un revisión para determinar si un bloque de código fue movido sin permutación.
blocks::
	Bloques de texto movido de al menos 20 caracteres alfanuméricos se detectan codiciosamente. Los bloques detectados se pintan usando cualquier color 'color.diff.{old,new}Moved'. No se pueden distinguir bloques adyacentes.
zebra::
	Los bloques de texto movido se detectan como en el modo 'blocks'. Los bloques se colorean con cualquier color 'color.diff.{old,new}Moved' o 'color.diff.{old.new}MovedAlternative'. El cambio entre los dos colores indica que fue detectado un bloque nuevo.
dimmed-zebra::
	Similar a 'zebra', pero se hace un oscurecimiento adicional de partes no-interesantes de código movido. Las líneas limitantes de dos bloques adyacentes se consideran interesantes, el resto es no-interesante. `dimmed_zebra` es un sinónimo obsoleto.
--

--no-color-moved::
	Apaga la detección de movimiento. Puede ser usada para sobre-escribir configuraciones. Es lo mismo que `--color-moved=no`.

--color-moved-ws=<modos>::
	Este configura como el espacio en blanco es ignorado cuando se hace la detección de movimiento para `--color-moved`.
ifdef::git-diff[]
	Puede ser asignado por la configuración `diff.colorMovedWS`.
endif::git-diff[]
	Estos modos pueden se dados como una lista separada por comas:
+
--
no::
	No ignora espacio en blanco cuando se hace detección de movimiento.
ignore-space-at-eol::
	Ignorar cambios de espacios en blanco al finalizar renglón.
ignore-space-change::
	Ignora cambios en la cantidad de espacios en blanco. Esto ignora espacio en blanco al final de la línea, y considera todas las otras secuencias de uno o mas caracteres de espacio en blanco como equivalentes.
ignore-all-space::
	Ignora espacios en blanco al comparar líneas. Esto ignora diferencias incluso si una línea tiene espacio en blanco donde la otra no tiene alguno.
allow-indentation-change::
	Inicialmente ignora cualquier espacio en blanco en la detección de movimiento, y luego agrupa los bloques de código movido sólo en un bloque si el cambio en espacios en blanco es el mismo por línea. Esto es incompatible con los otros modos.
--

--no-color-moved-ws::
	No ignorar espacio en blanco durante detección de movimiento. Esto puede usarse para anular ajustes de configuración. Es lo mismo que `--color-moved-ws=no`.

--word-diff[=<modo>]::
	Muestra diferencias entre palabras, utilizando el <modo> para delimitar las palabras cambiadas. De manera predeterminada, las palabras se delimitan por espacios; consulte `--word-diff-regex` más abajo. El <modo> predeterminado es «plain», y debe ser uno de:
+
--
color::
	Resaltar palabras modificadas usando sólo colores. Implica `--color`.
plain::
	Mostrar palabras como `[-removed-]` y `{+added+}`. No intenta escapar delimitadores si aparecen en la entrada, entonces la salida puede ser ambigua.
porcelain::
	Usa un formato especial basado en líneas intencionado para consumo de scripts. Las acciones añadir/eliminar/sin-modificar se imprimen en el formato usual diff unificado, comenzando con un caracter `+`/`-`/` ` al principio de la línea y extendiendo al final de la línea. Nuevas líneas se representan con una tilde `~` en una línea misma.
none::
	Desactiva de nuevo las diferencias entre palabras.
--
+
Nota que a pesar del nombre del primer modo, el color -si esta habilitado- se usa para resaltar las partes cambiadas en todos los modos.

--word-diff-regex=<expresión regular>::
	Usa <expresión-regular> para decidir qué es una palabra, en lugar de considerar no-espacios en blanco seguidos como una palabra. También implica `--word-diff` a menos que ya haya sido habilitado.
+
Cada coincidencia sin traslape de <expresión-regular> se considera una palabra. Lo que esté entre esas coincidencias se considera espacio en blanco y es ignorado(!) para propósito de encontrar diferencias. Querrás agregar `|[^[:space:]]` a tu expresión regular para asegurarte que coincida todos lo caracteres que no son espacio en blanco. Una coincidencia que contenga salto de línea es silenciosamente truncada(!) en el salto de línea.
+
Por ejemplo, `--word-diff-regex=.` tratará cada carácter como si fuese una palabra y, por tanto, mostrará las diferencias carácter por carácter.
+
La expresión regular también puede asignarse por un controlador de diff u opción de configuración, ver linkgit:gitattributes[5] o linkgit:git-config[1]. Dándolo explícitamente anula cualquier controlador de diff u opción de configuración. Los controladores de diff anulan ajustes de configuración.

--color-words[=<expresión regular>]::
	Equivalente a `--word-diff=color` mas (si se especificó una expresión regular) `--word-diff-regex=<expresión-regular>`.
endif::git-format-patch[]

--no-renames::
	Apaga la detección de renombramiento, incluso cuando el fichero de configuración predetermina hacerlo.

--[no-]rename-empty::
	Si usar blobs vacíos como fuente de renombramiento.

ifndef::git-format-patch[]
--check::
	Advierte si los cambios introducidos conflictúan marcadores o errores de espacio en blanco. Lo que es considerado error de espacio en blanco es controlado por la configuración `core.whitespace`. Predeterminadamente, espacios en blanco al final (incluyendo líneas que consisten únicamente en espacios en blanco) y un caracter espacio que es inmediatamente seguido por una caracter tabulador dentro del indentado inicial de una línea, son considerados errores de espacio en blanco. Sale con un estatus no-cero si se encuentran problemas. No compatible con --exit-code.

--ws-error-highlight=<tipo>::
	Resalta errores de espacio en blanco en las líneas `context`, `old ` o `new` del diff. Valores múltiples se separan con coma, `none` restablece valores previos, `default` restablece la lista a `new` y `all` es una forma corta de `old,new,context`. Cuando no se da esta opción y no se asigna la variable de configuración `diff.wsErrorHighlight`, sólo se resaltan errores de espacio en blanco en líneas `new`. Los errores de espacio en blanco se colorean con `color.diff.whitespace`.

endif::git-format-patch[]

--full-index::
	En lugar del primer puñado de caracteres, muestra los nombres completos pre- y post-imágen de objeto blob en la línea del índice cuando se genera la salida del formato de parche.

--binary::
	Además de `--full-index`, saca un diff binario que puede ser aplicado con `git-apply`.
ifndef::git-format-patch[]
	Implica `--patch`.
endif::git-format-patch[]

--abbrev[=<n>]::
	En lugar de mostrar el nombre de objeto completo en 40 bytes hexadecimal en la salida del formato diff-raw y en las líneas de encabezado de diff-tree, muestra el prefijo más corto que es de por lo menos '<n>' dígitos hexadecimales de largo que refiere únicamente al objeto. En el formato diff-patch, `--full-index` toma mayor precedencia, ej. si se especifica `--full-index`, se mostrarán los nombres completos de blob sin importar `--abbrev`. Un número no-predeterminado de dígitos puede especificarse con `--abbrev=<n>`.

-B[<n>][/<m>]::
--break-rewrites[=[<n>][/<m>]]::
	Rompe cambios de reescritura completa en pares de borrado y creado. Esto sirve para dos propósitos:
+
Afecta la manera en que un cambio suma al total de reescrituras de un fichero, no como una serie de borrados e inserciones mezcladas con unas cuantas líneas que resultan coincidir textualmente con el contexto, sino como un sólo borrado de todo lo anterior seguido por una sola inserción de todo lo nuevo, y el número `m` controla éste aspecto de la opción -B (predeterminado a 60%). `-B/70%` especifica que menos del 30% del original debe permanecer en el resultado para que Git lo considere una reescritura total (ej. de lo contrario el parche resultante sería una serie de borrados e inserciones mezclada con líneas de contexto).
+
Cuando se usa con -M, un fichero totalmente reescrito se considera la fuente de un cambio de nombre (usualmente -M sólo considera un fichero que desaparece como fuente de un cambio de nombre), y un número `n` controla éste aspecto de la opción -B (predeterminado a 50%). `-B20%` especifica que un cambio con adición y eliminación comparado con el 20% o mas del tamaño de fichero es elegible para ser seleccionado como una posible fuente de cambio de nombre a otro fichero.

-M[<n>]::
--find-renames[=<n>]::
ifndef::git-log[]
	Detectar cambios de nombre.
endif::git-log[]
ifdef::git-log[]
	Si se generan diffs, detecta y reporta cambios de nombre por cada commit
	Para seguir ficheros a través de los cambios de nombre en el historial, ver
	`--follow`.
endif::git-log[]
	If `n` is specified, it is a threshold on the similarity
	index (i.e. amount of addition/deletions compared to the
	file's size). For example, `-M90%` means Git should consider a
	delete/add pair to be a rename if more than 90% of the file
	hasn't changed.  Without a `%` sign, the number is to be read as
	a fraction, with a decimal point before it.  I.e., `-M5` becomes
	0.5, and is thus the same as `-M50%`.  Similarly, `-M05` is
	the same as `-M5%`.  To limit detection to exact renames, use
	`-M100%`.  The default similarity index is 50%.

-C[<n>]::
--find-copies[=<n>]::
	Detect copies as well as renames. See also `--find-copies-harder`. If `n` is specified, it has the same meaning as for `-M<n>`.

--find-copies-harder::
	For performance reasons, by default, `-C` option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one `-C` option has the same effect.

-D::
--irreversible-delete::
	Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and `/dev/null`. The resulting patch is not meant to be applied with `patch` or `git apply`; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.
+
When used together with `-B`, omit also the preimage in the deletion part of a delete/create pair.

-l<número>::
	The `-M` and `-C` options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.

ifndef::git-format-patch[]
--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]::
	Select only files that are Added (`A`), Copied (`C`), Deleted (`D`), Modified (`M`), Renamed (`R`), have their type (i.e. regular file, symlink, submodule, ...) changed (`T`), are Unmerged (`U`), are Unknown (`X`), or have had their pairing Broken (`B`). Any combination of the filter characters (including none) can be used. When `*` (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.
+
Also, these upper-case letters can be downcased to exclude. E.g. `--diff-filter=ad` excludes added and deleted paths.
+
Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.

-S<cadena>::
	Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter's use.
+
It is useful when you're looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into `-S`, and keep going until you get the very first version of the block.
+
Binary files are searched as well.

-G<expresión regular>::
	Look for differences whose patch text contains added/removed lines that match <regex>.
+
To illustrate the difference between `-S<regex> --pickaxe-regex` and `-G<regex>`, consider a commit with the following diff in the same file:
+
----
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
----
+
While `git log -G"frotz\(nitfol"` will show this commit, `git log -S"frotz\(nitfol" --pickaxe-regex` will not (because the number of occurrences of that string did not change).
+
Unless `--text` is supplied patches of binary files without a textconv filter will be ignored.
+
See the 'pickaxe' entry in linkgit:gitdiffcore[7] for more information.

--find-object=<id-de-objeto>::
	Look for differences that change the number of occurrences of the specified object. Similar to `-S`, just the argument is different in that it doesn't search for a specific string but for a specific object id.
+
The object can be a blob or a submodule commit. It implies the `-t` option in `git-log` to also find trees.

--pickaxe-all::
	When `-S` or `-G` finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.

--pickaxe-regex::
	Treat the <string> given to `-S` as an extended POSIX regular expression to match.

endif::git-format-patch[]

-O<orderfile>::
	Control the order in which files appear in the output. This overrides the `diff.orderFile` configuration variable (see linkgit:git-config[1]). To cancel `diff.orderFile`, use `-O/dev/null`.
+
The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.
+
<orderfile> is parsed as follows:
+
--
 - Blank lines are ignored, so they can be used as separators for readability.

 - Lines starting with a hash ("`#`") are ignored, so they can be used for comments. Add a backslash ("`\`") to the beginning of the pattern if it starts with a hash.

 - Each other line contains a single pattern.
--
+
Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern "`foo*bar`" matches "`fooasdfbar`" and "`foo/bar/baz/asdf`" but not "`foobarx`".

--skip-to=<fichero>::
--rotate-to=<fichero>::
	Discard the files before the named <file> from the output (i.e. 'skip to'), or move them to the end of the output (i.e. 'rotate to'). These were invented primarily for use of the `git difftool` command, and may not be very useful otherwise.

ifndef::git-format-patch[]
-R::
	Swap two inputs; that is, show differences from index or on-disk file to tree contents.
endif::git-format-patch[]

--relative[=<ruta>]::
--no-relative::
	When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. `--no-relative` can be used to countermand both `diff.relative` config option and previous `--relative`.

-a::
--text::
	Tratar todos los archivos como si fueran de texto.

--ignore-cr-at-eol::
	Ignore carriage-return at the end of line when doing a comparison.

--ignore-space-at-eol::
	Ignorar cambios de espacios en blanco al finalizar renglón.

-b::
--ignore-space-change::
	Ignora cambios en la cantidad de espacios en blanco. Esto ignora espacio en blanco al final de la línea, y considera todas las otras secuencias de uno o mas caracteres de espacio en blanco como equivalentes.

-w::
--ignore-all-space::
	Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.

--ignore-blank-lines::
	Ignorar cambios cuyos renglones están todos vacíos.

-l<expresión-regular>::
--ignore-matching-lines=<expresión-regular>::
	Ignore changes whose all lines match <regex>. This option may be specified more than once.

--inter-hunk-context=<líneas>::
	Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to `diff.interHunkContext` or 0 if the config option is unset.

-W::
--function-context::
	Show whole function as context lines for each change. The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5]).

ifndef::git-format-patch[]
ifndef::git-log[]
--exit-code::
	Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.

--quiet::
	Disable all output of the program. Implies `--exit-code`.
endif::git-log[]
endif::git-format-patch[]

--ext-diff::
	Allow an external diff helper to be executed. If you set an external diff driver with linkgit:gitattributes[5], you need to use this option with linkgit:git-log[1] and friends.

--no-ext-diff::
	Disallow external diff drivers.

--textconv::
--no-textconv::
	Allow (or disallow) external text conversion filters to be run when comparing binary files. See linkgit:gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for linkgit:git-diff[1] and linkgit:git-log[1], but not for linkgit:git-format-patch[1] or diff plumbing commands.

--ignore-submodules[=<cuando>]::
	Ignore changes to submodules in the diff generation. <when> can be either "none", "untracked", "dirty" or "all", which is the default. Using "none" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the 'ignore' option in linkgit:git-config[1] or linkgit:gitmodules[5]. When "untracked" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using "dirty" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using "all" hides all changes to submodules.

--src-prefix=<prefijo>::
	Mostrar el prefijo de origen indicado en lugar de «a/».

--dst-prefix=<prefijo>::
	Mostrar el prefijo de destino indicado en lugar de «b/».

--no-prefix::
	No mostrar ningún prefijo de origen o de destino.

--default-prefix::
	Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as `diff.noprefix`.

--line-prefix=<prefijo>::
	Anteponer un prefijo adicional a cada línea mostrada.

--ita-invisible-in-index::
	By default entries added by "git add -N" appear as an existing empty file in "git diff" and a new file in "git diff --cached". This option makes the entry appear as a new file in "git diff" and non-existent in "git diff --cached". This option could be reverted with `--ita-visible-in-index`. Both options are experimental and could be removed in future.

For more detailed explanation on these common options, see also linkgit:gitdiffcore[7].
