git-reset(1)
============

NOMBRE
------
git-reset - Restablece el HEAD actual a un estado especifico

SINOPSIS
--------
[synopsis]
git reset [-q] [<árbol-ismo>] [--] <especificación-de-ruta>...
git reset [-q] [--pathspec-from-file=<fichero> [--pathspec-file-nul]] [<árbol-ismo>]
git reset (--patch | -p) [<árbol-ismo>] [--] [<especificación-de-ruta>...]
git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<confirmación>]

DESCRIPCIÓN
-----------
En las primeras tres formas, copia entradas de _<árbol-ismo>_ al índice. En la última forma, establece la rama actual head (`HEAD`) a _<confirmación>_, modificando opcionalmente el índice y el árbol de trabajo para que coincidan. _<árbol-ismo>_/_<confirmación>_ están predeterminados a `HEAD` en todas las formas.

`git reset [-q] [<árbol-ismo>] [--] <ruta>...`::
`git reset [-q] [--pathspec-from-file=<fichero> [--pathspec-file-nul]] [<árbol>]`::
	Estas formas restablecen las entradas del índice para todas las rutas que coincidan la _<especificación-de-ruta>_ al su estado en _<árbol-ismo>_. (No afecta el árbol de trabajo o la rama actual.)
+
Esto significa que `git reset <especificación-de-ruta>` es lo opuesto a `git add <especificación-de-ruta>`. Este comando equivale a `git restore [--source=<árbol-ismo>] --staged <especificación-de-ruta>...`.
+
Después de ejecutar `git reset <especificación-de-ruta>` para actualizar la entrada del índice, puedes usar linkgit:git-restore[1] para poner el contenido fuera del índice en el árbol de trabajo. Alternativamente, el contenido de una ruta fuera de una confirmación lo puedes copiar al índice y al árbol de trabajo de una vez usando linkgit:git-restore[1] y especificando una confirmación con `--source`.

`git reset (--patch | -p) [<árbol-ismo>] [--] [<ruta>...]`::
	Selecciona interactivamente pedazos en la diferencia entre el índice y _<árbol-ismo>_ (predeterminado a `HEAD`). Los pedazos elegidos se aplican en reversa al índice.
+
Esto significa que `git reset -p` es lo opuesto a `git add -p`, ej. puedes usarlo para restaurar selectivamente pedazos. Ver la sección "Modo Interactivo" de linkgit:git-add[1] para aprender cómo operar el modo `--patch`.

`git reset [<modo>] [<confirmación>]`::
	Esta forma restablece la cabeza de la rama actual a _<confirmación>_ y posiblemente actualiza el índice (restableciéndolo al árbol de _<confirmación>_) y el árbol de trabajo dependiendo de _<modo>_. Antes de la operación, `ORIG_HEAD` se establece a la punta de la rama actual. Si se omite _<modo>_, se predetermina a `--mixed`. El _<modo>_ debe ser uno de los siguientes:
+
--
`--soft`::
	No toques los ficheros del índice o del árbol de trabajo en absoluto (exceptuando restablecer la cabeza a _<confirmación>_, tal y como lo hacen todos los modos). Esto deja a todos tus ficheros modificados como "Cambios a confirmar", como `git status` lo haría.

`--mixed`::
	Restablece el índice pero no el árbol de trabajo (p. ej. los ficheros modificados se preservan pero no se marcan para confirmar) e informa qué no se ha actualizado. Esta es la acción predeterminada.
+
Si se especifica `-N`, las rutas eliminadas son marcadas como intento de inclusión (ver linkgit:git-add[1]).

`--hard`::
	Restablece el índice y el árbol de trabajo. Cualquier cambio a ficheros con seguimiento en el árbol de trabajo desde _<confirmación>_ es descartado. Cualquier fichero sin seguimiento o directorio en camino de escribir cualquier fichero con seguimiento es simplemente eliminado.

`--merge`::
	Restablece el índice y actualiza los ficheros en el árbol de trabajo que son diferentes entre _<confirmación>_ y `HEAD`, pero mantiene aquellos que son diferentes entre el índice y el árbol de trabajo (p. ej. aquellos cambios que no han sido agregados). Si un fichero tiene diferencias entre _<confirmación>_ y el índice tiene cambios sin presentar, se aborta el restablecimiento.
+
En otras palabras, `--merge` hace algo como un `git read-tree -u -m <confirmación>`, pero acarrea hacia adelante entradas del índice sin fusionar.

`--keep`::
	Restablece entradas del índice y actualiza ficheros en el árbol de trabajo que tienen diferencias entre _<confirmación>_ y `HEAD`. Si un fichero tiene diferencias entre _<confirmación>_ y `HEAD` tiene cambios locales, se aborta el restablecimiento.

`--recurse-submodules`::
`--no-recurse-submodules`::
	Cuando se actualiza el árbol de trabajo, usar `--recurse-submodules` también restablecerá recursivamente el árbol de trabajo de todos los submódulos activos según la confirmación registrada en el superproyecto, también separando la `HEAD` de los submódulos de esa confirmación.
--

Ver "Restablecer, restaurar y revertir" en linkgit:git[1] para diferenciar los tres comandos.


OPCIONES
--------

`-q`::
`--quiet`::
	Ser silencioso, solo reportar errores.

`--refresh`::
`--no-refresh`::
	Refresca el índice después de restablecimiento mixto. Habilitado predeterminadamente.

`--pathspec-from-file=<fichero>`::
	La especificación de ruta se pasa en `_<fichero>_` y no como argumento en la línea de comandos. Si `_<fichero>_` es exactamente `-` entonces se usa la entrada estándar. Los elementos de la especificación de ruta se separan por _LF_ o _CR_/_LF_. Los elementos de la especificación de ruta pueden ser entrecomillados como se explica para la variable de configuración `core.quotePath` (ver linkgit:git-config[1]). Ver también `--pathspec-file-nul` y `--literal-pathspecs` global.

`--pathspec-file-nul`::
	Sólo significativo con `--pathspec-from-file`. Los elementos de la especificación de ruta se separan con el caracter _NUL_ y todos los otros caracteres se toman literalmente (incluyendo saltos de línea y entrecomillados).

include::diff-context-options.adoc[]

`--`::
	No interpreta ningún argumento mas como opciones.

`<especificación-de-ruta>...`::
	Limita las rutas afectadas por la operación.
+
Para mas detalles, ver 'pathspec' en linkgit:gitglossary[7].

EJEMPLOS
--------

Deshacer inclusión::
+
------------
$ edit                                     <1>
$ git add frotz.c filfre.c
$ mailx                                    <2>
$ git reset                                <3>
$ git pull git://info.example.com/ nitfol  <4>
------------
+
<1> Estas felizmente trabajando en algo y los cambios en esos ficheros ya los ves bien; no quieres verlos al hacer `git diff` porque planeas trabajar en otros ficheros y los cambios a los primeros te distraen.
<2> Alguien te pide incorporar, y parece que vale la pena fusionar esos cambios.
<3> Sin embargo, ya ensuciaste el índice (es decir, tu índice no coincide con la `HEAD` de la confirmación). Pero sabes que la incorporación que vas a hacer no afecta `frotz.c` o `filtre.c`, así que reviertes los cambios al índice para esos dos ficheros. Tus cambios en el árbol de trabajo permanecen ahí.
<4> Entonces puedes incorporar y fusionar, manteniendo aún los cambios en `frotz.c` y `filfre.c` en el árbol de trabajo.

Deshacer una confirmación y rehacer::
+
------------
$ git commit ...
$ git reset --soft HEAD^      <1>
$ edit                        <2>
$ git commit -a -c ORIG_HEAD  <3>
------------
+
<1> Esto se hace mas frecuentemente cuando recuerdas que esta incompleto lo que acabas de confirmar, o escribiste mal tu mensaje de confirmación, o ambos. Deja el árbol de trabajo como estaba antes del "reset".
<2> Hacer correcciones a ficheros del árbol de trabajo.
<3> "reset" copia la cabeza anterior a `.git/ORIG_HEAD`; rehace la confirmación comenzando con su mensaje de registro. Si no necesitas editar mas el mensaje, simplemente puedes dar la opción `-C`.
+
Ve también la opción `--amend` de linkgit:git-commit[1].

Deshacer una confirmación, haciéndola una rama tópica::
+
------------
$ git branch topic/wip          <1>
$ git reset --hard HEAD~3       <2>
$ git switch topic/wip          <3>
------------
+
<1> Has hecho algunas confirmaciones, pero te das cuenta que fue prematuro hacerlo en la rama `master`. Quieres continuar puliéndolas en una rama tópica, entonces creas la rama `topic/wip` a partir de la `HEAD` actual.
<2> Regresas la rama master para deshacerte de esas tres confirmaciones.
<3> Cambias a la rama `topic/wip` y sigues trabajando.

Deshacer confirmaciones permanentemente::
+
------------
$ git commit ...
$ git reset --hard HEAD~3   <1>
------------
+
<1> Las últimas tres confirmaciones (`HEAD`, `HEAD^` y `HEAD~2`) estuvieron mal y no quieres ni siquiera verlas otra vez. *No* hagas esto si ya le has dado esas confirmaciones a alguien mas. (Ver la sección "Recuperándose de un rebase río arriba" en linkgit:git-rebase[1] para las implicaciones de hacerlo.)

Deshacer una fusión o incorporación::
+
------------
$ git pull                         <1>
Auto-merging nitfol
CONFLICT (content): Merge conflict in nitfol
Automatic merge failed; fix conflicts and then commit the result.
$ git reset --hard                 <2>
$ git pull . topic/branch          <3>
Updating from 41223... to 13134...
Fast-forward
$ git reset --hard ORIG_HEAD       <4>
------------
+
<1> El intento de actualizar desde el origen resultó en un montón de conflictos; y como no estabas listo para pasar mucho tiempo fusionando en el momento decides hacerlo después.
<2> "pull" no confirmó la fusión, entonces `git reset --hard` que es un sinónimo de `git reset --hard HEAD` limpia el desastre partiendo del fichero del índice y el árbol de trabajo.
<3> Fusiona una rama tópica en el rama actual, lo que resulta en un avance rápido.
<4> Pero decidiste que la rama tópica aún no esta lista para consumo público. "pull" o "merge" siempre dejan la punta original de la rama actual en `ORIG_HEAD`, de tal manera que restableciéndola duramente te trae de vuelta tu fichero del índice y el árbol de trabajo en ese estado, y restablece la punta de la rama a esa confirmación.

Deshacer una fusión o incorporación dentro de un árbol de trabajo sucio::
+
------------
$ git pull                         <1>
Auto-merging nitfol
Merge made by recursive.
 nitfol                |   20 +++++----
 ...
$ git reset --merge ORIG_HEAD      <2>
------------
+
<1> Incluso si tuvieras modificaciones locales en tu árbol de trabajo, puedes hacer con seguridad `git pull` cuando sabes que los cambios en la otra rama no se traslapan con los tuyos.
<2> Después de inspeccionar el resultado de la fusión, podrías encontrar que el cambio en la otra rama es insatisfactorio. Ejecutar `git reset --hard ORIG_HEAD` te regresará a donde estabas, pero descartará tus cambios locales, lo cual no quieres. `git reset --merge` mantiene tus cambios locales.


Flujo de trabajo interrumpido::
+
Supón que te interrumpen para pedirte una corrección urgente cuando estas en medio de un cambio grande. Los ficheros en tu árbol de trabajo aún no están como para ser confirmados, pero necesitas obtener la otra rama para una corrección rápida.
+
------------
$ git switch feature  ;# trabajas en la rama "feature" y
$ work work work      ;# te interrumpen
$ git commit -a -m "snapshot WIP"                 <1>
$ git switch master
$ fix fix fix
$ git commit ;# confirma con registro real
$ git switch feature
$ git reset --soft HEAD^ ;# de regreso al estado de WIP  <2>
$ git reset                                       <3>
------------
+
<1> Esta confirmación explotará, así que un mensaje de desecho no va mal.
<2> Esto quita la confirmación 'WIP' del historial de confirmaciones, y establece tu árbol de trabajo al estado justo antes de que hicieras esa instantánea.
<3> En este punto el fichero del índice aún tiene todos los cambios de WIP que confirmaste como 'snapshot WIP'. Esto actualiza el índice para mostrar tus ficheros de WIP como no confirmados.
+
Ver también linkgit:git-stash[1].

Restablecer un solo fichero en el índice::
+
Supón que has agregado un fichero a tu índice, pero luego decides que no quieres incluirlo en tu confirmación. Puedes quitar el fichero del índice manteniendo tus cambios con git reset.
+
------------
$ git reset -- frotz.c                      <1>
$ git commit -m "Confirma ficheros en índice"     <2>
$ git add frotz.c                           <3>
------------
+
<1> Esto quita el fichero del índice mientras lo mantiene en el directorio de trabajo.
<2> Esto confirma todos los cambios en el índice.
<3> Agrega el archivo de nuevo al índice.

Mantiene los cambios en el árbol de trabajo descartando algunas confirmaciones previas::
+
Supón que estas trabajando en algo y lo confirmas, luego trabajas un poco mas, pero ahora piensas que lo que acabas de hacer debería ir en otra rama que no tiene nada que ver con lo que confirmaste anteriormente. Puedes comenzar una rama nueva y restablecerla manteniendo los cambios en tu árbol de trabajo.
+
------------
$ git tag start
$ git switch -c branch1
$ edición
$ git commit ...                            <1>
$ edición
$ git switch -c branch2                     <2>
$ git reset --keep start                    <3>
------------
+
<1> Esto confirma tus primeras ediciones en `branch1`.
<2> En un mundo ideal, al querer crear `branch2` y cambiar a ella podrías haber notado que la confirmación anterior no pertenece al nuevo tópico (es decir, `git switch -c branch2 start`), pero nadie es perfecto.
<3> Pero ahora puedes usar `reset --keep` para quitar la confirmación no deseada después de cambiar a `branch2`.

Dividir una confirmación en una secuencia de confirmaciones::
+
Supón que has creado montones de cambios lógicamente separados y que los has confirmado en conjunto. Después decides que hubiera sido mejor tener cada grupo de pedazos lógicamente relacionados en su propia confirmación. Puedes usar git reset para rebobinar el historial sin modificar el contenido de tus ficheros locales, y hacer sucesivamente `git add -p` para seleccionar interactivamente qué pedazos se incluirán en cada confirmación, usando `git commit -c` para pre-llenar el mensaje de confirmación.
+
------------
$ git reset -N HEAD^                        <1>
$ git add -p                                <2>
$ git diff --cached                         <3>
$ git commit -c HEAD@{1}                    <4>
...                                         <5>
$ git add ...                               <6>
$ git diff --cached                         <7>
$ git commit ...                            <8>
------------
+
<1> Primero, restablece el historial una confirmación hacia atrás para eliminar la confirmación original, pero dejando el árbol de trabajo con todos sus cambios. `-N` asegura que cualquier fichero nuevo agregado con `HEAD` quede marcado para que `git add -p` los encuentre.
<2> Después, interactivamente seleccionamos los pedazos de diferencia a agregar usando la prestación `git add -p`. Esto te preguntará en secuencia por cada pedazo de diferencia y podrás simplemente usar instrucciones como "si, incluirlo", "no incluirlo" o la muy poderosa "editar".
<3> Una vez satisfecho con los pedazos que quieres incluir, deberías verificar lo que se ha preparado para la primer confirmación usando `git diff --cached`. Esto muestra todos los cambios que se han movido al índice y serán confirmados.
<4> Lo siguiente, confirmar los cambios almacenados en el índice. La opción `-c` especifica pre-llenar el mensaje de confirmación a partir del mensaje original que iniciaste en la primer confirmación. Esto ayuda a evitar volver a teclearlo. `HEAD@{1}` es una notación especial para referirse a la confirmación donde estaba `HEAD` antes de la confirmación original restablecida (hace 1 cambio). Ver linkgit:git-reflog[1] para mas detalles. También puedes usar cualquier otra referencia de confirmación válida.
<5> Puedes repetir los pasos 2 a 4 varias veces para despedazar el código original en cualquier número de confirmaciones.
<6> Ahora que has dividido varios cambios en sus respectivas confirmaciones, puede que ya no uses el modo de parche de `git add`, con tal de seleccionar los cambios sin confirmar restantes.
<7> Una vez mas, revisa que lo incluido es lo que quieres. También querrías verificar que git diff no muestre algún cambio remanente a ser confirmado después.
<8> Y por último, crear la confirmación final.


DISCUSIÓN
---------

Las tablas de abajo muestran lo que sucede al ejecutar:

----------
git reset --option target
----------

para restablecer `HEAD` a otra confirmación (`target`) con opciones diferentes dependiendo del estado de los ficheros.

En estas tablas, `A`, `B`, `C` y `D` son estados diferentes de un fichero. Por ejemplo, la primer línea de la primer tabla significa que si un fichero esta en estado `A` en el árbol de trabajo, en estado `B` en el índice, en estado `C` en `HEAD` y en estado `D` en target, entonces `git reset --soft target` dejará el fichero en el árbol de trabajo en estado `A` y en el índice en estado `B`. Restablece (es decir, mueve) `HEAD` (la punta de la rama actual, si no estas en una) a `target` (que tiene el fichero en estado `D`).

....
árbol  índice HEAD   target         árbol  índice HEAD
------------------------------------------------------
 A      B      C      D     --soft   A      B      D
                            --mixed  A      D      D
                            --hard   D      D      D
                            --merge (no permitido)
                            --keep  (no permitido)
....

....
árbol índice HEAD target         árbol índice HEAD
----------------------------------------------------
 A     B      C    C     --soft   A     B      C
                         --mixed  A     C      C
                         --hard   C     C      C
                         --merge (no permitido)
                         --keep   A     C      C
....

....
árbol índice HEAD target         árbol índice HEAD
----------------------------------------------------
 B     B      C    D     --soft   B     B      D
                         --mixed  B     D      D
                         --hard   D     D      D
                         --merge  D     D      D
                         --keep  (no permitido)
....

....
árbol índice HEAD target         árbol índice HEAD
----------------------------------------------------
 B     B      C    C     --soft   B     B      C
                         --mixed  B     C      C
                         --hard   C     C      C
                         --merge  C     C      C
                         --keep   B     C      C
....

....
árbol índice HEAD target         árbol índice HEAD
----------------------------------------------------
 B     C      C    D     --soft   B     C      D
                         --mixed  B     D      D
                         --hard   D     D      D
                         --merge (no permitido)
                         --keep  (no permitido)
....

....
árbol índice HEAD target         árbol índice HEAD
----------------------------------------------------
 B     C      C    C     --soft   B     C      C
                         --mixed  B     C      C
                         --hard   C     C      C
                         --merge  B     C      C
                         --keep   B     C      C
....

`git reset --merge` es para cuando se quiere restablecer de una fusión con conflictos. Cualquier operación de fusión garantiza que, antes de iniciar, el fichero del árbol de trabajo involucrado en la fusión no tenga un cambio local con respecto al índice, y que escriba el resultado en el árbol de trabajo. Así que si vemos algunas diferencias entre el índice y target y también entre el índice y el árbol de trabajo, eso significa que no estamos restableciendo desde un estado que quedó de una operación de fusión fallida por un conflicto. Es por ello que no se permite la opción `--merge` en este caso.

`git reset --keep` es para cuando se eliminan algunas de las últimas confirmaciones en la rama actual mientras se mantienen los cambios en el árbol de trabajo. Si hubieran conflictos entre los cambios en la confirmación que queremos eliminar y los cambios en el árbol de trabajo que queremos mantener, no se permite restablecer. Es por eso que no se permite si hay cambios tanto entre el árbol de trabajo y `HEAD` como entre `HEAD` y target. Por seguridad, tampoco se permite cuando hay entradas sin fusionar.

Las tablas siguientes muestran lo que sucede cuando hay entradas sin fusionar:

....
árbol índice HEAD target         árbol índice HEAD
----------------------------------------------------
 X     U      A    B     --soft  (no permitido)
                         --mixed  X     B      B
                         --hard   B     B      B
                         --merge  B     B      B
                         --keep  (no permitido)
....

....
árbol índice HEAD target         árbol índice HEAD
----------------------------------------------------
 X     U      A    A     --soft  (no permitido)
                         --mixed  X     A      A
                         --hard   A     A      A
                         --merge  A     A      A
                         --keep  (no permitido)
....

`X` significa cualquier estado y `U` significa un índice sin fusionar.

GIT
---
Parte de la suite de linkgit:git[1]
