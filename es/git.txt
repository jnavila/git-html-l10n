git(1)
======

NOMBRE
------
git - el estúpido rastreador de contenido


SINOPSIS
--------
[verse]
'git' [-v | --version] [-h | --help] [-C <ruta>] [-c <nombre>=<valor>]
           [--exec-path[=<ruta>]] [--html-path] [--man-path] [--info-path]
           [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<ruta>] [--work-tree=<ruta>] [--namespace=<nombre>]
           [--config-env=<nombre>=<var-ambiente>] <comando> [<args>]

DESCRIPCIÓN
-----------
Git es un sistema de control de revisiones distribuido, rápido y escalable con un conjunto de comandos inusualmente rico que permite tanto operaciones de alto nivel como acceso completo a componentes internos.

Ver linkgit:gittutorial[7] para comenzar, luego ver linkgit:giteveryday[7] para un útil conjunto de comandos mínimo. La liga:user-manual.html[Manual de Usuario de Git] tiene una introducción mas a fondo.

Después que domines los conceptos básicos, puedes regresar a ésta página para aprender qué comandos ofrece Git. Puedes aprender mas sobre comandos Git individuales con el comando "git help comando". La página del manual linkgit:gitcli[7] te da una vistazo de la sintáxis de comandos en la línea de comandos.

Una copia formateada e hipervinculada de la mas reciente documentación de Git puede verse en https://git.github.io/htmldocs/git.html o https://git-scm.com/docs.


OPCIONES
--------
-v::
--version::
	Imprime la versión de la suite Git de la cual proviene el programa 'git'.
+
Esta opción es internamente convertida a `git versión ...` y acepta las mismas opciones que el comando linkgit:git-version[1]. Si también se da `--help` toma precedencia sobre `--version`.

-h::
--help::
	Imprime la sinopsis y una lista de los comandos más usados comúnmente. Si se da la opción `--all` o `-a` entonces todos los comandos disponibles se imprimen. Si un comando Git es nombrado, esta opción traerá la página del manual para ese comando.
+
Hay otras opciones disponibles para controlar cómo se muestra la página del manual. Ver linkgit:git-help[1] para mayor información, porque `git-help ...` es convertido internamente en `git help ...`.

-C <ruta>::
	Corre como si git hubiera iniciado en `<ruta>` en lugar del directorio de trabajo actual. Cuando se dan múltiples opciones `-C`, cada `-C <ruta>` no-absoluta subsecuente se interpreta como relativa al `-C <ruta>` precedente. Si `<ruta>` esta presente pero vacía, ej. `-C ""`, entonces el directorio de trabajo actual que sin modificaciones.
+
Esta opción afecta opciones que esperan una ruta (como `--git-dir` y `--work-tree`), en donde sus interpretaciones de los nombres de ruta se harían relativos al directorio de trabajo a causa de la opción `-C`. Por ejemplo, las invocaciones siguientes son equivalentes:

    git --git-dir=a.git --work-tree=b -C c status
    git --git-dir=c/a.git --work-tree=c/b status

-c <nombre>=<valor>::
	Pasa un parámetro de configuración al comando. El valor dado sobreescribirá valores de ficheros de configuración. El <nombre> se espera en el mismo formato como se lista por 'git config' (subclaves separadas por puntos).
+
Nota que es permitido omitir el `=` en `git -c foo.bar ...` y se asignará a `foo.bar` el valor booleano true (así como `[foo]bar` lo haría en un fichero de configuración). Incluir el igual pero con un valor vacío (como `git -c foo.bar= ...`) asigna a `foo.bar` la cadena vacía que `git config --type=bool` convertirá a `false`.

--config-env=<nombre>=<variable-de-ambiente>::
	Como `-c <nombre>=<valor>`, da a la variable de configuración '<nombre>' un valor, donde <variable-de-ambiente> es el nombre de una variable de ambiente de la cual se obtiene el valor. Al contrario que `-c` no hay un atajo para asignar directamente el valor a una cadena vacía, en cambio, a la variable de ambiente misma se le debe asignar la cadena vacía. Es un error si la `<variable-de-ambiente>` no existe en el ambiente. `<variable-de-ambiente>` no puede contener un signo de igual para evitar ambigüedad con `<nombre>` que contenga.
+
Esto es útil en casos donde quieres pasar a git opciones de configuración transitorias, pero se hacen tan en el SO donde otros procesos pueden ser capaces de leer tu línea de comandos (ej. `/proc/self/cmdline`), pero no tu ambiente (ej. `/proc/self/environ`). Ese es el comportamiento predeterminado en Linux, pero pudiera no serlo en tu sistema.
+
Nota que esto puede agregar seguridad para variables como `http.extraHeader` donde la información sensible es parte del valor, pero no ej. `url.<base>.insteadOf` donde la información sensible puede ser parte de la clave.

--exec-path[=<ruta>]::
	Ruta a dondequiera que estén instalados tus programas del núcleo de Git. Esto también puede ser controlado asignando la variable de ambiente GIT_EXEC_PATH. Si no se proporciona ruta 'git' imprimirá la configuración actual y saldrá.

--html-path::
	Imprime la ruta, sin la última diagonal, donde esta instalada la documentación HTML de Git y sale.

--man-path::
	Imprime la ruta del manual (ver `man(1)`) para las páginas del manual de esta versión de Git y sale.

--info-path::
	Imprime la ruta donde están instalados los ficheros de información documentando esta versión de Git y sale.

-p::
--paginate::
	Entuba toda la salida hacia 'less' (o si esta configurado, $PAGER) si la salida estándar es una terminal. Esto sobreescribe las opciones de configuración `pager.<comando>` (ver la sección "Mecanismo de Configuración" mas abajo).

-P::
--no-pager::
	No entuba la salida de Git hacia el paginador.

--git-dir=<ruta>::
	Asigna la ruta al repositorio (directorio ".git"). Esto también puede ser controlado configurando la variable de ambiente `GIT_DIR`. Puede ser una ruta absoluta o relativa al directorio de trabajo actual.
+
Especificando la ubicación del directorio ".git" usando esta opción (o la variable de ambiente `GIT_DIR`) apaga el descubrimiento de repositorio que intenta encontrar un directorio con subdirectorio ".git" (que es como se descubren el repositorio y el nivel mas alto del árbol de trabajo), y le dice a Git que estás en el nivel mas alto del árbol de trabajo. Si no estas en el directorio de nivel mas alto del árbol de trabajo, deberías decirle a Git dónde esta el nivel más alto del árbol de trabajo con la opción `--work-tree=<ruta>` (o la variable de ambiente `GIT_WORK_TREE`)
+
Si sólo quieres correr git como si fuera arrancado en `<ruta>`entonces usa `git -C <ruta>`.

--work-tree=<ruta>::
	Asigna la ruta al árbol de trabajo. Puede ser una ruta absoluta o relativa al directorio de trabajo actual. Esto puede se controlado asignando la variable de ambiente GIT_WORK_TREE y la variable de configuración core.worktree (ver core.worktree en linkgit:git-config[1] para una discusión mas detallada).

--namespace=<ruta>::
	Asigna el espacio de nombres de Git. Ver linkgit:gitnamespaces[7] para mas detalles. Equivalente a asignar la variable de ambiente `GIT_NAMESPACE`.

--bare::
	Trata el repositorio como un repositorio básico. Si la variable de ambiente GIT_DIR no esta asignada, se asigna al directorio de trabajo actual.

--no-replace-objects::
	No usa remplazamiento de referencias para remplazar objetos Git. Ver linkgit:git-replace[1] para mas información.

--literal-pathspecs::
	Trata las especificaciones de ruta literalmente (ej. sin interpretar glob, sin especificaciones de ruta mágicas). Es equivalente a asignar la variable de ambiente `GIT_LITERAL_PATHSPECS` con `1`.

--glob-pathspecs::
	Agrega magia "glob" a todas las especificaciones de ruta. Es equivalente a asignar `1` a la variable de ambiente `GIT_GLOB_PATHSPECS`. Se puede deshabilitar interpretación de glob en especificaciones de ruta individuales usando la especificación de ruta mágica ":(literal)"

--noglob-pathspecs::
	Agrega magia "literal" a todas las especificaciones de ruta. Es equivalente a asignar `1` a la variable de ambiente `GIT_NOGLOB_PATHSPECS`. Se puede habilitar interpretación de glob en especificaciones de ruta individuales usando la especificación de ruta mágica ":(glob)"

--icase-pathspecs::
	Agrega magia "icase" a todas las especificaciones de ruta. Es equivalente a asignar `1` a la variable de ambiente `GIT_ICASE_PATHSPECS`.

--no-optional-locks::
	No realiza operaciones opcionales que requieran bloqueos. Es equivalente a asignar `0` a `GIT_OPTIONAL_LOCKS`.

--list-cmds=grupo[,grupo...]::
	Lista comandos por grupo. Es una opción interna/experimental y puede cambiar o ser removida en el futuro. Los grupos soportados son: builtins, parseopt (comandos interconstruidos que usan opciones de parseo), main (todos los comandos en el directorio libexec), others (todos los otros comandos en `$PATH` que tienen el prefijo git-), list-<categoría> (ver categorías en command-list.txt), nohelpers (excluye comandos auxiliares), alias y config (obtiene la lista de comandos de la variable de configuración completion.commands)

COMANDOS GIT
------------

Dividimos Git en comandos de alto nivel ("porcelana") y comandos de bajo nivel ("plomería").

Comandos de alto nivel (porcelana)
----------------------------------

Separamos los comandos porcelana en comandos principales y algunas utilidades de usuario auxiliares.

Comandos porcelana principales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-mainporcelain.txt[]

Comandos Auxiliares
~~~~~~~~~~~~~~~~~~~
Manipuladores:

include::cmds-ancillarymanipulators.txt[]

Interrogadores:

include::cmds-ancillaryinterrogators.txt[]


Interactuando con Otros
~~~~~~~~~~~~~~~~~~~~~~~

Estos comandos son para interactuar con otros SCM y con otra gente vía parche sobre correo electrónico.

include::cmds-foreignscminterface.txt[]

Resetear, restaurar y revertir
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hay tres comandos con nombres similares: `git reset`, `git restore` y `git revert`.

* linkgit:git-revert[1] es acerca de hacer un nuevo commit que revierta los cambios hechos por otros commits.

* linkgit:git-restore[1] es acerca de restaurar ficheros en el árbol de trabajo de ya sea el índice u otro commit. Este comando no actualiza tu rama. El comando también puede usarse para restaurar ficheros en el índice de otro commit.

* linkgit:git-reset[1] es acerca de actualizar tu rama, moviendo la punta con el fin de agregar o eliminar commits de la rama. Esta operación cambia el historial de commits.
+
`git reset` también puede usarse para restaurar el índice, traslapando con `git restore`.


Comandos de bajo nivel (plomería)
---------------------------------

Aunque Git incluye su propia capa de porcelana, sus comandos de bajo nivel son suficientes para soportar desarrollo de porcelanas alternativas. Desarrolladores de tales porcelanas podrían comenzar leyendo acerca de linkgit:git-update-index[1] y linkgit:git-read-tree[1].

La interfase (entrada, salida, conjunto de opciones y la semántica) a esos comandos de bajo nivel tienen la intención de ser mucho mas estables que comandos a nivel porcelana, porque esos comandos son primordialmente para ser usados por scripts. Por otro lado, la interface a comandos porcelana esta sujeta a cambios con el fin de mejorar la experiencia de usuario final.

La descripción siguiente divide los comandos de bajo nivel en comandos que manipulan objetos (en el repositorio, índice y árbol de trabajo), comandos que interrogan y comparan objetos, y comandos que mueven objetos y referencias entre repositorios.


Comandos de manipulación
~~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-plumbingmanipulators.txt[]


Comandos de interrogación
~~~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-plumbinginterrogators.txt[]

En general, los comandos de interrogación no tocan los ficheros en el árbol de trabajo.


Sincronizando repositorios
~~~~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-synchingrepositories.txt[]

Los siguientes son comandos auxiliares usados por los anteriores; usuarios finales típicamente no los usan directamente.

include::cmds-synchelpers.txt[]


Comandos auxiliares internos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Estos son comandos auxiliares internos usados por otros comandos; usuarios finales típicamente no los usan directamente.

include::cmds-purehelpers.txt[]

Guías
-----

Las páginas de documentación siguientes son guías acerca de conceptos de Git.

include::cmds-guide.txt[]

Interfases de repositorio, comando y fichero
--------------------------------------------

Esta documentación discute interfases de repositorio y comando con las cuales se espera que los usuarios interactúen directamente. Ver `--user-formats` en linkgit:git-help[1] para mas detalles sobre los criterios.

include::cmds-userinterfaces.txt[]

Formatos de fichero, protocolos y otras interfaces para el desarrollador
------------------------------------------------------------------------

Esta documentación discute los formatos de fichero, protocolos sobre-el-cable y otras interfases de desarrollador git. Ver `--developer-interfaces` en linkgit:git-help[1].

include::cmds-developerinterfaces.txt[]

Mecanismo de Configuración
--------------------------

Git usa un formato de texto simple para almacenar personalizaciones que son por repositorio y por usuario. Tal fichero de configuración puede parecerse a éste:

------------
#
# Un caracter '#' o ';' indica un comentario.
#

; core variables
[core]
	; Don't trust file modes
	filemode = false

; identidad del usuario
[user]
	name = "Junio C Hamano"
	email = "gitster@pobox.com"

------------

Varios comandos leen del fichero de configuración y ajustan su operación respectivamente. Ver linkgit:git-config[1] para una lista y mas detalles acerca del mecanismo de configuración.


Terminología Identificadora
---------------------------
<objeto>::
	Indica el nombre del objeto para cualquier tipo de objeto.

<blob>::
	Indica un nombre de objeto blob.

<árbol>::
	Indica un nombre de objeto árbol.

<encomiendo>::
	Indica un nombre de objeto commit.

<árbol-ismo>::
	Indica un nombre de objeto árbol, commit o etiqueta. Un comando que toma un argumento <arbol-ismo> quiere operar en última instancia sobre un objeto <árbol> pero automáticamente desreferencia objetos <commit> y <etiqueta> que apuntan a un <árbol>.

<commit-ish>::
	Indica un nombre de objeto commit o etiqueta. Un comando que toma un argumento <commit-ish> de último quiere operar sobre un objeto <commit> pero automáticamente desreferencia objetos <etiqueta> que apunten a un <commit>.

<tipo>::
	Indica que un tipo de objeto es requerido. Actualmente uno de: `blob`, `tree`, `commit`, o `tag`.

<fichero>::
	Indica un nombre de fichero - casi siempre relativo a la raíz de la estructura del árbol que describe `GIT_INDEX_FILE`.

Indentificadores Simbólicos
---------------------------
Cualquier comando Git que acepte cualquier <objeto> también puede usar la notación simbólica siguiente:

HEAD::
	indica la cabeza de la rama actual.

<etiqueta>::
	un 'nombre' valido de etiqueta (ej. una referencia `refs/tags/<etiqueta>`).

<head>::
	un 'nombre' valido de cabeza (ej. una referencia `refs/heads/<cabeza>`).

Para una lista completa de las maneras de deletrear nombres de objetos ver la sección "ESPECIFICANDO REVISIONES" en linkgit:gitrevisions[7].


Estructura de Ficheros/Directorios
----------------------------------

Por favor ver el documento linkgit:gitrepository-layout[5].

Leer linkgit:githooks[5] para mas detalles sobre cada gancho.

Gestores de Código Fuente de alto nivel pueden proveer y manejar información adicional en el `$GIT_DIR`.


Terminología
------------
Favor de ver linkgit:gitglossary[7].


Variables de Ambiente
---------------------
Varios comandos de Git prestan atención a variables de ambiente y alteran su funcionamiento. Las variables de ambiente marcadas como "Booleanas" toman sus valores de la misma manera que variables de configuración booleanas, ej. "true", "yes", "on" y números positivos se consideran como "yes".

Aquí las variables:

El Repositorio Git
~~~~~~~~~~~~~~~~~~
Esas variables de ambiente aplican a 'todos' los comandos de núcleo de Git. Nótese bien: cabe notar que pueden ser usadas/sobremontadas por Gestores de Código Fuente asentados sobre Git, entonces tener cuidado si se usa un front-end foráneo.

`GIT_INDEX_FILE`::
	Esta variable de ambiente especifica un fichero de índice alterno. Si no se especifica, se usa el valor predeterminado en `$GIT_DIR/index`.

`GIT_INDEX_VERSION`::
	Esta variable de ambiente especifica qué versión de índice se usa al escribir el fichero de índice. No afectará ficheros de índice existentes. De manera predeterminada se usa la versión 2 o 3 del fichero de índice. Ver linkgit:git-update-index[1] para mas información.

`GIT_OBJECT_DIRECTORY`::
	Si el directorio de almacenamiento de objetos se especifica por medio de esta variable de ambiente, entonces los directorios sha1 se crean debajo - de lo contrario se usa el directorio predeterminado `$GIT_DIR/objects`.

`GIT_ALTERNATE_OBJECT_DIRECTORIES`::
	Debido a la naturaleza inmutable de los objetos Git, objetos antiguos pueden ser archivados en directorios compartidos de sólo lectura. Esta variable especifica una lista separada por ":" (en Windows separada por ";") de directorios de objetos Git que pueden ser usados para buscar objetos Git. Objetos nuevos no serán escritos en esos directorios.
+
Entradas que comienzan con `"` (comilla doble) serán interpretadas como rutas entrecomilladas estilo C, quitando la comillas dobles iniciales y finales y respetando escapes de diagonal invertida. Ej. el valor `"ruta-con-\"-y-:-en-ella":ruta-vainilla` tiene dos rutas: `ruta-con-"-y-:-en-ella` y `ruta-vainilla`.

`GIT_DIR`::
	Si la variable de ambiente `GIT_DIR` esta asignada entonces especifica una ruta para usarse en lugar de la predeterminada `.git` para la base del repositorio. La opción de línea de comando `--git-dir` también asigna éste valor.

`GIT_WORK_TREE`::
	Asigna la ruta de la raíz del árbol de trabajo. También puede controlarse con la opción de línea de comando `--work-tree` y la variable de configuración core.worktree.

`GIT_NAMESPACE`::
	Asigna el espacio de nombres de Git; ver linkgit:gitnamespaces[7] para detalles. La opción de línea de comandos `--namespace` también asigna éste valor.

`GIT_CEILING_DIRECTORIES`::
	Esta debe ser una lista separada por dos puntos de rutas absolutas. Si se asigna, es una lista de directorios en los que Git no debería hacer chdir al buscar un directorio de repositorio (útil para excluir directorios de red de carga lenta). No excluirá el directorio de trabajo actual o un GIT_DIR configurado en línea de comandos o en el ambiente. Normalmente, Git tiene que leer las entradas en esta lista y resolver cualquier enlace simbólico que pueda estar presente con el fin de compararlos con el directorio actual. Sin embargo, si incluso éste acceso es lento, puedes agregar a la lista una entrada vacía para indicarle a Git que las entradas subsecuentes no son enlaces simbólicos y que por lo tanto no necesitan resolverse; ej. `GIT_CEILING_DIRECTORIES=/posible/enlace::/no/enlace/muy/lento`.

`GIT_DISCOVERY_ACROSS_FILESYSTEM`::
	Cuando se ejecuta en un directorio que no tiene directorio de repositorio ".git", Git intenta encontrarlo en los directorios padres para encontrar el tope del directorio de trabajo, pero predeterminadamente no cruza los límites del sistema de ficheros. A esta variable de ambiente booleana se le puede asignar true para indicarle a Git que no pare en los límites del sistema operativo. Así como `GIT_CEILING_DIRECTORIES`, no afectará un directorio de repositorio explícito configurado en `GIT_DIR`o en la línea de comandos.

`GIT_COMMON_DIR`::
	Si a esta variable se le asigna una ruta, los ficheros que no son del árbol de trabajo que normalmente están en $GIT_DIR serán tomados en cambio de esta ruta. Ficheros específicos del árbol de trabajo como HEAD y index se toman de $GIT_DIR. Ver linkgit:gitrepository-layout[5] y linkgit:git-worktree[1] para detalles. Esta variable tiene precedencia mas baja que otras variables de ruta como GIT_INDEX_FILE, GIT_OBJECT_DITECTORY...

`GIT_DEFAULT_HASH`::
	Si se configura esta variable, el algoritmo predeterminado de hash para repositorios nuevos será asignado con éste valor. Al clonar se ignora este valor y siempre se usa la configuración del repositorio remoto. El predeterminado es "sha1". ESTA VARIABLE ES EXPERIMENTAL! Ver `--object-format` en linkgit:git-init[1].

Commits de Git
~~~~~~~~~~~~~~
`GIT_AUTHOR_NAME`::
	El nombre legible al humano usado en la identidad del autor cuando se crean objetos commit o etiqueta, o cuando se escriben reflogs. Sobreescribe las configuraciones `user.name` y `author.name`.

`GIT_AUTHOR_EMAIL`::
	La dirección de correo electrónico usada en la identidad del autor cuando se crean objetos commit o etiquetas, o cuando se escriben reflogs. Anula las configuraciones `user.email` y `author.email`.

`GIT_AUTHOR_DATE`::
	La fecha usada para la identidad del autor cuando se crean objetos commit o etiqueta, o cuando se escriben reflogs. Ver linkgit:git-commit[1] para formatos válidos.

`GIT_COMMITTER_NAME`::
	The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.name` and `committer.name` configuration settings.

`GIT_COMMITTER_EMAIL`::
	The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.email` and `committer.email` configuration settings.

`GIT_COMMITTER_DATE`::
	The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See linkgit:git-commit[1] for valid formats.

`EMAIL`::
	The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set.

Diffs de Git
~~~~~~~~~~~~
`GIT_DIFF_OPTS`::
	La única configuración válida es "--unified=??" o "-u??" para asignar el número de líneas de contexto a mostrarse cuando se crea un diff unificado. Toma precedencia sobre cualquier valor de opción "-U" o "--unified" pasada en la línea de comandos del diff Git.

`GIT_EXTERNAL_DIFF`::
	Cuando se asigna la variable de ambiente `GIT_EXTERNAL_DIFF`, se llama al programa nombrado en ella para generar diffs, y Git no usa su maquinaria de diff interconstruida. Para una ruta que es agregada, removida, o modificada, se llama a `GIT_EXTERNAL_DIFF` con 7 parámetros:

	ruta fichero-anterior hex-anterior modo-anterior fichero-nuevo hex-nuevo modo-nuevo
+
donde:

	<anterior|nuevo>-fichero:: son los ficheros que GIT_EXTERNAL_DIFF puede usar para leer el contenido de <anterior|nuevo>,
	<anterior|nuevo>-hex:: 	son los hash SHA1 de 40 dígitos hexadecimal,
	<anterior|nuevo>-modo:: 	son la representación octal de los modos del fichero.
+
Los parámetros fichero pueden apuntar al fichero de trabajo del usuario (ej. `fichero-nuevo` en "git-diff-files"), `/dev/null`(ej. `fichero-anterior` cuando se agrega un fichero nuevo), o un fichero temporal (ej. `fichero-anterior` en el índice). `GIT_EXTERNAL_DIFF` no debería preocuparse por desenlazar el fichero temporal -- es eliminado cuando `GIT_EXTERNAL_DIFF` sale.
+
Para una ruta no-fusionada, se llama a `GIT_EXTERNAL_DIFF` con 1 parámetro, <ruta>.
+
Para cada ruta se llama a `GIT_EXTERNAL_DIFF`, dos variables de ambiente se asignan, `GIT_DIFF_PATH_COUNTER` y `GIT_DIFF_PATH_TOTAL`.

`GIT_DIFF_PATH_COUNTER`::
	Un contador base 1 incrementado por uno por cada ruta.

`GIT_DIFF_PATH_TOTAL`::
	El número total de rutas.

otras
~~~~~
`GIT_MERGE_VERBOSITY`::
	Un número controlando la cantidad de salida mostrada por la estrategia de fusión recursiva. Anula merge.verbosity. Ver linkgit:git-merge[1]

`GIT_PAGER`::
	Esta variable de ambiente anula `$PAGER`. Si se le asigna una cadena vacía o el valor "cat", Git no lanzará un paginador. Ver también la opción `core.pager` en linkgit:git-config[1].

`GIT_PROGRESS_DELAY`::
	Un número controlando cuántos segundos retardar antes de mostrar indicadores opcionales de progreso. Predeterminado a 2.

`GIT_EDITOR`::
	Esta variable de ambiente anula `$EDITOR` y `$VISUAL`. Es usada por varios comandos Git cuando en modo interactivo se va a lanzar un editor. Ver también linkgit:git-var[1] y la opción `core.editor` en linkgit:git-config[1].

`GIT_SEQUENCE_EDITOR`::
	Esta variable de ambiente anula el editor de Git configurado cuando se edita la lista de pendientes en un rebase interactivo. Ver también linkgit:git-rebase[1] y la opción `sequence.editor` en linkgit:git-config[1].

`GIT_SSH`::
`GIT_SSH_COMMAND`::
	Si cualquiera de estas variables de ambiente se asigna entonces 'git fetch' y 'git push' usarán el comando especificado en lugar de 'ssh' cuando se necesite conectar a un sistema remoto. Los parámetros de línea de comandos pasados al comando configurado los determina la variante de ssh. Ver la opción `ssh.variant` en linkgit:git-config[1] para detalles.
+
`$GIT_SSH_COMMAND` toma precedencia sobre `$GIT_SSH`, y es interpretado por el shell, el cual permite argumentos adicionales a incluirse. Por otro lado, `$GIT_SSH` debe ser sólo la ruta al programa (el cual puede ser un script de shell envolvente, si se necesitan argumentos adicionales).
+
Usualmente es mas fácil configurar cualquier opción deseada por medio de tu fichero personal `.ssh/config`. Por favor consulta tu documentación de ssh para mayores detalles.

`GIT_SSH_VARIANT`::
	Si se asigna ésta variable de ambiente, anula que Git autodetecte si `GIT_SSH`/`GIT_SSH_COMMAND`/`core.sshCommand` se refiere a OpenSSH, link o tortoiseplink. Esta variable anula la configuración `ssh.variant` que sirve para el mismo propósito.

`GIT_SSL_NO_VERIFY`::
	Asignando y exportando ésta variable de ambiente a cualquier valor le dice a Git que no verifique el certificado SSL cuando haga fetch o push sobre HTTPS.

`GIT_ASKPASS`::
	Si se asigna esta variable de ambiente, entonces los comandos Git que necesiten recibir contraseñas o frases de acceso (ej. para autenticación HTTP o IMAP) llamarán a éste programa con una línea de entrada apropiada como argumento de línea de comandos y leer la contraseña de su STDOUT. Ver también la opción `core.askPass` en linkgit:git-config[1].

`GIT_TERMINAL_PROMPT`::
	Si se asigna ésta variable de ambiente booleana, git no usará una línea de entrada en la terminal (ej. cuando se solicite una autenticación HTTP).

`GIT_CONFIG_GLOBAL`::
`GIT_CONFIG_SYSTEM`::
	Toma la configuración de los ficheros dados en lugar de los ficheros de configuración global o a nivel sistema. Si `GIT_CONFIG_SYSTEM` es asignado, el fichero de configuración de sistema definido en tiempo de construcción (usualmente `/etc/gitconfig`) no será leído. En el mismo sentido, si `GIT_CONFIG_GLOBAL` es asignado, ninguno de `$HOME/.gitconfig` o `$XDG_CONFIG_HOME/git/config`será leído. Se le puede asignar `/dev/null` para saltar la lectura de ficheros de configuración del nivel respectivo.

`GIT_CONFIG_NOSYSTEM`::
	Si saltar la lectura de ajustes del fichero de ámbito de sistema `$(prefijo)/etc/gitconfig`. Esta variable de ambiente booleana puede ser usada junto con `$HOME` y `$XDG_CONFIG_HOME` para crear un ambiente predecible para un script quisquilloso, o puedes asignarle verdadero para evitar temporalmente usar un fichero defectuoso `/etc/gitconfig` mientras se espera a alguien con premisos suficientes para arreglarlo.

`GIT_FLUSH`::
// NEEDSWORK: make it into a usual Boolean environment variable
	Si a esta variable de ambiente se le asigna "1", entonces comandos como
	'git-blame' (en modo incremental), 'git rev-list', 'git log',
	'git check-attar' y 'git check-ignore' forzarán un desalojo
	del flujo de salida después de que cada registro sea
	desalojado. Si a esta
	variable se le asigna "0", la salida de esos comandos se hará
	usando búfer de E/S por completo. Si no se asigna esta variable de ambiente,
	Git elegirá desalojo por búfer u orientada a registro
	con base en si la salida estándar parece ser redirigida a un fichero o no.

`GIT_TRACE`::
	Habilita mensajes de rastreo general, ej. expansión de alias, ejecución de comando interconstruido y ejecución de comando externo.
+
Si a esta variable se le asigna "1", "2" o "true" (comparación sensible a mayúsculas), mensajes de rastreo se imprimirán en stderr.
+
Si a esta variable se le asigna un valor entero mayor a 2 y menor a 10 (estrictamente) entonces Git interpretará éste valor como un descriptor de fichero abierto e intentará escribir mensajes de rastro en éste descriptor de fichero.
+
Alternativamente, si a la variable se le asigna un ruta absoluta (iniciando con un caracter '/'), Git interpretará esta como una ruta de fichero e intentará adicionar mensajes de rastreo en él.
+
Desasignando la variable, o asignándole vacío, "0" o "false" (sensible a mayúsculas) deshabilita mensajes de rastreo.

`GIT_TRACE_FSMONITOR`::
	Habilita mensajes de rastreo para la extensión de monitoreo de sistema de ficheros. Ver `GIT_TRACE` para las opciones de salida de rastreo disponibles.

`GIT_TRACE_PACK_ACCESS`::
	Habilita mensajes de rastreo para todos los accesos a cualquier paquete. Para cada acceso, se registra el nombre de fichero de paquete y un corrimiento. Esto puede ser de ayuda para diagnosticar algunos problemas de desempeño relacionados con paquetes. Ver `GIT_TRACE` para opciones de rastreo disponibles.

`GIT_TRACE_PACKET`::
	Habilita mensajes de rastreo para todos los paquetes que vienen de o van hacia un programa dado. Esto puede ayudar con depuración de negociación de objetos u otros problemas de protocolo. El rastreo esta apagado en un paquete que comienza con "PACK" (pero ver `GIT_TRACE_PACKFILE` mas abajo). Ver `GIT_TRACE` para opciones de salida de rastreo disponibles.

`GIT_TRACE_PACKFILE`::
	Habilita el rastreo de fichero de paquete enviados o recibidos por un programa dado. Contrario a otras salidas de rastreo, este rastreo es verboso: sin encabezados, y sin entrecomillar datos binarios. Seguramente querrás dirigirla a un fichero (ej. `GIT_TRACE_PACKFILE=/tmp/mi.paquete`) mas que desplegarla en la terminal o mezclarla con otra salida de rastreo.
+
Note que esto esta actualmente implementado sólo para el lado del cliente de clonaciones y fetchs.

`GIT_TRACE_PERFORMANCE`::
	Habilita mensajes de rastreo relacionados con desempeño, ej. tiempo total de ejecución de cada comando Git. Ver `GIT_TRACE` para opciones de salida de rastreo disponibles.

`GIT_TRACE_REFS`::
	Habilita mensajes de rastreo para operaciones en la base de datos de referencias. Ver `GIT_TRACE` para opciones de salida de rastreo disponibles.

`GIT_TRACE_SETUP`::
	Habilita mensajes de rastreo imprimiendo el .git, el árbol de trabajo y el directorio de trabajo actual después que Git haya terminado su fase de configuración. Ver `GIT_TRACE` para opciones de salida de rastreo disponibles.

`GIT_TRACE_SHALLOW`::
	Habilita mensajes de rastreo que pueden ayudar a depurar fetch / clonación de repositorios superficiales. Ver `GIT_TRACE` para opciones de salida de rastreo disponibles.

`GIT_TRACE_CURL`::
	Habilita un volcado de rastreo completo de curl de todos los datos entrantes y salientes, incluyendo información descriptiva, del protocolo de transporte git. Es similar a hacer curl con `--trace-ascii` desde la línea de comandos. Ver `GIT_TRACE` para opciones de salida de rastreo disponibles.

`GIT_TRACE_CURL_NO_DATA`::
	Cuando se habilita un rastreo curl (ver `GIT_TRACE_CURL` arriba), no vuelca los datos (esto es, sólo vuelca líneas de información y cabeceras).

`GIT_TRACE2`::
	Habilita mensajes de rastreo mas detallados desde la librería "trace2". La salida de `GIT_TRACE2` es un formato simple basado en texto para legibilidad humana.
+
Si a esta variable se le asigna "1", "2" o "true" (comparación sensible a mayúsculas), mensajes de rastreo se imprimirán en stderr.
+
Si a esta variable se le asigna un valor entero mayor a 2 y menor a 10 (estrictamente) entonces Git interpretará éste valor como un descriptor de fichero abierto e intentará escribir mensajes de rastro en éste descriptor de fichero.
+
Alternativamente, si a la variable se le asigna una ruta absoluta (que comience con el caracter '/'), Git la interpretará como una ruta de fichero e intentará añadir mensajes de rastreo en él. Si la ruta ya existe y es un directorio, los mensajes de rastreo serán escritos en ficheros (uno por proceso) en ese directorio, nombrados de acuerdo al último componente del SID y un contador opcional (para evitar colisiones de nombre de fichero).
+
Además, si a la variable se le asigna `af_unix:[<tipo-de-socket>:]<nombre-de-ruta-absoluta>`, Git intentará abrir la ruta como un Socket de Dominio de Unix. El tipo de socket puede ser `stream` o `dgram`.
+
Desasignando la variable, o asignándole vacío, "0" o "false" (sensible a mayúsculas) deshabilita mensajes de rastreo.
+
Ver link:technical/api-trace2.html[documentación de Trace2] para detalles completos.


`GIT_TRACE2_EVENT`::
	Este ajuste escribe un formato basado en JSON que es adecuado para interpretación por máquina. Ver `GIT_TRACE2` para opciones disponibles de salida de rastreo y link:technical/api-trace2.html[documentación de Trace2] para detalles completos.

`GIT_TRACE2_PERF`::
	Además de los mensajes basados en texto disponibles en `GIT_TRACE2`, este ajuste escribe un formato basado en columnas para entender regiones anidadas. Ver `GIT_TRACE` para opciones de salida de rastreo disponibles y link:technical/api-trace2.html[documentación de Trace2] para detalles completos.

`GIT_TRACE_REDACT`::
	Predeterminadamente, cuando se activa rastreo, Git redacta los valores de cookies, el encabezado "Authorization", el encabezado "Proxy-Authorization:" y fichero empaquetado de URIs. Asigne false a esta variable de ambiente booleana para prevenir esta redacción.

`GIT_LITERAL_PATHSPECS`::
	Asignando verdadero a esta variable de ambiente booleana causará que Git trate a todas las especificaciones de ruta literalmente, mas que como patrones glob. Por ejemplo, corriendo `GIT_LITERAL_PATHSPECS=1 git log -- '*.c'` buscará confirmaciones que toquen la ruta `*.c`, no cualquier ruta que coincida con el glob `*.c`. Querrías esto si proporcionas rutas literales a Git (ej., rutas que te hayan resultado previamente de `git ls-tree`, `--raw` salida de diff, etc.).

`GIT_GLOB_PATHSPECS`::
	Asignando verdadero a esta variable de ambiente booleana causará que Git trate todas las especificaciones de ruta como patrones glob (también conocido como magia "glob").

`GIT_NOGLOB_PATHSPECS`::
	Asignando verdadero a esta variable de ambiente booleana causará que Git trate a todas la especificaciones de ruta como literales (también conocido como magia "literal").

`GIT_ICASE_PATHSPECS`::
	Asignando verdadero a esta variable de ambiente booleana causará que Git trate a todas las especificaciones de ruta como insensibles a mayúsculas.

`GIT_REFLOG_ACTION`::
	Cuando se actualiza una referencia, se crean entradas de reflog para dar seguimiento a la razón por la cual la referencia fue actualizada (la cual es típicamente el nombre de un comando de alto nivel que actualizó la referencia), además de los valores anterior y nuevo de la referencia. Un comando porcelana en un script puede usar la función auxiliar set_reflog_action en `git-sh-setup` para asignar su nombre a esta variable cuando es invocada por el usuario final como el comando de máximo nivel, para ser registrado en el cuerpo del reflog.

`GIT_REF_PARANOIA`::
	Si se asigna falso a esta variable de ambiente booleana, ignora referencias rotas o mal nombradas cuando se itera por la lista de referencias. Normalmente Git intentará incluir cualquiera de tales referencias, lo cual puede provocar que algunas operaciones fallen. Esto es usualmente preferible, ya que es mejor abortar operaciones potencialmente destructivas (ej. linkgit:git-prune[1]) en vez de ignorar referencias rotas (y por lo tanto considerar que no vale guardar el historial al que apuntan). El valor predeterminado es `1` (ej. ser paranoico en la detección y abortar todas las operaciones). Normalmente no deberías asignarle `0`, pero puede ser útil cuando se intenta salvar datos de un repositorio corrupto.

`GIT_ALLOW_PROTOCOL`::
	Si se le asigna una lista de protocolos separada por dos puntos, se comporta como si a `protocolo.allow` se le asigna `never`, y cada uno de los protocolos listados `protocol.<nombre>.allow` tuviera asignado `always` (anulando cualquier configuración existente). Ver la descripción de `protocol.allow` en linkgit:git-config[1] para mas detalles.

`GIT_PROTOCOL_FROM_USER`::
	Asigne falso a esta variable de ambiente booleana para prevenir el uso de protocolos por fetch/push/clone los cuales están configurados en el estado `user`. Esto es útil para restringir inicialización recursiva de submodulos desde un repositorio no confiable o para programas que alimenten URLs potencialmente no confiables a comandos git. Ver linkgit:git-config[1] para mas detalles.

`GIT_PROTOCOL`::
	Sólo para uso interno. Usado en el protocolo de estrechamiento de manos de conexión. Contiene una lista de claves separadas por dos puntos ':' con valores opcionales 'clave[=valor]'. La presencia de claves y valores desconocidos debe ser ignorada.
+
Note que servidores pueden necesitar ser configurados para permitir que esta variable sobrepase algunos transportes. Será propagada automáticamente cuando se accesen repositorios locales (ej. `file://` o una ruta del sistema de ficheros), así como sobre el protocolo `git://`. Para git-sobre-http, debería funcionar automáticamente en la mayoría de las configuraciones, pero ver la discusión en linkgit:git-http-backend[1]. Para git-sobre-ssh, el servidor ssh puede necesitar ser configurado para permitir a los clientes pasar esta variable (ej. usando `AcceptEnv GIT_PROTOCOL` con OpenSSH).
+
Esta configuración es opcional. Si la variable no es propagada, entonces los clientes caerán de vuelta a protocolo "v0" original (pero pueden perder algunas mejoras de desempeño o características). Esta variable afecta actualmente únicamente a clonados y fetchs; aún no es usada para empujes (pero podría serlo en el futuro).

`GIT_OPTIONAL_LOCKS`::
	Si se le asigna falso a esta variable de ambiente, Git completará cualquier petición solicitada sin hacer cualquier sub-operación opcional que requiera un bloqueo. Por ejemplo, prevendrá que `git status` refresque el índice como efecto colateral. Esto es útil para procesos corriendo en segundo plano que no quieran provocar contención de bloqueos con otras operaciones en el repositorio. Es predeterminada a `1`.

`GIT_REDIRECT_STDIN`::
`GIT_REDIRECT_STDOUT`::
`GIT_REDIRECT_STDERR`::
	Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via `CreateProcess()` is not an option because it would require the handles to be marked inheritable (and consequently *every* spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. `\\.\pipe\my-git-stdin-123`).
+
Two special values are supported: `off` will simply close the corresponding standard handle, and if `GIT_REDIRECT_STDERR` is `2>&1`, standard error will be redirected to the same handle as standard output.

`GIT_PRINT_SHA1_ELLIPSIS` (deprecated)::
	If set to `yes`, print an ellipsis following an (abbreviated) SHA-1 value. This affects indications of detached HEADs (linkgit:git-checkout[1]) and the raw diff output (linkgit:git-diff[1]). Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable).

Discussion[[Discussion]]
------------------------

More detail on the following is available from the link:user-manual.html#git-concepts[Git concepts chapter of the user-manual] and linkgit:gitcore-tutorial[7].

A Git project normally consists of a working directory with a ".git" subdirectory at the top level. The .git directory contains, among other things, a compressed object database representing the complete history of the project, an "index" file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads.

The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.

The commit, equivalent to what other systems call a "changeset" or "version", represents a step in the project's history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development.

All objects are named by the SHA-1 hash of their contents, normally written as a string of 40 hex digits. Such names are globally unique. The entire history leading up to a commit can be vouched for by signing just that commit. A fourth object type, the tag, is provided for this purpose.

When first created, objects are stored in individual files, but for efficiency may later be compressed together into "pack files".

Named pointers called refs mark interesting points in history. A ref may contain the SHA-1 name of an object or the name of another ref. Refs with names beginning `ref/head/` contain the SHA-1 name of the most recent commit (or "head") of a branch under development. SHA-1 names of tags of interest are stored under `ref/tags/`. A special ref named `HEAD` contains the name of the currently checked-out branch.

The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.

The index is also capable of storing multiple entries (called "stages") for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.

FURTHER DOCUMENTATION
---------------------

See the references in the "description" section to get started using Git. The following is probably more detail than necessary for a first-time user.

The link:user-manual.html#git-concepts[Git concepts chapter of the user-manual] and linkgit:gitcore-tutorial[7] both provide introductions to the underlying Git architecture.

See linkgit:gitworkflows[7] for an overview of recommended workflows.

See also the link:howto-index.html[howto] documents for some useful examples.

The internals are documented in the link:technical/api-index.html[Git API documentation].

Users migrating from CVS may also want to read linkgit:gitcvs-migration[7].


Authors
-------
Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list <git@vger.kernel.org>. http://www.openhub.net/p/git/contributors/summary gives you a more complete list of contributors.

If you have a clone of git.git itself, the output of linkgit:git-shortlog[1] and linkgit:git-blame[1] can show you the authors for specific parts of the project.

Reporting Bugs
--------------

Report bugs to the Git mailing list <git@vger.kernel.org> where the development and maintenance is primarily done. You do not have to be subscribed to the list to send a message there. See the list archive at https://lore.kernel.org/git for previous bug reports and other discussions.

Issues which are security relevant should be disclosed privately to the Git Security mailing list <git-security@googlegroups.com>.

VER TAMBIÉN
-----------
linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:giteveryday[7], linkgit:gitcvs-migration[7], linkgit:gitglossary[7], linkgit:gitcore-tutorial[7], linkgit:gitcli[7], link:user-manual.html[The Git User's Manual], linkgit:gitworkflows[7]

GIT
---
Parte de la suite de linkgit:git[1]
