git-restore(1)
==============

NOMBRE
------
git-restore - Restaura ficheros del árbol de trabajo

SINOPSIS
--------
[synopsis]
git restore [<opciones>] [--source=<árbol>] [--staged] [--worktree] [--] <especificación-de-ruta>...
git restore [<opciones>] [--source=<árbol>] [--staged] [--worktree] --pathspec-from-file=<fichero> [--pathspec-file-nul]
git restore (-p|--patch) [<opciones>] [--source=<árbol>] [--staged] [--worktree] [--] [<especificación-de-ruta>...]

DESCRIPCIÓN
-----------
Restaura las rutas especificadas en el árbol de trabajo con algún contenido de una fuente de restauración. Si una ruta es rastreada pero no existe en la fuente de restauración será eliminada para coincidir con la fuente.

El comando tambien puede usarse para restaurar el contenido en el índice con `--staged`, o restaurar tanto el árbol de trabajo como el índice con `--staged --worktree`.

Predeterminadamente, si se da `--staged`, el contenido es restaurado desde `HEAD`, de lo contrario desde el índice. Use `--source` para restaurar desde una confirmación diferente.

Ver "Restablecer, restaurar y revertir" en linkgit:git[1] para diferenciar los tres comandos.

OPCIONES
--------
`-s <árbol>`::
`--source=<árbol-ismo>`::
	Restaura los ficheros del árbol de trabajo con el contenido de un árbol dado. Es normal especificar el árbol fuente por su nombre de confirmación, rama o etiqueta asociada.
+
Si no se especifica, el contenido es restaurado desde `HEAD` si se proporciona `--staged`, de lo contrario desde el índice.
+
Como un caso especial, puedes usar `"<revisión-A>...<revisión-B>"` como un atajo para la base de fusión de _<revisión-A>_ y <revisión-B>_ si hay exactamente una base de fusión. Puedes dejar fuera a lo mucho una de _<revisión-A> y _<revisión-B>_, en cuyo caso se predetermina a `HEAD`.

`-p`::
`--patch`::
	Selecciona pedazos interactivamente en la diferencia entre la fuente y la ubicación de restauración. Ver la sección "Modo Interactivo" de linkgit:git-add[1] para aprender cómo operar el modo `--patch`.

include::diff-context-options.adoc[]

`-W`::
`--worktree`::
`-S`::
`--staged`::
	Especifica la ubicación de restauración. Si no se especifica ninguna opción, se restaura predeterminadamente el árbol de trabajo. Especificando `--staged` solo restaura el índice. Especificando ambos restaura ambos.

`-q`::
`--quiet`::
	Suprime silenciosamente los mensajes de retroalimentación. Implica `--no-progress`.

`--progress`::
`--no-progress`::
	El estado de progreso es reportado al flujo de error estándar predeterminadamente cuando esta vinculado a una terminal, a menos que se especifique `--quiet`. Esta bandera habilita el reporte de progreso incluso si no esta vinculado a una terminal, independientemente de `--quiet`.

`--ours`::
`--theirs`::
	Cuando se restauran ficheros en el árbol de trabajo desde el índice, usa escenario #2 (`ours`) o #3 (`theirs`) para rutas sin fusionar. Esta opción no puede usarse cuando se revisan rutas de un árbol-ismo (es decir, con la opción `--source`).
+
Nota que durante `git rebase` y `git pull --rebase`, `ours` y `theirs` pueden aparecer intercambiados. Ver la explicación de las mismas opciones en linkgit:git-checkout[1] para detalles.

`-m`::
`--merge`::
	Cuando se restauran ficheros en el árbol de trabajo desde el índice, recrea la fusión en conflicto en las rutas sin fusionar. Esta opción no puede usarse cuando se revisan rutas de un árbol-ismo. (es decir, con la opción `--source`).

`--conflict=<estilo>`::
	Igual que la opción `--merge` arriba, pero cambia la forma en que se presentan los pedazos en conflicto, anulando la variable de configuración `merge.conflictStyle`. Los valores posibles son `merge` (predeterminado), `diff3`, y `zdiff3`.

`--ignore-unmerged`::
	Cuando se restauran ficheros en el árbol de trabajo desde el índice, no aborta la operación si hay entradas sin fusionar y no se ha especificado ninguna de `--ours`, `--theirs`, `--merge` o `--conflict`. Las rutas sin fusionar en el árbol de trabajo se dejan solas.

`--ignore-skip-worktree-bits`::
	En modo checkout escaso, lo predeterminado es solo actualizar las entradas que coincidan con _<especificación-de-ruta>_ y los patrones de escasez en `$GIT_DIR/info/sparse-checkout`. Esta opción ignora los patrones de escasez y restaura incondicionalmente cualquier fichero en _<especificación-de-ruta>_.

`--recurse-submodules`::
`--no-recurse-submodules`::
	Si _<especifiación-de-ruta>_ incluye un submódulo activo y la ubicación de restauración incluye el árbol de trabajo, el submódulo se actualizará solo si se da esta opción, en cuyo caso su árbol de trabajo será restaurado a la confirmación registrada en el superproyecto, y cualquier modificación local será sobreescrita. Si no se usa nada (o `--no-recurse-submodules`) los árboles de trabajo de los submódulos no serán actualizados. Tal y como linkgit:git-checkout[1], esto separará `HEAD` del submódulo.

`--overlay`::
`--no-overlay`::
	En modo overlay, nunca elimina ficheros al restaurar. En modo no-overlay, elimina ficheros rastreados que no aparezcan en el _<árbol>_ de `--source=<árbol>`, para hacerlos coincidir exactamente con _<árbol>_. El predeterminado es modo no-overlay.

`--pathspec-from-file=<fichero>`::
	La especificación de ruta se pasa en `_<fichero>_` y no como argumento en la línea de comandos. Si `_<fichero>_` es exactamente `-` entonces se usa la entrada estándar. Los elementos de la especificación de ruta se separan por _LF_ o _CR_/_LF_. Los elementos de la especificación de ruta pueden ser entrecomillados como se explica para la variable de configuración `core.quotePath` (ver linkgit:git-config[1]). Ver también `--pathspec-file-nul` y `--literal-pathspecs` global.

`--pathspec-file-nul`::
	Sólo significativo con `--pathspec-from-file`. Los elementos de la especificación de ruta se separan con el caracter _NUL_ y todos los otros caracteres se toman literalmente (incluyendo saltos de línea y entrecomillados).

`--`::
	No interpreta ningún argumento mas como opciones.

`<especificación-de-ruta>...`::
	Limita las rutas afectadas por la operación.
+
Para mas detalles, ver 'pathspec' en linkgit:gitglossary[7].

EJEMPLOS
--------

La secuencia siguiente cambia a la rama `master`, revierte `Makefile` dos versiones atrás, elimina `hello.c` por error, y lo obtiene de vuelta desde el índice.

------------
$ git switch master
$ git restore --source master~2 Makefile  <1>
$ rm -f hello.c
$ git restore hello.c                     <2>
------------

<1> saca un fichero de otra confirmación
<2> restaura `hola.c` desde el índice

Si quieres restablecer _todos_ los ficheros de código C para que coincidan con la versión en el índice, puedes hacer

------------
$ git restore '*.c'
------------

Observa las comillas que rodean a `*.c`. El fichero `hello.c` también será restaurado, incluso si ya no esta en el árbol de trabajo, porque se usa glob para encontrar las entradas en el índice (mas no en el árbol de trabajo donde esta situado el intérprete de comandos).

Para restaurar todos los ficheros en el directorio actual

------------
$ git restore .
------------

o para restaurar todos los ficheros del árbol de trabajo con las especificación de ruta mágica 'top' (ver linkgit:gitglossary[7])

------------
$ git restore :/
------------

Para restaurar un fichero en el índice para que coincida con la versión en `HEAD`(lo mismo que usar linkgit:git-reset[1])

------------
$ git restore --staged hello.c
------------

o puedes restaurar ambos, el índice y el árbol de trabajo (esto es lo mismo que usar linkgit:git-checkout[1])

------------
$ git restore --source=HEAD --staged --worktree hello.c
------------

o la forma corta, la cual es más práctica pero menos legible:

------------
$ git restore -s@ -SW hello.c
------------

VER TAMBIÉN
-----------
linkgit:git-checkout[1], linkgit:git-reset[1]

GIT
---
Parte de la suite de linkgit:git[1]
