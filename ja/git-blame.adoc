git-blame(1)
============

NAME
----
git-blame - ファイルの各行を最後に変更したリビジョンと著者を表示する

概要
--
[verse]
'git blame' [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]
	    [-L <range>] [-S <revs-file>] [-M] [-C] [-C] [-C] [--since=<date>]
	    [--ignore-rev <rev>] [--ignore-revs-file <file>]
	    [--color-lines] [--color-by-age] [--progress] [--abbrev=<n>]
	    [ --contents <file> ] [<rev> | --reverse <rev>..<rev>] [--] <file>

説明
--

指定したファイルの各行に、その行を最後に変更したリビジョンの情報を付加します。必要に応じて、指定したリビジョンから注釈を開始することもできます。

`-L` を1回以上指定すると、注釈を付ける範囲を指定した行に限定できます。

行の由来は、ファイル全体のリネームをまたいで自動的に追跡されます（現時点ではリネーム追跡を無効にするオプションはありません）。他のファイルから移動された行や、コピー＆ペーストされた行なども追跡したい場合は、`-C` および `-M` オプションを参照してください。

このレポートでは、削除または置換された行については何も表示されません。そのような行を調べるには、'git diff' や、次の段落で簡単に触れる「pickaxe」インターフェースなどのツールを利用してください。

ファイルへの注釈付け（blame）機能に加えて、Git にはコード片がどの変更で現れたかを履歴から検索する機能もあります。これにより、コード片がファイルに追加された時期や、ファイル間で移動・コピーされ、最終的に削除または置換された時期を追跡できます。これは差分（diff）内の文字列を検索することで実現しています。`blame_usage` を検索する pickaxe インターフェースの簡単な例を以下に示します:

-----------------------------------------------------------------------------
$ git log --pretty=oneline -S'blame_usage'
5040f17eba15504bad66b14a645bddd9b015ebb7 blame -S <ancestry-file>
ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git-blame: Make the output
-----------------------------------------------------------------------------

オプション
-----
include::blame-options.adoc[]

-c::
	linkgit:git-annotate[1] と同じ出力モードを使用します（デフォルト: 無効）。

--score-debug::
	ファイル間で行が移動した場合（`-C`参照）や、ファイル内で行が移動した場合（`-M`参照）に関するデバッグ情報を含めます。最初に表示される数値はスコアであり、これはファイル間またはファイル内で移動したと判定された英数字の文字数です。この値が一定の閾値を超えた場合にのみ、'git blame' はその行を移動したものとみなします。

-f::
--show-name::
	元のコミットでのファイル名を表示します。デフォルトでは、リネーム検出により異なるファイル名から来た行がある場合のみファイル名が表示されます。

-n::
--show-number::
	元のコミットでの行番号を表示します（デフォルト: 無効）。

-s::
	出力から著者名とタイムスタンプを省略します。

-e::
--show-email::
	作者名の代わりにメールアドレスを表示します（デフォルトは無効）。この設定は `blame.showEmail` オプションでも制御できます。

-w::
	親のバージョンと子のバージョンを比較して行の由来を特定する際、空白の違いを無視します。

--abbrev=<n>::
	省略名としてデフォルトの7+1桁の16進数ではなく、<m>+1桁を使用します。ここで <m> は少なくとも <n> 以上で、コミットオブジェクト名が一意になるようにします。なお、境界コミットを示すキャレット用に1桁分が使われます。


デフォルトフォーマット
-----------

`--porcelain` または `--incremental` オプションが指定されていない場合、`git blame` は各行について以下の情報を注釈として出力します:

- その行が属するコミットの省略オブジェクト名;
- 著者識別情報（デフォルトでは著者名と日付。ただし `-s` または `-e` が指定された場合は異なります）；および
- 行番号

その行の内容の前に表示されます。

PORCELAIN フォーマット
----------------

このフォーマットでは、各行はヘッダーの後に出力されます。ヘッダーには最低限、次の情報を含む最初の行があります:

- その行が属するコミットの40バイトSHA-1ハッシュ値;
- 元のファイルでのその行の行番号;
- 最終ファイルでのその行の行番号;
- 前のコミットとは異なるコミットからの行グループを開始する行では、そのグループ内の行数。続く行ではこのフィールドは省略されます。

このヘッダー行に続いて、各コミットについて少なくとも1回は以下の情報が表示されます:

- 著者名（"author"）、メールアドレス（"author-mail"）、時刻（"author-time"）、タイムゾーン（"author-tz"）が出力されます。コミッターについても同様です。
- その行が属するコミットでのファイル名。
- コミットログメッセージの最初の行（"summary"）。

実際の行の内容は、上記ヘッダーの後にタブで区切って出力されます。これは将来的にヘッダー要素を追加できるようにするためです。

The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. Information which is specific to individual lines will not be grouped together, like revs to be marked 'ignored' or 'unblamable'. This is more efficient, but may require more state be kept by the reader. The `--line-porcelain` option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:

	# 各著者に帰属する行数をカウントする例
	git blame --line-porcelain file |
	sed -n 's/^author //p' |
	sort | uniq -c | sort -rn


範囲の指定
-----

古いバージョンの 'git blame' や 'git annotate' と異なり、注釈の範囲は行範囲・リビジョン範囲の両方で制限できます。行範囲を制限する `-L` オプションは複数回指定可能です。

ファイル `foo` の40～60行目の由来を調べたい場合、`-L` オプションを次のように使えます（どちらも40行目から21行分を指定する意味です）:

	git blame -L 40,60 foo
	git blame -L 40,+21 foo

また、正規表現を使って行範囲を指定することもできます:

	git blame -L '/^sub hello {/,/^}$/' foo

`hello` サブルーチン本体だけに注釈を限定します。

バージョン v2.6.18 より古い変更や、3週間より前の変更に興味がない場合は、'git rev-list' と同様のリビジョン範囲指定子を使うことができます:

	git blame v2.6.18.. -- foo
	git blame --since=3.weeks -- foo

リビジョン範囲指定子で注釈範囲を制限した場合、その範囲境界（上記例では v2.6.18 のコミットや3週間以上前の最新コミット）以降に変更されていない行は、その境界コミットに帰属します。

特に便利な使い方として、追加されたファイルに既存ファイルからコピー＆ペーストされた行があるかどうかを調べる方法があります。これは、開発者がリファクタリングを怠ったことを示している場合もあります。まず、そのファイルを導入したコミットを次のようにして特定します:

	git log --diff-filter=A --pretty=short -- foo

そして、そのコミットと親コミットの差分に対して `commit^!` 記法を使って注釈を付けます:

	git blame -C -C -f $commit^! -- foo


インクリメンタル出力
----------

`--incremental` オプションを付けて実行すると、コマンドは結果を生成しながら順次出力します。この出力は、より新しいコミットで変更された行から順に（つまり順不同で）注釈が付けられるのが一般的で、対話的なビューア向けの形式です。

出力フォーマットはPorcelainフォーマットに似ていますが、注釈対象ファイルの実際の行内容は含まれません。

. 各blameエントリは必ず次の形式の行から始まります:

	<40バイトの16進SHA1> <元の行番号> <結果の行番号> <行数>
+
行番号は1から始まります。

. ストリーム内でコミットが初めて現れるとき、そのコミットに関するさまざまな追加情報（著者、メールアドレス、コミッター、日付、サマリーなど）が、各行の先頭に1語のタグを付けて出力されます。

. Porcelainフォーマットとは異なり、ファイル名情報は常に出力され、エントリの終端となります:

	"filename" <ここに空白で囲まれたファイル名が入る>
+
そのため、行指向・単語指向のパーサー（多くのスクリプト言語で自然に扱えるもの）で非常に簡単に解析できます。
+
[NOTE]
パース処理を行う方へ: より堅牢にするには、最初と最後（「<sha1>」行と「filename」行）の間にある「拡張情報」行で、先頭のタグ単語が分からない（または必要ない）行は無視してください。そうすれば、将来コミットのエンコーディングや拡張コメントなどの情報が追加されても、blameビューアは問題なく動作します。


MAPPING AUTHORS
---------------

linkgit:gitmailmap[5] を参照。

設定
--

include::includes/cmd-config-section-all.adoc[]

include::config/blame.adoc[]

関連項目
----
linkgit:git-annotate[1]

GIT
---
Part of the linkgit:git[1] suite
