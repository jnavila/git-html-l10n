git-push(1)
===========

NOME
----
git-push - Atualiza as refs remotas junto com os objetos associados a ela


RESUMO
------
[verse]
'git push' [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
	   [--repo=<repositório>] [-f | --force] [-d | --delete] [--prune] [-q | --quiet] [-v | --verbose]
	   [-u | --set-upstream] [-o <texto> | --push-option=<texto>]
	   [--[no-]signed|--signed=(true|false|if-asked)]
	   [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]
	   [--no-verify] [<repositório> [<refspec>...]]

DESCRIÇÃO
---------

Updates one or more branches, tags, or other references in a remote repository from your local repository, and sends all necessary data that isn't already on the remote.

The simplest way to push is `git push <remote> <branch>`. `git push origin main` will push the local `main` branch to the `main` branch on the remote named `origin`.

The `<repository>` argument defaults to the upstream for the current branch, or `origin` if there's no configured upstream.

To decide which branches, tags, or other refs to push, Git uses (in order of precedence):

1. The `<refspec>` argument(s) (for example `main` in `git push origin main`) or the `--all`, `--mirror`, or `--tags` options
2. The `remote.*.push` configuration for the repository being pushed to
3. The `push.default` configuration. The default is `push.default=simple`, which will push to a branch with the same name as the current branch. See the <<CONFIGURATION,CONFIGURATION>> section below for more on `push.default`.

`git push` may fail if you haven't set an upstream for the current branch, depending on what `push.default` is set to. See the <<UPSTREAM-BRANCHES,UPSTREAM BRANCHES>> section below for more on how to set and use upstreams.

É possível fazer com que coisas interessantes aconteçam num repositório toda vez que você fizer um "push" nele, ao configurar "ganchos" nele. Consulte a documentação para linkgit:git-receive-pack[1].


OPÇÕES[[OPTIONS]]
-----------------
<repositório>::
	O repositório "remote" que é o destino de uma operação 'push'. Este parâmetro pode ser uma URL (consulte a seção <<URLS,GIT URLS>> abaixo) ou o nome de um controle remoto (consulte a seção <<REMOTES,RAMOS REMOTOS>> abaixo).

<refspec>...::
	Specify what destination ref to update with what source object.
+
The format for a refspec is [+]<src>[:<dst>], for example `main`, `main:other`, or `HEAD^:refs/heads/main`.
+
The `<src>` is often the name of the local branch to push, but it can be any arbitrary "SHA-1 expression" (see linkgit:gitrevisions[7]).
+
The `<dst>` determines what ref to update on the remote side. It must be the name of a branch, tag, or other ref, not an arbitrary expression.
+
The `+` is optional and does the same thing as `--force`.
+
You can write a refspec using the fully expanded form (for example `refs/heads/main:refs/heads/main`) which specifies the exact source and destination, or with a shorter form (for example `main` or `main:other`). Here are the rules for how refspecs are expanded, as well as various other special refspec forms:
+
 *  `<src>` without a `:<dst>` means to update the same ref as the `<src>`, unless the `remote.<repository>.push` configuration specifies a different <dst>. For example, if `main` is a branch, then the refspec `main` expands to `main:refs/heads/main`.
 *  If `<dst>` unambiguously refers to a ref on the <repository> remote, then expand it to that ref. For example, if `v1.0` is a tag on the remote, then `HEAD:v1.0` expands to `HEAD:refs/tags/v1.0`.
 *  If `<src>` resolves to a ref starting with `refs/heads/` or `refs/tags/`, then prepend that to <dst>. For example, if `main` is a branch, then `main:other` expands to `main:refs/heads/other`
 *  O refspec especial `:` (ou `+:` para permitir atualizações que não sejam de avanço rápido) direciona o Git a enviar ramificações "correspondentes": para cada ramificação que existe no lado local, o lado remoto é atualizado quando uma ramificação com o mesmo nome já existir no lado remoto.
 *  <src> may contain a * to indicate a simple pattern match. This works like a glob that matches any ref matching the pattern. There must be only one * in both the `<src>` and `<dst>`. It will map refs to the destination by replacing the * with the contents matched from the source. For example, `refs/heads/*:refs/heads/*` will push all branches.
 *  A refspec starting with `^` is a negative refspec. This specifies refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be pattern refspecs. They must only contain a `<src>`. Fully spelled out hex object names are also not supported. For example, `git push origin 'refs/heads/*' '^refs/heads/dev-*'` will push all branches except for those starting with `dev-`
 *  If `<src>` is empty, it deletes the `<dst>` ref from the remote repository. For example, `git push origin :dev` will delete the `dev` branch.
 *  `tag <tag>` expands to `refs/tags/<tag>:refs/tags/<tag>`.
	This is technically a special syntax for `git push` and not a refspec, since in `git push origin tag v1.0` the arguments `tag` and `v1.0` are separate.
 *  If the refspec can't be expanded unambiguously, error out with an error indicating what was tried, and depending on the `advice.pushUnqualifiedRefname` configuration (see linkgit:git-config[1]) suggest what refs/ namespace you may have wanted to push to.

Not all updates are allowed: see PUSH RULES below for the details.

--all::
--branches::
	impulsione todos os ramos (ou seja, refs em `refs/heads/`); não pode ser utilizado com outro <refspec>.

--prune::
	Remova as ramificações remotas que não têm uma contraparte local. Por exemplo, uma ramificação remota `tmp` será removida se uma ramificação local com o mesmo nome não existir mais. Isso também respeita os refspecs, por exemplo, o comando `git push --prune remote refs/heads/*:refs/tmp/*` garantiria que o remote `refs/tmp/foo` seria removido se `refs/heads/foo` não existisse.

--mirror::
	Em vez de nomear cada referência que será enviada, especifica que todas as refs em `refs/` (que inclui, mas não se limita a `refs/heads/`, `refs/remotes/` e `refs/tags/`) sejam espelhadas no repositório remoto. As refs locais recém-criadas serão enviadas para a extremidade remota, as refs atualizadas localmente serão atualizadas à força na extremidade remota e as refs excluídas serão removidas da extremidade remota. Esse é o padrão se a opção de configuração `remote.<remoto>.mirror` estiver definida.

-n::
--dry-run::
	Faça tudo, exceto realmente enviar as atualizações.

--porcelain::
	Produz resultados legíveis para máquina. A linha de status de saída para cada ref será separada por tabulação e enviada para stdout em vez de stderr. Os nomes simbólicos completos dos refs serão fornecidos.

-d::
--delete::
	Todas as refs listadas são excluídas do repositório remoto. É o mesmo que prefixar todos as refs com dois pontos.

--tags::
	Todas as refs no `refs/tags` são impulsionadas, além das "refspecs" que forem explicitamente listados na linha de comando.

--follow-tags::
	Envie todas as refs que seriam enviadas sem essa opção e também envie as etiquetas anotadas em `refs/tags` que estão faltando no controle remoto, mas que estão apontando para os commits que são acessíveis a partir das refs que estão sendo enviadas. Isso também pode ser definido na variável de configuração `push.followTags`. Para mais informações consulte `push.followTags` do comando linkgit:git-config[1].

--signed::
--no-signed::
--signed=(true|false|if-asked)::
	Assine com GPG a solicitação de envio para atualizar as referências no lado receptor, para permitir que ela seja verificada pelos ganchos ou para que seja registrada. Se for `false` ou `--no-signed`, não haverá tentativa de assinatura. Se for `true` ou `--signed`, o 'push' falhará se o servidor não suportar envios assinados. Se for definido como `if-asked`, assine, funciona apenas se o servidor suportar envios assinados. O envio também falhará se a chamada real para a opção `gpg --sign` falhar. Para mais detalhes sobre o recebimento consulte linkgit:git-receive-pack[1].

--atomic::
--no-atomic::
	Use uma transação atômica no lado remoto, caso esteja disponível. Todas as refs são atualizadas ou, em caso de erro, nenhuma será. Se o servidor não for compatível com envios atômicos, o envio falhará.

-o <opção>::
--push-option=<opção>::
	Transmite a string fornecida para o servidor, que a passa para o gancho de pré-recepção e pós-recepção. A atring fornecida não deve conter um caractere NUL ou LF. Quando várias `--push-option=<opção>` são usadas, todas elas são enviadas para o outro lado na ordem listada da linha de comando. Quando nenhuma `--push-option=<opção>` é usada na linha de comando, os valores na variável de configuração `push.pushOption` são usados em seu lugar.

--receive-pack=<git-receive-pack>::
--exec=<git-receive-pack>::
	O caminho para o programa 'git-receive-pack' no lado remoto. Às vezes, é útil durante um "push" ao enviar para um repositório remoto via ssh e você não tem o programa no diretório do $PATH predefinido.

--force-with-lease::
--no-force-with-lease::
--force-with-lease=<refname>::
--force-with-lease=<refname>:<expect>::
	Normalmente, o comando "git push" se recusa a atualizar uma "ref" remota que não seja um ancestral da "ref" local utilizada para substituí-la.
+
Esta opção substitui essa restrição se o valor atual da referência remota for o valor esperado. Caso contrário, o comando 'git push' falhará.
+
Imagine que você tenha que fazer o rebase o que já foi publicado. Você terá que contornar a regra "fazer avanço rápido" para substituir o histórico originalmente publicado pelo histórico refeito. Se outra pessoa construiu em cima do seu histórico original enquanto você está fazendo o rebase, o cume do ramo remoto pode avançar com o commit dela, e o push cego feito com `--force` fará com que o trabalho dela seja perdido.
+
Esta opção permite que você diga que vai esperar que o histórico que está sendo atualizando seja o que você reconstruiu com o "rebase" e vai querer substituir. Casi uma "ref" remota ainda aponte para um commit específico, você pode ter certeza que outras pessoas não fizeram nada com a "ref". É como fazer uma "concessão" na ref sem bloqueá-la diretamente, a "ref" remota será atualizada apenas caso a "concessão" ainda seja válida.
+
Somente a opção `--force-with-lease`, sem qualquer outra definição, protegerá todos as refs remotas que serão atualizadas, exigindo que o seu valor atual seja o mesmo que o ramo monitorado remotamente que temos para eles.
+
A opção `--force-with-lease=<refname>`, sem qualquer outro valor esperado, protegerá a "ref" que foi informado (sozinho), caso seja atualizado, exigindo que o seu valor atual seja o mesmo que o ramo monitorado remotamente que temos para isso.
+
`--force-with-lease=<refname>:<expect>` protegerá a ref mencionada (sozinha), se ela for atualizada, exigindo que o seu valor atual seja o mesmo que o valor especificado em `<expect>` (que pode ser diferente da ramificação rastreada remotamente que temos para referência de nome, ou nem mesmo precisamos ter essa ramificação rastreada remotamente quando esse formulário for usado). Se `<expect>` estiver vazio, então a referência mencionada ainda não deve existir.
+
Observe que todas as formas diferentes da opção `--force-with-lease=<refname>:<expect>` que define o valor atual esperado para a "ref" de forma explicita, ainda são experimentais e sua semântica pode mudar à medida que adquiramos mais experiência com este recurso.
+
A opção `--no-force-with-lease` cancelará todos os `--force-with-lease` anteriores na linha de comando.
+
Uma observação geral sobre a segurança: utilizar esta opção sem um valor esperado, por exemplo, `--force-with-lease` ou `--force-with-lease=<refname>` interage muito mal com qualquer coisa que execute de forma implícita o comando `git fetch` do ramo remoto que será encaminhado para um processo de segundo plano, como o comando `git fetch origin` no seu repositório para um trabalho agendado "cronjob" por exemplo.
+
A proteção oferecida contra a opção `--force` é garantir que as subsequentes alterações onde a base do seu trabalho não sejam prejudicadas, porém isso será derrotado trivialmente caso algum processo em segundo plano estiver atualizando as refs em segundo plano. Não temos nada além das informações de monitoramento remoto, como uma heurística para as refs que você deve ter visto e está disposto a adotar.
+
Caso o seu editor ou um outro sistema esteja executando o comando `git fetch` no segundo plano para você, uma maneira de atenuar isso é simplesmente configurar um outro ramo remoto:
+
	git remote add origin-push $(git config remote.origin.url)
	git fetch origin-push
+
Agora, quando o processo em segundo plano executar o comando `git fetch origin`, as referências no `origin-push` não serão atualizadas e portanto, comandos como:
+
	git push --force-with-lease origin-push
+
Irá falhar a menos que você execute manualmente o comando `git fetch origin-push`. É claro que esse método será totalmente derrotado por algo que execute o comando `git fetch --all`, neste caso, você precisa desativá-lo ou fazer algo mais tedioso como:
+
	git fetch              # atualiza o 'master' remotamente
	git tag base master    # marca o ponto da nossa base
	git rebase -i master   # reescreve alguns commits
	git push --force-with-lease=master:base master:master
+
Crie uma tag `base` para as versões do código upstream que você viu e está disposto a sobrescrever por exemplo, depois reescreva o histórico e finalmente, imponha um impulsionamento "push" com as alterações para `master` caso a versão remota ainda esteja na `base`, independentemente se os seus ramos `remotes/origin/master` locais foram atualizados em segundo plano ou não.
+
Alternativamente, ao usar a opção `--force-if-includes` como uma opção auxiliar em conjunto com `--force-with-lease[=<refname>]` (sem dizer qual o ref exato do commit remoto, ou quais os refs remotos que estão sendo protegidos por exemplo) no momento do "push", irá verificar se as atualizações a partir dos refs monitorados remotamente tenham sido atualizados de forma implicita em segundo plano e se estão sendo integrados localmente antes de permitir uma atualização forçada.

-f::
--force::
	Usually, `git push` will refuse to update a branch that is not an ancestor of the commit being pushed.
+
This flag disables that check, the other safety checks in PUSH RULES below, and the checks in --force-with-lease. It can cause the remote repository to lose commits; use it with care.
+
Observe que a opção `--force` se aplica a todas as refs que forem enviadas, portanto, usá-lo com `push.default` definido como `matching` ou com vários destinos de envio configurados com `remote.*.push` pode substituir diferentes refs do ramo atual (incluindo as refs locais que estão estritamente atrás de sua contraparte remota). Para forçar um envio para apenas um ramo, use um `+` na frente do refspec que será enviado (`git push origin +master` para forçar um envio para o ramo `master` por exemplo). Para mais detalhes consulte a seção `<refspec>...` acima.

--force-if-includes::
--no-force-if-includes::
	Impõem uma atualização apenas se o topo da ref monitorada remotamente estiver integrada localmente.
+
Esta opção permite uma checagem que verifica se o topo da referência monitorada remotamente é alcançável a partir de uma das entradas "reflog" do ramo local e feita com base nela para uma reescrita. A verificação assegura que quaisquer atualizações do ramo remoto foram incorporadas localmente, rejeitando a atualização forçada se não for esse o caso.
+
Nenhuma operação será feita caso a opção seja usada sem definir `--force-with-lease` ou se definir junto com `--force-with-lease=<refname>:<expect>`.
+
Usando a opção `--no-force-if-includes` desativa este comportamento.

--repo=<repositório>::
	Esta opção é equivalente ao argumento <repositório>. Caso ambos sejam utilizados, o argumento da linha de comandos terá a prioridade.

-u::
--set-upstream::
	Para cada ramo atualizado ou impulsionada com êxito, adicione uma referência "upstream" (monitorado), utilizada sem argumento pelo linkgit:git-pull[1] e os outros comandos. Para mais informações, consulte `branch.<nome>.merge` no linkgit:git-config[1].

--thin::
--no-thin::
	Estas opções são passadas para o linkgit:git-send-pack[1]. Uma pequena transferência "thin" reduz significativamente a quantidade dos dados enviados quando o remetente e o destinatário compartilham muito dos mesmos objetos em comum. A predefinição é `--thin`.

-q::
--quiet::
	Suprima tudo o que for gerado, incluindo a listagem das atualizações das refs, a menos que um erro aconteça. O progresso não é relatado para o fluxo de erro predefinido.

-v::
--verbose::
	Rode de forma loquaz.

--progress::
	É predefinido que a condição geral do progresso seja relatada no fluxo de erros quando estiver conectado num terminal, a menos que `-q` seja utilizado. Esta opção impõem a condição geral do progresso, mesmo que o fluxo de erro predefinido não seja direcionado para um terminal.

--no-recurse-submodules::
--recurse-submodules=check|on-demand|only|no::
	Pode ser usado para garantir que todos os commits dos submódulos usados pelas revisões que serão enviadas estejam disponíveis numa ramificação rastreada remotamente. Se 'check' for usado, o Git verificará se todos os commits do submódulo que foram alterados nas revisões que serão enviadas, se já estão disponíveis em pelo menos um submódulo do ramo remoto. Se algum commit estiver faltando, o 'push' será abortado e encerrará com uma condição diferente de zero. Elas serão enviadas se 'on-demand' for usado, todos os submódulos que foram alterados nas revisões que serão enviadas. Se o 'on-demand' não conseguir fazer o 'push' de todas as revisões necessárias, ele também será abortado e encerrará com uma condição diferente de zero. Se 'only' for usado, todos os submódulos serão enviados, menos o superprojeto. Um valor de 'no' ou o uso da opção `--no-recurse-submodules` pode ser usado para substituir a variável de configuração `push.recurseSubmodules` quando não for necessário a recursão dos submódulos.
+
Ao usar 'on-demand' ou 'only', caso um submódulo tenha uma configuração "push.recurseSubmodules={on-demand,only}" ou "submodule.recurse", haverá uma recursão adicional. Nesse caso, "only" é tratado como "on-demand"(sob demanda).

--verify::
--no-verify::
	Ative o gancho prévio do 'push' (para mais detalhes consulte linkgit:githooks[5]). A predefinição é `--verify`, dando ao hook a chance de impedir o 'push'. Com a opção `--no-verify`, o hook é completamente ignorado.

-4::
--ipv4::
	Utilize apenas os endereços IPv4, ignorando os endereços IPv6.

-6::
--ipv6::
	Utilize apenas os endereços IPv6, ignorando os endereços IPv4.

include::urls-remotes.adoc[]

SAÍDA
-----

O que é gerado através do "git push" depende do método de transporte utilizado; Esta seção descreve a saída gerada durante o impulsionamento através do protocolo Git (localmente ou através do ssh).

Durante um "push" a condição é que seja gerado em formato de tabela, com cada linha representando a condição de um único "ref". Cada linha é uma forma de:

-------------------------------
 <flag> <resumo> <from> -> <to> (<reason>)
-------------------------------

Caso a opção `--porcelain` seja utilizado, cada linha da saída terá o formato:

-------------------------------
 <flag> \t <from>:<to> \t <summary> (<reason>)
-------------------------------

A condição das referências atualizadas é exibido apenas caso a opção `--porcelain` ou `--verbose` seja utilizada.

sinalizar, sinalização, indicação, marcação, marcador::
	Um único caractere indicando a condição da referência:
(space);; para um push com avanço rápido bem sucedido;
`+`;; para uma imposição de atualização bem sucedida;
`-`;; para uma "ref" que foi excluída com sucesso;
`*`;; para uma nova "ref" enviada com sucesso;
`!`;; para uma "ref"que foi rejeitado ou não conseguiu realizar o impulsionamento "push"; e
`=`;; para uma "ref" que estava atualizada e não precisava do impulsionamento "push".

resumo::
	Para uma "ref" impulsionada com sucesso, o resumo mostra os valores antigos e os novos da "ref" num formato adequado para a utilização como argumento para o comando `git log` (isso é `<antigo>..<novo>` na maioria dos casos, e `<antigo>...<novo>` para as atualizações impostas pelo avanço rápido).
+
Para uma atualização que falhou, mais detalhes serão dados:
+
--
rejeitado::
	O Git não tenta encaminhar a "ref" de forma alguma, geralmente porque não é um avanço rápido e você não impôs a atualização.

rejeitado remotamente::
	O lado remoto recusou a atualização. Normalmente, isso é causado por um gancho no lado remoto ou porque o repositório remoto tem uma das seguintes opções de segurança em vigor: `receive.denyCurrentBranch` (no caso de um 'push' para o ramo verificado), `receive.denyNonFastForwards` (para atualizações impostas sem 'fast-forward'), `receive.denyDeletes` ou `receive.denyDeleteCurrent`. Consulte linkgit:git-config[1].

falha remota::
	O lado remoto não relatou a atualização bem-sucedida da "ref", talvez por causa de um erro temporário, uma interrupção na conexão da rede ou um outro erro transitório.
--

de::
	O nome do "ref" local que está sendo impulsionado, menos o seu prefixo `refs/<tipo>/`. No caso de exclusão, o nome do "ref" local é omitido.

para::
	O nome ref remoto sendo atualizado, menos o seu prefixo `refs/<tipo>/`.

motivo::
	Uma explicação legível para pessoas. No caso dos refs que forem enviados com sucesso, nenhuma explicação é necessária. Para um "ref" que falhou, o motivo do fracasso então é descrito.

PUSH RULES
----------

As a safety feature, the `git push` command only allows certain kinds of updates to prevent you from accidentally losing data on the remote.

Because branches and tags are intended to be used differently, the safety rules for pushing to a branch are different from the rules for pushing to a tag. In the following rules "update" means any modifications except deletions and creations. Deletions and creations are always allowed, except when forbidden by configuration or hooks.

1. If the push destination is a **branch** (`refs/heads/*`): only fast-forward updates are allowed, which means the destination must be an ancestor of the source commit. The source must be a commit.
2. If the push destination is a **tag** (`refs/tags/*`): all updates will be rejected. The source can be any object.
3. If the push destination is not a branch or tag:
   * If the source is a tree or blob object, any updates will be rejected
   * If the source is a tag or commit object, any fast-forward update is allowed, even in cases where what's being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it's replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.

You can override these rules by passing `--force` or by adding the optional leading `+` to a refspec. The only exceptions are that no amount of forcing will make a branch accept a non-commit object, and forcing won't make the remote repository accept a push that it's configured to deny.

Hooks and configuration can also override or amend these rules, see e.g. `receive.denyNonFastForwards` and `receive.denyDeletes` in linkgit:git-config[1] and `pre-receive` and `update` in linkgit:githooks[5].

NOTA SOBRE AVANÇOS RÁPIDOS
--------------------------

Quando uma atualização altera um ramo (ou geralmente uma "ref") que costumava apontar para o commit 'A' que aponta para outro commit 'B', é chamado de atualização de avanço rápido apenas e somente se 'B' for descendente de 'A'.

Numa atualização rápida de A para B, o conjunto de commits onde o commit original A foi construído é um subconjunto dos commits onde o novo commit B foi construído. Portanto, nenhum histórico é perdido.

Por outro lado, uma atualização sem avanço rápido (fast-forward) perderá o histórico. Por exemplo, imagine que você e outra pessoa começaram no mesmo commit X e você construiu um histórico que leva ao commit B, enquanto a outra pessoa construiu um histórico que leva ao commit A. O histórico ficará assim:

----------------

      B
     /
 ---X---A

----------------

Além disso, suponha que a outra pessoa já tenha enviado as alterações que levam "A" de volta ao repositório original, a partir do qual vocês dois obtiveram o commit "X" original.

O 'push' feito pela outra pessoa atualizou o ramo que apontava para o commit X para apontar para o commit A. É um avanço rápido (fast-forward).

Mas se você tentar fazer o 'push', você tentará atualizar a ramificação (que agora aponta para A) com o commit B. Isso não é um avanço rápido. Se fizer isso, as alterações introduzidas pelo commit A serão perdidas, pois todos começarão a construir em cima de B.

É predefinido que o comando não permita uma atualização que não seja um avanço rápido para impedir esta perda do histórico.

Caso não queira perder o seu trabalho (histórico 'X' para 'B') ou o trabalho da outra pessoa (histórico de 'X' para 'A'), é necessário primeiro buscar o histórico no repositório, criar um histórico que contenha as alterações feitas por ambas as partes e que impulsione o resultado de volta.

Você pode executar o "git pull", resolver possíveis conflitos e fazer um "git push" do resultado. Um "git pull" criará uma mesclagem do commit C entre os commits A e B.

----------------

      B---C
     /   /
 ---X---A

----------------

A atualização de "A" com a consolidação resultante da mesclagem, avançará rapidamente e o seu envio será aceito.

Como alternativa, você pode fazer o rebase da alteração entre X e B em cima de A, com `git pull --rebase`, e enviar de volta o resultado com um 'push'. O rebase criará um novo commit D que constrói a alteração entre X e B em cima de A.

----------------

      B   D
     /   /
 ---X---A

----------------

Novamente, a atualização de 'A' com este commit avançará rapidamente e o seu envio será aceito.

Há uma outra situação comum onde é possível encontrar uma rejeição sem avanço rápido ao tentar enviar através do "push", e é possível mesmo quando você está impulsionando para um repositório que ninguém mais faz impulsionamentos. Depois de enviar o commit 'A' (na primeira foto desta seção), substitua-o pelo comando "git commit --amend" para produzir o commit 'B' e tente realizar o "push", porque foi esquecido que já foi feito um push para 'A'. Neste caso e somente caso tenha certeza que ninguém fez a busca pelo seu commit 'A' anterior (e começou a construir em cima ele), execute o comando "git push --force" para substituí-lo. Em outras palavras, o comando "git push --force" é um método reservado para o caso onde você queira perder o histórico.


EXEMPLOS
--------

`git push`::
	Funciona como `git push <remoto>`, onde <remoto> é o ramo remoto da ramificação atual (ou `origin` (origem), caso nenhum ramo remoto estiver configurado para a ramificação atual).

`git push origin`::
	Sem uma configuração adicional, envia a ramificação atual para a upstream configurada (a variável de configuração `branch.<name>.merge`) caso ela tenha o mesmo nome que o ramo atual e os erros ocorrerem sem qualquer outro impulsionamento.
+
O comportamento predefinido deste comando quando nenhum <refspec> for informado, pode ser configurado definindo a opção `push` do ramo remoto ou a variável de configuração `push.default`.
+
Por exemplo, para fazer o envio predefinido apenas do ramo atual para `origin`, use o comando `git config remote.origin.push HEAD`. Qualquer <refspec> válido (como os dos exemplos abaixo) pode ser configurado como o predefinido para o comando `git push origin`.

`git push origin :`::
	Impulsiona (push) as ramificações "que coincidam" para `origin`. Consulte o <refspec> na seção <<OPTIONS,OPTIONS>> acima para obter uma descrição dos ramos "coincidentes".

`git push origin master`::
	Encontre uma referência que corresponda a `master` no repositório de origem (provavelmente, ele encontrará `refs/heads/master`) e atualize a mesma referência (`refs/heads/master` por exemplo) no repositório `origin` com ela. Se `master` não existir remotamente, ele seria criado.

`git push origin HEAD`::
	Uma maneira prática de enviar a ramificação atual com o mesmo nome no ramo remoto.

`git push mothership master:satellite/master dev:satellite/dev`::
	Use a referência da origem que corresponde ao `master` (`refs/heads/master` por exemplo) para atualizar a referência que corresponde ao `satellite/master` (provavelmente `refs/remotes/satellite/master`) no repositório `mothership`; faça o mesmo para `dev` e também para `satellite/dev`.
+
Consulte a seção que descreve `<refspec> ...` acima para uma discussão sobre a combinação semântica.
+
Isto serve para emular o comando `git fetch` executado na `mothership` utilizando o `git push` que é executado na direção oposta para integrar o trabalho realizado no `satellite` e geralmente é necessário quando só é possível fazer a conexão num sentido (ou seja, o satélite pode fazer uma conexão ssh com a nave mãe "mothership" mas a nave mãe não pode iniciar a conexão com o satélite porque este está atrás de um firewall ou não está executando o sshd (servidor ssh)).
+
Depois de executar o comando `git push` na máquina do `satellite`, você entraria na `mothership` e executaria o comando `git merge` lá para concluir a emulação do comando `git pull` executada na `mothership` para obter as alterações feitas no "satellite".

`git push origin HEAD: master`::
	Envie o ramo atual para a referência remota que coincida com `master` no repositório `origin`. Este formulário é conveniente para impulsionar o ramo atual sem pensar no nome local.

`git push origin master:refs/heads/experimental`::
	Crie o ramo `experimental` no repositório `origin` copiando o ramo `master` atual. Esse formulário só é necessário para criar uma nova ramificação ou etiqueta no repositório remoto quando o nome local e o nome remoto forem diferentes; caso contrário, o nome da referência por si só funcionará.

`git push origin :experimental`::
	Encontre uma "ref" que coincida com `experimental` no repositório `origin` (`refs/heads/experimental` por exemplo) e exclua-a.

`git push origin +dev:master`::
	Atualiza a ramificação principal do repositório de origem com a ramificação de desenvolvimento, permitindo atualizações sem avanço rápido. *Isso pode deixar os commits não referenciados pendurados no repositório de origem.* Considere a seguinte situação, onde não é possível avançar rapidamente:
+
----
	    o---o---o---A---B  origin/master
		     \
		      X---Y---Z  dev
----
+
O comando acima alteraria o repositório de origem para
+
----
		      A---B  (ramo sem nome)
		     /
	    o---o---o---X---Y---Z  master
----
+
Os commits A e B não pertenceriam mais a uma ramificação com um nome simbólico e, portanto, seriam inacessíveis. Dessa maneira, estes commits seriam removidos por um comando `git gc` no repositório de origem.

include::transfer-data-leaks.adoc[]

[[CONFIGURATION]]
CONFIGURAÇÃO
------------

include::includes/cmd-config-section-all.adoc[]

include::config/push.adoc[]

GIT
---
Parte do conjunto linkgit:git[1]
