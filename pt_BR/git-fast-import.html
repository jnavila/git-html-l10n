<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="generator" content="Asciidoctor 2.0.23"/>
<title>git-fast-import(1)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"/>
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="manpage">
<div id="header">
<h1>git-fast-import(1) Manual Page</h1>
<h2 id="_nome">NOME</h2>
<div class="sectionbody">
<p>git-fast-import - Estrutura para os importadores de dados rápidos do Git</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_resumo">RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content">frontend | <em>git fast-import</em> [&lt;opções&gt;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição">DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Normalmente, este programa não é o que o usuário final deseja executar diretamente. A maioria dos usuários finais deseja usar um dos programas "front-end" já existentes, que analisa um tipo específico de código-fonte externo e alimenta o conteúdo armazenado com <em>git fast-import</em>.</p>
</div>
<div class="paragraph">
<p>A importação rápida lê um fluxo misto de comando/dados na entrada predefinida e registra um ou mais pacote de arquivos diretamente no repositório atual. Quando um EOF é recebido na entrada predefinida, a importação rápida registra as referências atualizadas do ramo e da etiqueta, atualizando totalmente o repositório atual com os dados que foram recém-importados.</p>
</div>
<div class="paragraph">
<p>O próprio "backend fast-import" pode importar para um repositório vazio (um que já tenha sido inicializado pelo comando <em>git init</em>) ou atualizar de forma incremental um repositório existente e já preenchido. O fato das importações incrementais serem ou não compatíveis com uma determinada fonte estrangeira, isso dependerá do programa front-end em uso.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções">OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">--force</dt>
<dd>
<p>Impor a atualização das ramificações existentes que foram alteradas , ainda que os commits sejam perdidos (como um novo commit que não contenha o commit antigo).</p>
</dd>
<dt class="hdlist1">--quiet</dt>
<dd>
<p>Desabilita a saída mostrada por <code>--stats</code>, fazendo com que o "fast-import" geralmente seja silencioso quando for bem-sucedido. No entanto, se o fluxo de importação tiver opções destinadas a mostrar a saída do usuário (como a opção <code>progress</code> por exemplo), as mensagens correspondentes ainda serão exibidas.</p>
</dd>
<dt class="hdlist1">--stats</dt>
<dd>
<p>Exibe algumas estatísticas básicas sobre os objetos que o "fast-import" criou, onde foram armazenados os pacotes de arquivos e a memória usada pelo "fast-import" durante essa execução. Esta é atualmente a exibição predefinida, mas pode ser desativada com a opção <code>--quiet</code>.</p>
</dd>
<dt class="hdlist1">--allow-unsafe-features</dt>
<dd>
<p>Muitas opções de linha de comando podem ser usadas como parte do próprio fluxo de importação rápida, usando os comandos <code>feature</code> ou <code>option</code>. No entanto, algumas dessas opções não são seguras (permitir que a importação rápida acesse o sistema de arquivos fora do repositório por exemplo). Estas opções são desativadas por padrão, mas podem ser permitidas usando essa opção na linha de comando. Atualmente, isso afeta apenas os comandos <code>export-marks</code>, <code>import-marks</code> e <code>import-marks-if-exists</code>.</p>
<div class="literalblock">
<div class="content">
<pre>Ative esta opção apenas caso confie no programa que gera o fluxo de importação rápida! Esta opção é ativada automaticamente para os auxiliares remotos que usem o recurso `import`, pois eles já são confiáveis para executar o seu próprio código.</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_opções_para_front_ends">Opções para Front-ends</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">--cat-blob-fd=&lt;fd&gt;</dt>
<dd>
<p>Escreva as respostas às consultas <code>get-mark</code>, <code>cat-blob</code> e <code>ls</code> no descritor do arquivo <em>&lt;fd&gt;</em> em vez de <code>stdout</code>. Permite que a saída <code>progress</code> destinada ao usuário final seja separada de outras saídas.</p>
</dd>
<dt class="hdlist1">--date-format=&lt;fmt&gt;</dt>
<dd>
<p>Especifique o tipo de data que o "front-end" informará para a importação rápida nos comandos <code>author</code>, <code>committer</code> (quem fez o commit) e <code>tagger</code> (rotulador). Consulte &#8220;Formatos de data&#8221; abaixo para obter mais detalhes sobre quais os formatos são compatíveis e a sua sintaxe.</p>
</dd>
<dt class="hdlist1">--done</dt>
<dd>
<p>Será encerrado com erro se não houver um comando <code>done</code> no final do fluxo. Essa opção pode ser útil para detectar erros que fazem com que o "front-end" seja encerrado antes de começar a registrar um fluxo.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_localizações_dos_arquivos_de_marcação">Localizações dos arquivos de marcação</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">--export-marks=&lt;arquivo&gt;</dt>
<dd>
<p>Despeja a tabela das marcas internas em <em>&lt;arquivo&gt;</em> quando for concluído. As marcas são gravadas uma por linha como <code>:markid</code> <code>SHA-1</code>. Os "front-ends" podem usar esse arquivo para validar as importações depois que elas forem concluídas ou para salvar a tabela de marcas em execuções incrementais. Como <em>&lt;arquivo&gt;</em> só é aberto e truncado no ponto de verificação (checkpoint), o mesmo caminho também pode ser usado com segurança com a opção <code>--import-marks</code>.</p>
</dd>
<dt class="hdlist1">--import-marks=&lt;arquivo&gt;</dt>
<dd>
<p>Antes de processar qualquer entrada, carregue as marcas especificadas em &lt;arquivo&gt;. O arquivo de entrada deve existir, deve ser legível e deve usar o mesmo formato produzido pela opção <code>--export-marks</code>. Várias opções podem ser fornecidas para importar mais de um conjunto de marcações. Se uma marcação for definida com valores diferentes, o último arquivo vence.</p>
</dd>
<dt class="hdlist1">--import-marks-if-exists=&lt;arquivo&gt;</dt>
<dd>
<p>Como <code>--import-marks</code> porém caso não exista, em vez de exibir um erro, ignora silenciosamente o arquivo.</p>
</dd>
<dt class="hdlist1">--[no-]relative-marks</dt>
<dd>
<p>Após o uso da opção <code>--relative-marks</code>, os caminhos especificados com a opção <code>--import-marks=</code> e <code>--export-marks=</code> são relativos a um diretório interno no repositório atual. No "git-fast-import", isso significa que os caminhos são relativos ao diretório .<code>git/info/fast-import</code>. Entretanto, outros importadores podem usar um local diferente.</p>
<div class="paragraph">
<p>Marcações relativas ou não podem ser combinadas entrelaçando <code>--</code>(<code>no-</code>)<code>-relative-marks</code> com a opção <code>--</code>(<code>import</code>|<code>export</code>)<code>-marks=</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_reescrita_do_submódulo">Reescrita do submódulo</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">--rewrite-submodules-from=&lt;nome&gt;:&lt;arquivo&gt;</dt>
<dt class="hdlist1">--rewrite-submodules-to=&lt;nome&gt;:&lt;arquivo&gt;</dt>
<dd>
<p>Reescreve a ID dos objetos no submódulo especificado através do &lt;nome&gt; dos valores usados a partir de um &lt;arquivo&gt; para aqueles usados para o &lt;arquivo&gt;. As marcações de origem deveriam ter sido criadas por pelo comando <code>git</code> <code>fast-export</code> e as marcações to deveriam ter sido criadas pelo <code>git</code> <code>fast-import</code> durante a importação do mesmo submódulo.</p>
<div class="paragraph">
<p>&lt;nome&gt; pode ser qualquer string arbitrária que não contenha um caractere dois-pontos, mas o mesmo valor deve ser usado com ambas as opções ao especificar as marcações correspondentes. Diversos submódulos podem ser especificados com valores diferentes para <em>&lt;nome&gt;</em>. É um erro não usar estas opções em pares correspondentes.</p>
</div>
<div class="paragraph">
<p>Estas opções são úteis principalmente durante a conversão de um repositório através de um algoritmo hash para o outro; sem eles, a importação rápida irá falhar caso encontre um submódulo porque não há como gravar a ID do objeto no novo algoritmo hash.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ajuste_de_desempenho_e_compactação">Ajuste de desempenho e compactação</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">--active-branches=&lt;n&gt;</dt>
<dd>
<p>A quantidade máxima de ramos que serão mantidas ativas ao mesmo tempo. Consulte &#8220;Memory Utilization&#8221; logo abaixo para mais detalhes. A predefinição é 5.</p>
</dd>
<dt class="hdlist1">--big-file-threshold=&lt;n&gt;</dt>
<dd>
<p>O tamanho máximo de uma bolha para onde o "fast-import" tentará criar um delta, ele é expresso em bytes. A predefinição é 512m (512 MiB). Alguns importadores podem querer diminuir esse valor em sistemas com limitações de memória.</p>
</dd>
<dt class="hdlist1">--depth=&lt;n&gt;</dt>
<dd>
<p>Profundidade máxima do delta, para a "deltificação" das bolhas e das árvores. A predefinição é 50.</p>
</dd>
<dt class="hdlist1">--export-pack-edges=&lt;arquivo&gt;</dt>
<dd>
<p>Após criar um arquivo pacote, imprima uma linha de dados em &lt;arquivo&gt; listando o nome do arquivo pacote e do último commit em cada ramo onde ele foi gravado nesse arquivo pacote. Estas informações podem ser úteis após a importação de projetos cujo conjunto total dos objetos exceda o limite de 4 GiB do arquivo pacote, pois estes commits podem ser usados como pontos de limite durante as chamadas para o comando <em>git pack-objects</em>.</p>
</dd>
<dt class="hdlist1">--max-pack-size=&lt;n&gt;</dt>
<dd>
<p>O tamanho máximo de cada arquivo pacote gerado. A predefinição é ilimitado.</p>
</dd>
<dt class="hdlist1">fastimport.unpackLimit</dt>
<dd>
<p>Consulte <a href="git-config.html">git-config(1)</a></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_desempenho">DESEMPENHO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O design da importação rápida (fast-import) permite que ele importe grandes projetos com um mínimo de uso de memória e tempo de processamento. Supondo que o "front-end" seja capaz de acompanhar a importação rápida e alimentá-lo com um fluxo constante de dados, os tempos de importação de projetos com mais de 10 anos de histórico e contendo mais de 100.000 commits individuais geralmente são concluídos em apenas uma ou duas horas num hardware bastante modesto (cerca de US$ 2.000).</p>
</div>
<div class="paragraph">
<p>A maioria dos gargalos parece estar no acesso aos dados da fonte externa (a fonte simplesmente não consegue extrair as revisões com rapidez suficiente) ou na E/S do disco (a importação rápida faz o registro tão rápidas quanto o disco for capaz de aceitar os dados). As importações serão executadas mais rapidamente se os dados da origem forem armazenados numa unidade diferente do repositório Git de destino (devido à menor contenção de IO).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_custo_de_desenvolvimento">CUSTO DE DESENVOLVIMENTO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Um "front-end" típico para a importação rápida tende a pesar aproximadamente 200 linhas de código Perl/Python/Ruby. A maioria dos desenvolvedores conseguiu criar importadores funcionais em apenas algumas horas, mesmo que essa seja a sua primeira exposição à importação rápida e, às vezes, até mesmo ao Git. Essa é uma situação ideal, já que a maioria das ferramentas de conversão é descartável (use uma vez e nunca mais olhe para trás).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operação_em_paralelo">OPERAÇÃO EM PARALELO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como <code>git</code> <code>push</code> ou <code>git</code> <code>fetch</code>, as importações manipuladas pelo <code>fast-import</code> são seguras para serem executadas juntamente com as invocações paralelas <code>git</code> <code>repack</code> <code>-a</code> <code>-d</code> ou <code>git</code> <code>gc</code> ou qualquer outra operação Git (incluindo <code>git</code> <code>prune</code>, objetos soltos nunca são utilizados por <code>fast-import</code>).</p>
</div>
<div class="paragraph">
<p>A importação rápida não bloqueia o ramo ou as referências de tag que está importando ativamente. Após a importação, durante a sua fase de atualização da referência, a importação rápida testa individualmente cada "ref" do ramo já existente para verificar se a atualização será uma atualização de avanço rápido (o commit armazenado na ref está contido no novo histórico do commit que será gravado). Se a atualização não for uma atualização de avanço rápido, a importação rápida não atualizará essa referência e, em vez disso, mostrará uma mensagem de aviso. A importação rápida sempre tentará atualizar todas as referências da ramificação e não interromperá o processo na primeira falha.</p>
</div>
<div class="paragraph">
<p>As atualizações da ramificação podem ser impostas com a opção <code>--force</code>, mas é recomendável que isso seja usado somente num repositório mais tranquilo. O uso da opção <code>--force</code> não é necessário para uma importação inicial num repositório vazio.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_discussão_técnica">DISCUSSÃO TÉCNICA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A importação rápida rastreia um conjunto de ramos na memória. Qualquer ramificação pode ser criada ou alterada a qualquer momento durante o processo de importação, enviando um comando <code>commit</code> no fluxo de entrada. Este design permite que um programa "front-end" processe simultaneamente uma quantidade ilimitada de ramificações, gerando commits na ordem em que estão disponíveis nos dados de origem. Ele também simplifica consideravelmente os programas "front-end".</p>
</div>
<div class="paragraph">
<p>A importação rápida não usa e nem altera o diretório de trabalho atual ou qualquer arquivo dentro dele. (No entanto, ele atualiza o repositório Git atual, conforme referenciado por <code>GIT_DIR</code>). Portanto, um "front-end" de importação pode usar o diretório de trabalho para os seus próprios fins, como extrair as revisões dos arquivos de origem estrangeira. Esse desconhecimento do diretório de trabalho também permite que a importação rápida seja executada com muita rapidez, pois não precisa realizar nenhuma operação dispendiosa de atualização de arquivos ao alternar entre as ramificações.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_formato_de_entrada">FORMATO DE ENTRADA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Com a exceção de dados dos arquivos brutos (que o Git não interpreta), o formato de entrada de importação rápida tem texto (ASCII) como base. Esse formato texto simplifica o desenvolvimento e a depuração de programas "front-end", especialmente quando uma linguagem de alto nível estiver sendo usada como Perl, Python ou Ruby.</p>
</div>
<div class="paragraph">
<p>A importação rápida é muito rigorosa com a sua entrada. Quando dizemos o SP abaixo, queremos dizer <strong>exatamente</strong> um espaço. Da mesma maneira, <code>LF</code> significa um (e somente um) avanço de linha e <code>HT</code> uma (e somente uma) tabulação horizontal. Resultados inesperados serão causados com o fornecimento de caracteres de espaço vazio adicionais, como nomes de ramificações ou nomes de arquivos com espaços à esquerda ou à direita dos seus nomes, ou o encerramento antecipado da importação rápida quando ele encontrar uma entrada inesperada.</p>
</div>
<div class="sect2">
<h3 id="_comentários_do_fluxo">Comentários do fluxo</h3>
<div class="paragraph">
<p>Para ajudar na depuração dos "front-ends", A importação rápida ignora qualquer linha que comece com # (libra/hash ASCII), inclusive, até a linha que termina em <code>LF</code>. Uma linha de comentário pode conter qualquer sequência de bytes que não contenha um <code>LF</code> e, portanto, pode ser usada para incluir qualquer informação detalhada de depuração que possa ser específica do "front-end" e útil ao inspecionar um fluxo de dados de importação rápida.</p>
</div>
</div>
<div class="sect2">
<h3 id="_formatos_de_data">Formatos de data</h3>
<div class="paragraph">
<p>Os seguintes formatos de data são compatíveis. Um "front-end" deve selecionar o formato que será utilizado para esta importação, repassando o nome do formato na opção da linha de comando <code>--date-format=</code><em>&lt;fmt&gt;</em>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>raw</code></dt>
<dd>
<p>Este é o formato nativo do Git que é <em>&lt;time&gt;</em> <code>SP</code> <em>&lt;offutc&gt;</em>. Este também é o formato predefinida da importação rápida, caso a opção <code>--date-format</code> não tenha sido especificada.</p>
<div class="paragraph">
<p>A hora do evento é especificado através de <em>&lt;tempo&gt;</em> como o número de segundos desde a época UNIX (meia-noite de 1º de janeiro de 1970, UTC) e é gravado como um número inteiro decimal ASCII.</p>
</div>
<div class="paragraph">
<p>O offset local é especificado por <em>&lt;offutc&gt;</em> como um offset positivo ou negativo em relação ao UTC. Por exemplo, o EST (que está 5 horas atrás do UTC) seria expresso em <em>&lt;tz&gt;</em> por &#8220;-0500&#8221;, enquanto o UTC é &#8220;+0000&#8221;. O offset local não afeta o <em>&lt;time&gt;</em>; ele é usado apenas como um aviso para ajudar as rotinas de formatação a exibir o registro de data e hora.</p>
</div>
<div class="paragraph">
<p>Se o offset local não estiver disponível no material de origem, use &#8220;+0000&#8221; ou o offset local mais comum. Por exemplo, muitas organizações têm um repositório CVS que só foi acessado por usuários que estão localizados no mesmo local e fuso horário. Neste caso, pode-se presumir um offset razoável do UTC.</p>
</div>
<div class="paragraph">
<p>Diferente do formato <code>rfc2822</code>, este formato é muito rigoroso. Qualquer variação na formatação fará com que a importação rápida rejeite o valor e algumas verificações de sanidade nos valores numéricos também podem ser realizadas.</p>
</div>
</dd>
<dt class="hdlist1"><code>raw-permissive</code></dt>
<dd>
<p>É o mesmo que <code>raw</code>, exceto pelo fato de que não são realizadas verificações de sanidade na época numérica e no offset local. Isso pode ser útil ao tentar filtrar ou importar um histórico existente com, por exemplo, valores falsos de fuso horário.</p>
</dd>
<dt class="hdlist1"><code>rfc2822</code></dt>
<dd>
<p>This is the standard date format as described by RFC 2822.</p>
<div class="paragraph">
<p>Um exemplo de valor é &#8220;Tue Feb 6 11:22:18 2007 -0500&#8221;. O analisador do Git é preciso, porém, é pouco tolerante. É o mesmo analisador usado pelo comandos <em>git am</em> ao aplicar as correções recebidos por e-mail.</p>
</div>
<div class="paragraph">
<p>Algumas strings malformadas podem ser aceitas como datas válidas. Em alguns desses casos, o Git ainda conseguirá obter a data correta a partir da string malformada. Há também alguns tipos de strings malformadas que o Git analisará incorretamente e, ainda assim, as considerará válidas. As strings seriamente malformadas serão rejeitadas.</p>
</div>
<div class="paragraph">
<p>Diferentemente do formato <code>raw</code> acima, as informações de offset do fuso horário/UTC contidas numa string de datas RFC 2822 são usadas para ajustar o valor da data para UTC antes do armazenamento. Portanto, é importante que essas informações sejam as mais precisas possíveis.</p>
</div>
<div class="paragraph">
<p>Caso o material de origem utilize datas no formato RFC 2822, o front-end deve permitir que o <code>fast-import</code> manipule a análise a conversão (em vez de tentar fazer isso sozinho), pois o analisador do Git foi bem testado num ambiente natural.</p>
</div>
<div class="paragraph">
<p>Os front-end devem preferir o formato <code>raw</code> (bruto) caso o material de origem já utilize o formato UNIX, pode ser atrativo fornecer datas nesse formato, ou o seu formato é facilmente convertível, pois não há ambiguidade na análise.</p>
</div>
</dd>
<dt class="hdlist1"><code>now</code></dt>
<dd>
<p>Sempre use a hora e o fuso horário atual. O literal <code>now</code> sempre deve ser repassado para <em>&lt;quando&gt;</em>.</p>
<div class="paragraph">
<p>Este é um formato de brinquedo. A hora e o fuso horário atual desse sistema são sempre copiados para a string de identidade no momento em que ela está sendo criada pela importação rápida. Não há como especificar um horário ou fuso horário diferente.</p>
</div>
<div class="paragraph">
<p>Esse formato em particular é informado para implementação curta e pode ser útil para um processo onde se deseja criar um novo commit imediatamente, sem a necessidade de usar um diretório ativo ou <code>git</code> <code>update-index</code>.</p>
</div>
<div class="paragraph">
<p>Se forem usados comandos <code>author</code> e <code>committer</code> separados num <code>commit</code>, os registros de data e hora podem não corresponder, pois o relógio do sistema será consultado duas vezes (uma para cada comando). A única maneira de garantir que as informações de identidade do autor e de quem fez o commit tenham o mesmo registro de data e hora é omitir o <code>author</code> (copiando assim de <code>committer</code>) ou usar um formato de data diferente de <code>now</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_comandos">Comandos</h3>
<div class="paragraph">
<p>A importação rápida aceita vários comandos para atualizar o repositório atual e controlar o processo de importação atual. Uma discussão mais detalhada (com exemplos) de cada comando será apresentada posteriormente.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>commit</code></dt>
<dd>
<p>Cria uma nova ramificação ou atualiza uma ramificação existente, criando um novo commit e atualizando a ramificação para apontar para o commit recém criado.</p>
</dd>
<dt class="hdlist1"><code>tag</code></dt>
<dd>
<p>Cria um objeto de etiqueta anotada a partir de um commit ou de um ramo já existente. As etiquetas simples não são compatíveis por esse comando, pois não são recomendadas para registrar pontos de tempo significativos.</p>
</dd>
<dt class="hdlist1"><code>reset</code></dt>
<dd>
<p>Redefine um ramo existente (ou um novo ramo) para uma revisão específica. Esse comando deve ser usado para alterar uma ramificação para uma revisão específica sem fazer um commit nela.</p>
</dd>
<dt class="hdlist1"><code>blob</code></dt>
<dd>
<p>Converte os dados brutos do arquivo numa bolha, para uso futuro num comando <code>commit</code>. Esse comando é opcional e não é necessário para realizar uma importação.</p>
</dd>
<dt class="hdlist1"><code>alias</code></dt>
<dd>
<p>Registre que uma marcação se refira a um determinado objeto sem primeiro criar nenhum novo objeto. O uso da opção <code>--import-marks</code> e a referência as marcações ausentes farão com que a importação rápida falhe, portanto, os pseudônimos podem fornecer uma maneira de definir os commits que, de outra maneira, seriam podados para um valor válido (o ancestral não podado mais próximo por exemplo).</p>
</dd>
<dt class="hdlist1"><code>checkpoint</code></dt>
<dd>
<p>Força a importação rápida a fechar o arquivo do pacote atual, gerar a sua soma de verificação e o índice SHA-1 exclusivos e iniciar um novo pacote de arquivos. Esse comando é opcional e não é necessário para realizar uma importação.</p>
</dd>
<dt class="hdlist1"><code>progress</code></dt>
<dd>
<p>Faz com que a importação rápida ecoe a linha inteira em sua própria saída predefinida. Esse comando é opcional e não é necessário para realizar uma importação.</p>
</dd>
<dt class="hdlist1"><code>done</code></dt>
<dd>
<p>Faz a marcação do fim do fluxo. Este comando é opcional, a menos que o recurso <code>--done</code> tenha sido solicitado utilizando a opção de linha de comando <code>--done</code> ou o comando <code>feature</code> <code>done</code>.</p>
</dd>
<dt class="hdlist1"><code>get-mark</code></dt>
<dd>
<p>Faz com que o <code>fast-import</code> imprima o SHA-1 correspondente a uma marcação no descritor do arquivo definido com <code>--cat-blob-fd</code> ou <code>stdout</code> caso não tenha sido especificado.</p>
</dd>
<dt class="hdlist1"><code>cat-blob</code></dt>
<dd>
<p>Faz com que o <code>fast-import</code> imprima uma bolha no formato <em>cat-file --batch</em> no descritor do arquivo definido com <code>--cat-blob-fd</code> ou <code>stdout</code> caso não tenha sido especificado.</p>
</dd>
<dt class="hdlist1"><code>ls</code></dt>
<dd>
<p>Faz com que o <code>fast-import</code> imprima uma linha que descreve uma entrada do diretório no formato <code>ls-tree</code> para o descritor do arquivo definido com <code>--cat-blob-fd</code> ou <code>stdout</code> caso não tenha sido especificado.</p>
</dd>
<dt class="hdlist1"><code>feature</code></dt>
<dd>
<p>Ativa o recurso especificado. Isso requer que o <code>fast-import</code> ofereça compatibilidade ao recurso especificado, caso contrário, que seja abortado.</p>
</dd>
<dt class="hdlist1"><code>option</code></dt>
<dd>
<p>Especifique qualquer uma das opções listadas em <code>OPTIONS</code> que não alterem a semântica do fluxo para atender às necessidades do front-end. Este comando é opcional, não sendo necessário para executar uma importação.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_commit"><code>commit</code></h3>
<div class="paragraph">
<p>Crie ou atualize uma ramificação com um novo commit, registrando uma alteração lógica no projeto.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'commit' SP &lt;ref&gt; LF
        mark?
        original-oid?
        ('author' (SP &lt;nome&gt;)? SP LT &lt;e-mail&gt; GT SP &lt;quando&gt; LF)?
        'committer' (SP &lt;nome&gt;)? SP LT &lt;e-mail&gt; GT SP &lt;quando&gt; LF
        ('encoding' SP &lt;codificação&gt;)?
        data
        ('from' SP &lt;commit-ish&gt; LF)?
        ('merge' SP &lt;commit-ish&gt; LF)*
        (filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*
        LF?</pre>
</div>
</div>
<div class="paragraph">
<p>Onde <em>&lt;ref&gt;</em> é o nome do ramo onde o commit deve ser feito. Normalmente, os nomes das ramificações são prefixados com <code>refs/heads/</code> no Git, portanto, a importação do símbolo de ramificação do CVS <code>RELENG-1_0</code> usaria <code>refs/heads/RELENG-1_0</code> para o valor de <em>&lt;ref&gt;</em>. O valor de <em>&lt;ref&gt;</em> deve ser um nome de referência válido no Git. Como <code>LF</code> não é válido num <em>refname</em> do Git, aqui não há suporte para sintaxe de citação ou escape.</p>
</div>
<div class="paragraph">
<p>Um comando <code>mark</code> pode ser exibido opcionalmente, solicitando que a importação rápida salve uma referência ao commit recém-criado para uso futuro pelo "frontend" (veja o formato abaixo). É muito comum que os "front-ends" marquem cada commit que eles criam, permitindo assim a criação futura das ramificações a partir de qualquer commit que for importado.</p>
</div>
<div class="paragraph">
<p>O comando <code>data</code> que segue o <code>committer</code> deve repassar a mensagem do commit (veja abaixo a sintaxe do comando <code>data</code>). Para importar uma mensagem vazia do commit, use dados de comprimento 0. As mensagens do commit são de formato livre e não são interpretadas pelo Git. Atualmente, eles devem ser codificados em UTF-8, pois o "fast-import" não permite que outras codificações sejam definidas.</p>
</div>
<div class="paragraph">
<p>Zero ou mais comandos como <code>filemodify</code>, <code>filedelete</code>, <code>filecopy</code>, <code>filerename</code>, <code>filedeleteall</code> e <code>notemodify</code> podem ser incluídos para atualizar o conteúdo do ramo antes da criação do commit. Esses comandos podem ser repassados em qualquer ordem. No entanto, recomenda-se que um comando <code>filedeleteall</code> preceda todos os comandos <code>filemodify</code>, <code>filecopy</code>, <code>filerename</code> e <code>notemodify</code> no mesmo commit, pois o <code>filedeleteall</code> limpa a ramificação (veja abaixo).</p>
</div>
<div class="paragraph">
<p>O <code>LF</code> após o comando é opcional (antes era obrigatório). Observe que, por motivos de compatibilidade com as versões anteriores, se o commit terminar com um comando <code>data</code> (ou seja, não tiver comandos <code>from</code>, <code>merge</code>, <code>filemodify</code>, <code>filedelete</code>, <code>filecopy</code>, <code>filederename</code>, <code>filedeleteall</code> ou <code>notemodify</code>), dois comandos <code>LF</code> poderão aparecer no final do comando em vez de apenas um.</p>
</div>
<div class="sect3">
<h4 id="_author"><code>author</code></h4>
<div class="paragraph">
<p>Um comando <code>author</code> pode ser exibido opcionalmente, se as informações do autor forem diferentes das informações de quem fez o commit. Se <code>author</code> for omitido, a importação rápida usará automaticamente as informações de quem fez o commit para a parte do autor do commit. Veja abaixo uma descrição dos campos em <code>author</code>, pois eles são idênticos aos do <code>committer</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_committer"><code>committer</code></h4>
<div class="paragraph">
<p>O comando <code>committer</code> indica quem foi que fez o commit e quando foi feito.</p>
</div>
<div class="paragraph">
<p>Aqui, <em>&lt;nome&gt;</em> é o nome de exibição da pessoa (por exemplo, &#8220;Com M Itter&#8221;) e <em>&lt;email&gt;</em> é o endereço de e-mail da pessoa (&#8220;cm@example.com&#8221;). Já <code>LT</code> e <code>GT</code> são os símbolos literais menor que (\x3c) e maior que (\x3e). Eles são necessários para delimitar o endereço de e-mail dos outros campos da linha. Observe que <em>&lt;nome&gt;</em> e <em>&lt;email&gt;</em> são de formato livre e podem conter qualquer sequência de bytes, exceto <code>LT</code>, <code>GT</code> e <code>LF</code>. O <em>&lt;nome&gt;</em> é normalmente codificado em UTF-8.</p>
</div>
<div class="paragraph">
<p>A hora da alteração é especificada por <em>&lt;quando&gt;</em> usando o formato de data que foi selecionado pela opção de linha de comando <code>--date-format=</code><em>&lt;fmt&gt;</em>. Consulte &#8220;Formatos de data&#8221; abaixo para obter mais detalhes sobre quais os formatos são compatíveis e a sua sintaxe.</p>
</div>
</div>
<div class="sect3">
<h4 id="_encoding"><code>encoding</code></h4>
<div class="paragraph">
<p>O comando opcional <code>encoding</code> indica a codificação da mensagem do commit. A maioria dos commits é UTF-8 e a codificação é omitida, mas isso permite importar mensagens do commit para o git sem primeiro recodificá-las.</p>
</div>
</div>
<div class="sect3">
<h4 id="_from"><code>from</code></h4>
<div class="paragraph">
<p>O comando <code>from</code> é usado para especificar o commit a partir do qual esse ramo será inicializado. Essa revisão será o primeiro ancestral do novo commit. O estado da árvore construída neste commit começará com o estado no commit <code>from</code> e será alterado pelas alterações de conteúdo neste commit.</p>
</div>
<div class="paragraph">
<p>A omissão do comando <code>from</code> no primeiro commit de uma nova ramificação fará com que a importação rápida crie este commit sem nenhum ancestral. Isso tende a ser desejado apenas para o commit inicial de um projeto. Se o "front-end" criar todos os arquivos do zero durante a criação de uma nova ramificação, um comando <code>merge</code> poderá ser usado em vez de <code>from</code> para iniciar o commit com uma árvore vazia. A omissão do comando <code>from</code> em ramificações existentes geralmente é desejada, pois o commit atual nessa ramificação é automaticamente considerado o primeiro ancestral do novo commit.</p>
</div>
<div class="paragraph">
<p>Como <code>LF</code> não é válido numa referência de nome do Git ou numa expressão SHA-1, nenhuma sintaxe de citação ou escape é compatível com <em>&lt;commit-ish&gt;</em>.</p>
</div>
<div class="paragraph">
<p>Aqui <em>&lt;commit-ish&gt;</em> é qualquer um dos seguintes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>O nome de uma ramificação existente já na tabela interna de ramificações de importação rápida. Se a importação rápida não souber o nome, ele será tratado como uma expressão SHA-1.</p>
</li>
<li>
<p>A marcação de referência, <code>:</code><em>&lt;idnum&gt;</em>, onde <em>&lt;idnum&gt;</em> seja o número da marcação.</p>
<div class="paragraph">
<p>O motivo pelo qual o fast-import usa <code>:</code> para denotar uma referência de marca é que esse caractere não é legal num nome de ramo do Git. O <code>:</code> inicial facilita a distinção entre a marca 42 (<code>:42</code>) e a ramificação 42 (<code>42</code> ou <code>refs/heads/42</code>), ou um SHA-1 abreviado que consiste apenas em dígitos de base 10.</p>
</div>
<div class="paragraph">
<p>As marcações devem ser declaradas (através de <code>mark</code>) antes de poderem ser utilizadas.</p>
</div>
</li>
<li>
<p>Um commit completo com 40 bytes ou um SHA-1 abreviado em hexadecimal.</p>
</li>
<li>
<p>Qualquer expressão SHA-1 válida do Git que resolva para um commit. Para mais detalhes consulte &#8220;DEFININDO AS REVISÕES&#8221; do comando <a href="gitrevisions.html">gitrevisions(7)</a>.</p>
</li>
<li>
<p>O SHA-1 nulo especial (40 zeros) especifica que a ramificação deve ser removida.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O caso especial de reiniciar uma importação incremental do valor atual do ramo deve ser escrito como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>        from refs/heads/branch^0</pre>
</div>
</div>
<div class="paragraph">
<p>O sufixo <code>^0</code> é necessário, pois a importação rápida não permite que uma ramificação inicie a partir de si mesma, e a ramificação é criada na memória antes mesmo que o comando <code>from</code> seja lido na entrada. A adição de <code>^0</code> fará com que a importação rápida resolva o commit através da biblioteca de análise de revisão do Git, em vez da sua tabela de ramificação interna, carregando assim o valor existente da ramificação.</p>
</div>
</div>
<div class="sect3">
<h4 id="_merge"><code>merge</code></h4>
<div class="paragraph">
<p>Inclui um commit ancestral adicional. O link de ancestralidade adicional não altera a forma como o estado da árvore é construído neste commit. Se o comando <code>from</code> for omitido ao criar um novo ramo, o primeiro commit <code>merge</code> será o primeiro ancestral do commit atual, e o ramo começará sem arquivos. Um número ilimitado de comandos <code>merge</code> por commit é permitido pela importação rápida estabelecendo assim uma mesclagem de "n" vias.</p>
</div>
<div class="paragraph">
<p>Aqui <em>&lt;commit-ish&gt;</em> é qualquer uma das expressões de especificação de um commit também aceitas por <code>from</code> (veja acima).</p>
</div>
</div>
<div class="sect3">
<h4 id="_filemodify"><code>filemodify</code></h4>
<div class="paragraph">
<p>Incluído num comando <code>commit</code> para adicionar um novo arquivo ou alterar o conteúdo de um arquivo já existente. Esse comando tem dois meios diferentes de especificar o conteúdo do arquivo.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Formato de dados externos</dt>
<dd>
<p>O conteúdo dos dados do arquivo já foi repassado por um comando <code>blob</code> anterior. O "front-end" só precisa conectá-lo.</p>
<div class="literalblock">
<div class="content">
<pre>        'M' SP &lt;modo&gt; SP &lt;dataref&gt; SP &lt;caminho&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui, normalmente, <em>&lt;dataref&gt;</em> deve ser uma marcação de referência (<code>:</code><em>&lt;idnum&gt;</em>) definida por um comando <code>blob</code> anterior ou um SHA-1 completo com 40 bytes de um objeto blob do Git já existente. Se o <em>&lt;modo&gt;</em> for <code>040000</code>`, então <em>&lt;dataref&gt;</em> deve ser o SHA-1 completo com 40 bytes de um objeto de árvore Git existente ou um conjunto de marcação de referência com a opção <code>--import-marks</code>.</p>
</div>
</dd>
<dt class="hdlist1">Formato de dados em linha</dt>
<dd>
<p>O conteúdo de dados do arquivo ainda não foi fornecido. O front-end deseja fornecê-lo como parte deste comando de alteração.</p>
<div class="literalblock">
<div class="content">
<pre>        'M' SP &lt;modo&gt; SP 'inline' SP &lt;caminho&gt; LF
        dado</pre>
</div>
</div>
<div class="paragraph">
<p>Veja abaixo uma descrição detalhada do comando <code>data</code>.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Em ambos os formatos, o <em>&lt;modo&gt;</em> é o tipo de entrada do arquivo, especificado em octal. O Git é compatível apenas com os seguintes modos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>100644</code> ou <code>644</code>: Um arquivo normal (not-executable). A maioria dos arquivos na maioria dos projetos usa este modo. Na dúvida, é disso que você precisa.</p>
</li>
<li>
<p><code>100755</code> ou <code>755</code>: Um arquivo normal, porém executável.</p>
</li>
<li>
<p><code>120000</code>: um link simbólico, o conteúdo do arquivo será o destino do link.</p>
</li>
<li>
<p><code>160000</code>: Um gitlink SHA-1 do objeto referindo-se a um commit em outro repositório. Os links Git podem ser especificados ou pelo SHA ou por meio de uma marcação do commit. Eles são utilizados para implementar os submódulos.</p>
</li>
<li>
<p><code>040000</code>: Um subdiretório. Os subdiretórios só podem ser especificados por SHA ou através de uma marcação da árvore definida com a opção <code>--import-marks</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Nos dois formatos o <em>&lt;caminho&gt;</em> é o caminho completo do arquivo a ser adicionado (caso ainda não exista) ou modificado (caso já exista).</p>
</div>
<div class="paragraph">
<p>A <em>&lt;path&gt;</em> can be written as unquoted bytes or a C-style quoted string.</p>
</div>
<div class="paragraph">
<p>When a <em>&lt;path&gt;</em> does not start with a double quote ("), it is an unquoted string and is parsed as literal bytes without any escape sequences. However, if the filename contains <code>LF</code> or starts with double quote, it cannot be represented as an unquoted string and must be quoted. Additionally, the source <em>&lt;path&gt;</em> in <code>filecopy</code> or <code>filerename</code> must be quoted if it contains SP.</p>
</div>
<div class="paragraph">
<p>When a <em>&lt;path&gt;</em> starts with a double quote ("), it is a C-style quoted string, where the complete filename is enclosed in a pair of double quotes and escape sequences are used. Certain characters must be escaped by preceding them with a backslash: <code>LF</code> is written as \n, backslash as \\, and double quote as \". Some characters may optionally be written with escape sequences: \a for bell, \b for backspace, \f for form feed, \n for line feed, \r for carriage return, \t for horizontal tab, and \v for vertical tab. Any byte can be written with 3-digit octal codes (e.g., \033). All filenames can be represented as quoted strings.</p>
</div>
<div class="paragraph">
<p>A <em>&lt;path&gt;</em> must use UNIX-style directory separators (forward slash <code>/</code>) and its value must be in canonical form. That is it must not:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>contém um componente de diretório vazio (<code>foo//bar</code> é inválido por exemplo),</p>
</li>
<li>
<p>termina com um separador de diretório (<code>foo/</code> é inválido por exemplo),</p>
</li>
<li>
<p>comece com um separador de diretório (<code>/foo</code> é inválido por exemplo),</p>
</li>
<li>
<p>tem o componente especial . ou .. (<code>foo/./bar</code> e <code>foo/</code><code>..</code><code>/bar</code> são inválidos por exemplo).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A raiz da árvore pode ser representada por uma cadeia de caracteres vazios como <em>&lt;caminho&gt;</em>.</p>
</div>
<div class="paragraph">
<p><em>&lt;path&gt;</em> cannot contain NUL, either literally or escaped as \000. It is recommended that <em>&lt;path&gt;</em> always be encoded using UTF-8.</p>
</div>
</div>
<div class="sect3">
<h4 id="_filedelete"><code>filedelete</code></h4>
<div class="paragraph">
<p>Incluído num comando <code>commit</code> para remover um arquivo ou excluir recursivamente um diretório inteiro do ramo. Se a remoção do arquivo ou diretório deixar seu diretório principal vazio, o diretório principal também será removido automaticamente. Isso é feito em cascata na árvore até que o primeiro diretório não vazio ou a raiz seja alcançada.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'D' SP &lt;caminho&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui o <em>&lt;caminho&gt;</em> é o caminho completo do arquivo ou subdiretório que será removido da ramificação. Consulte o <code>filemodify</code> acima para obter uma descrição detalhada do <em>&lt;caminho&gt;</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_filecopy"><code>filecopy</code></h4>
<div class="paragraph">
<p>Copia recursivamente um arquivo ou subdiretório existente para um local diferente dentro da ramificação. O arquivo ou diretório existente deve existir. Se o destino existir, ele será completamente substituído pelo conteúdo copiado da origem.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'C' SP &lt;caminho&gt; SP &lt;caminho&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui o primeiro <em>&lt;caminho&gt;</em> é o local de origem e o segundo <em>&lt;caminho&gt;</em> é o destino. Consulte <code>filemodify</code> acima para obter uma descrição detalhada de como o <em>&lt;caminho&gt;</em> se parece. Para usar um caminho de origem que contenha SP, o caminho deve ser citado.</p>
</div>
<div class="paragraph">
<p>Um comando <code>filecopy</code> entra em vigor imediatamente. Depois que o local de origem tenha sido copiado para o destino, quaisquer comandos futuros aplicados ao local de origem não afetarão o destino da cópia.</p>
</div>
</div>
<div class="sect3">
<h4 id="_filerename"><code>filerename</code></h4>
<div class="paragraph">
<p>Copia recursivamente cópias de um arquivo ou subdiretório existente para um local diferente dentro da ramificação. O arquivo ou diretório existente deve existir. Se o destino existir, ele será substituído pelo diretório de origem.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'R' SP &lt;caminho&gt; SP &lt;caminho&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui o primeiro <em>&lt;caminho&gt;</em> é o local de origem e o segundo <em>&lt;caminho&gt;</em> é o destino. Consulte <code>filemodify</code> acima para obter uma descrição detalhada de como o <em>&lt;caminho&gt;</em> se parece. Para usar um caminho de origem que contenha SP, o caminho deve ser citado.</p>
</div>
<div class="paragraph">
<p>Um comando <code>filerename</code> entra em vigor imediatamente. Depois que o local de origem tiver sido renomeado para o destino, todos os comandos futuros aplicados ao local de origem criarão novos arquivos nesse local e não afetarão o destino da renomeação.</p>
</div>
<div class="paragraph">
<p>Observe que um <code>filerename</code> é o mesmo que uma <code>filecopy</code> seguido de um <code>filedelete</code> do local da origem. Há uma pequena vantagem no desempenho no uso do <code>filerename</code>, mas a vantagem é tão pequena que nunca vale a pena tentar converter um par de exclusão/adição no material de origem numa renomeação para importação rápida. Esse comando <code>filerename</code> é fornecido apenas para simplificar os "frontends" que já têm informações de renomeação e não querem se preocupar em decompô-las numa <code>filecopy</code> seguida de um <code>filedelete</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_filedeleteall"><code>filedeleteall</code></h4>
<div class="paragraph">
<p>Incluído num comando <code>commit</code> para remover todos os arquivos (e também todos os diretórios) do ramo. Esse comando redefine a estrutura interna da ramificação para que não haja arquivos nela, permitindo que o "frontend" adicione posteriormente todos os arquivos interessantes do zero.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'deleteall' LF</pre>
</div>
</div>
<div class="paragraph">
<p>Este comando é extremamente útil caso o front-end não soiba (ou não quer saber) quais são os arquivos estão atualmente no ramo e, portanto, não conseguir gerar os comandos <code>filedelete</code> adequados para atualizar o conteúdo.</p>
</div>
<div class="paragraph">
<p>A emissão de um comando <code>filedeleteall</code> seguido do comando <code>filemodify</code> são necessários para definir que o conteúdo correto produzirá os mesmos resultados que apenas o envio dos comandos necessários <code>filemodify</code> e <code>filedelete</code>. A abordagem <code>filedeleteall</code> pode, no entanto, exigir que a importação rápida use um pouco mais de memória por ramificação ativo (menos de 1 MiB até mesmo para a maioria dos projetos grandes); portanto, os "front-ends" que podem obter facilmente apenas os caminhos afetados para um commit são incentivados a fazer isso.</p>
</div>
</div>
<div class="sect3">
<h4 id="_notemodify"><code>notemodify</code></h4>
<div class="paragraph">
<p>Incluído num comando <code>commit</code> <em>&lt;notes-ref&gt;</em> para adicionar uma nova nota anotando um <em>&lt;commit-ish&gt;</em> ou para alterar o conteúdo dessa anotação. Internamente, é semelhante ao <code>filemodify</code> <code>100644</code> no caminho <em>&lt;commit-ish&gt;</em> (talvez dividido em subdiretórios). Não é aconselhável usar nenhum outro comando para registrar na árvore <em>&lt;notes-ref&gt;</em>, exceto o <code>filedeleteall</code> para excluir todas as notas existentes nessa árvore. Este comando tem dois meios diferentes de especificar o conteúdo da nota.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Formato de dados externos</dt>
<dd>
<p>O conteúdo dos dados do arquivo já foi repassado anteriormente pelo comando <code>blob</code>. O "front-end" precisa apenas conectá-lo ao commit que deve ser anotado.</p>
<div class="literalblock">
<div class="content">
<pre>        'N' SP &lt;dataref&gt; SP &lt;commit-ish&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui o <em>&lt;dataref&gt;</em> pode ser uma referência de marcação (<code>:</code><em>&lt;idnum&gt;</em>) definida por um comando <code>blob</code> anterior ou um SHA-1 completo com 40 bytes de um objeto bolha já existente do Git.</p>
</div>
</dd>
<dt class="hdlist1">Formato de dados em linha</dt>
<dd>
<p>O conteúdo de dados do arquivo ainda não foi repassado. O front-end deseja fornecê-lo como parte deste comando de alteração.</p>
<div class="literalblock">
<div class="content">
<pre>        'N' SP 'inline' SP &lt;commit-ish&gt; LF
        dado</pre>
</div>
</div>
<div class="paragraph">
<p>Veja abaixo uma descrição detalhada do comando <code>data</code>.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Nos dois formatos, <em>&lt;commit-ish&gt;</em> é qualquer uma das expressões de especificação do commit também aceitos por <code>from</code> (veja acima).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mark"><code>mark</code></h3>
<div class="paragraph">
<p>Faz com que a importação rápida salve uma referência ao objeto atual, permitindo que o "front-end" recupere esse objeto num momento futuro, sem conhecer o seu SHA-1. Aqui, o objeto atual é o comando de criação de objeto onde o comando <code>mark</code> aparece. Isso pode ser <code>commit</code>, <code>tag</code> e <code>blob</code>, mas <code>commit</code> é o uso mais comum.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'mark' SP ':' &lt;idnum&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>Onde <em>&lt;idnum&gt;</em> é o número atribuído pelo "front-end" a esta marcação. O valor de <em>&lt;idnum&gt;</em> é expresso como um número inteiro decimal ASCII. O valor 0 é reservado e não pode ser usado como marcação. Apenas podem ser usados valores maiores ou iguais a 1 como marcações.</p>
</div>
<div class="paragraph">
<p>Novas marcações são criadas automaticamente. As marcas existentes podem ser movidas para outro objeto simplesmente reutilizando o mesmo <em>&lt;idnum&gt;</em> em outro comando <code>mark</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_original_oid"><code>original-oid</code></h3>
<div class="paragraph">
<p>Fornece o nome do objeto no sistema de controle da fonte original. A importação rápida simplesmente ignorará essa diretriz, porém, os processos de filtragem que operam e modificam o fluxo antes de alimentar a importação rápida podem usar estas informações</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'original-oid' SP &lt;identificador-do-objeto&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>onde <em>&lt;identificador-do-objeto&gt;</em> é qualquer cadeia de caracteres que não contenha LF.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tag"><code>tag</code></h3>
<div class="paragraph">
<p>Cria uma etiqueta anotada referente a um commit específico. Para criar etiquetas simples (não anotadas), consulte o comando <code>reset</code> abaixo.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'tag' SP &lt;nome&gt; LF
        mark?
        'from' SP &lt;commit-ish&gt; LF
        original-oid?
        'tagger' (SP &lt;nome&gt;)? SP LT &lt;e-mail&gt; GT SP &lt;quando&gt; LF
        data</pre>
</div>
</div>
<div class="paragraph">
<p>onde <em>&lt;nome&gt;</em> é o nome da tag a ser criada.</p>
</div>
<div class="paragraph">
<p>Os nomes das tags são prefixados automaticamente com <code>refs/tags/</code> quando armazenados no Git, portanto, a importação do símbolo do ramo CVS <code>RELENG-1_0-FINAL</code> usaria apenas <code>RELENG-1_0-FINAL</code> para <em>&lt;nome&gt;</em> e o <code>fast-import</code> irá escrever um <code>ref</code> correspondente como <code>refs/tags/RELENG-1_0-FINAL</code>.</p>
</div>
<div class="paragraph">
<p>O valor de <em>&lt;nome&gt;</em> deve ser uma referência de nome válido no Git e, portanto, pode conter barras. Como <code>LF</code> não é válido num <em>refname</em> do Git, aqui não há suporte para sintaxe de citação ou escape.</p>
</div>
<div class="paragraph">
<p>O comando <code>from</code> é o mesmo que no comando <code>commit</code>; veja acima para detalhes.</p>
</div>
<div class="paragraph">
<p>O comando <code>tagger</code> usa o mesmo formato que <code>committer</code> dentro de <code>commit</code>; veja novamente acima para obter detalhes.</p>
</div>
<div class="paragraph">
<p>O comando <code>data</code> que segue o <code>tagger</code> deve repassar a mensagem da etiqueta anotada (veja abaixo a sintaxe do comando <code>data</code>). Para importar uma mensagem vazia do commit, use dados com comprimento 0. As mensagens da etiqueta são de formato livre e não são interpretadas pelo Git. Atualmente, eles devem ser codificados em UTF-8, pois o "fast-import" não permite que outras codificações sejam definidas.</p>
</div>
<div class="paragraph">
<p>Não há suporte para a assinatura das etiquetas anotadas durante a importação a vindas da importação rápida. Tentar incluir a sua própria assinatura PGP/GPG não é recomendável, pois o "front-end" não tem acesso (fácil) ao conjunto completo de bytes que normalmente é incluído numa assinatura deste tipo. Se a assinatura for necessária, crie etiquetas simples a partir da importação rápida com <code>reset</code> e, em seguida, crie as versões anotadas dessas etiquetas off-line com o processo padrão do comando <em>git tag</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reset"><code>reset</code></h3>
<div class="paragraph">
<p>Cria (ou recria) o ramo nomeado, opcionalmente a partir de uma revisão específica. O comando <code>reset</code> permite que um "frontend" emita um novo comando <code>from</code> para uma ramificação já existente ou crie uma nova ramificação a partir de um commit existente sem criar um novo commit.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'reset' SP &lt;ref&gt; LF
        ('from' SP &lt;commit-ish&gt; LF)?
        LF?</pre>
</div>
</div>
<div class="paragraph">
<p>Para uma descrição detalhada sobre <em>&lt;ref&gt;</em> e <em>&lt;commit-ish&gt;</em> veja acima em <code>commit</code> e` from`.</p>
</div>
<div class="paragraph">
<p>O <code>LF</code> após o comando é opcional (costumava ser necessário).</p>
</div>
<div class="paragraph">
<p>O comando <code>reset</code> também pode ser usado para criar etiquetas simples (não anotadas). Por exemplo:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>reset refs/tags/938
from :938</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>criaria a tag <code>leve</code> <code>refs/tags/938</code> se referindo a qualquer marcação do commit <code>:938</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_blob"><code>blob</code></h3>
<div class="paragraph">
<p>Solicita a gravação de uma revisão de arquivo no pacote de arquivos. A revisão não está conectada a nenhum commit; essa conexão deve ser formada com um comando <code>commit</code> subsequente, referenciando a bolha por meio de uma marcação atribuída.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'blob' LF
        mark?
        original-oid?
        dado</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui o comando "mark" é opcional, pois alguns "front-ends" optaram por gerar o Git SHA-1 para a bolha por conta própria e alimentá-lo diretamente no <code>commit</code>. No entanto, isso geralmente dá mais trabalho do que vale a pena, pois as marcações tem baixo custo de armazenamento e são fáceis de usar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_data"><code>data</code></h3>
<div class="paragraph">
<p>Fornece dados brutos para importação rápida (visando a utilização como conteúdo da bolha/arquivo, mensagens dos commits ou as mensagens das etiquetas anotadas). Os dados podem ser fornecidos usando uma contagem exata de bytes ou delimitados com uma linha de terminação. Os "front-ends" reais destinados a conversões com qualidade de produção devem sempre usar o formato de contagem exata de bytes, pois ele é mais robusto e tem melhor desempenho. O formato delimitado foi criado principalmente para testar a importação rápida.</p>
</div>
<div class="paragraph">
<p>As linhas de comentário que aparecem na parte <em>&lt;raw&gt;</em> dos comandos <code>data</code> são sempre consideradas como parte do corpo dos dados e, portanto, nunca são ignorados pela importação rápida. Isso torna seguro importar qualquer conteúdo de arquivo/mensagem cujas linhas possam começar com #.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Formato exato de contagem de bytes</dt>
<dd>
<p>O front-end deve especificar a quantidade de bytes dos dados.</p>
<div class="literalblock">
<div class="content">
<pre>        'data' SP &lt;count&gt; LF
        &lt;raw&gt; LF?</pre>
</div>
</div>
<div class="paragraph">
<p>Onde <em>&lt;quantidade&gt;</em> é a quantidade exato de bytes que aparecem em <em>&lt;raw&gt;</em>. O valor de <em>&lt;contagem&gt;</em> é expresso como um número inteiro decimal ASCII. O <code>LF</code> em ambos os lados de <em>&lt;raw&gt;</em> não está incluído em <em>&lt;quantidade&gt;</em> e não será incluído nos dados importados.</p>
</div>
<div class="paragraph">
<p>O <code>LF</code> após <em>&lt;raw&gt;</em> é opcional (costumava ser necessário). A sua inclusão sempre facilita a depuração de um fluxo de importação rápida, pois o próximo comando sempre começa na coluna 0 da próxima linha, ainda que <em>&lt;raw&gt;</em> não termine com um <code>LF</code>.</p>
</div>
</dd>
<dt class="hdlist1">Formato delimitado</dt>
<dd>
<p>Uma string de delimitadores é usada para marcar o fim dos dados. A importação rápida calculará o comprimento procurando pelo delimitador. Esse formato é útil principalmente para testes e não é recomendado para dados reais.</p>
<div class="literalblock">
<div class="content">
<pre>        'data' SP '&lt;&lt;' &lt;delim&gt; LF
        &lt;raw&gt; LF
        &lt;delim&gt; LF
        LF?</pre>
</div>
</div>
<div class="paragraph">
<p>Onde <em>&lt;delim&gt;</em> é a string escolhida de delimitadores. A string <em>&lt;delim&gt;</em> não deve aparecer numa linha sozinha dentro de <em>&lt;raw&gt;</em>, caso contrário, a importação rápida pensará que os dados terminam mais cedo do que deveriam. O <code>LF</code> imediatamente após o <em>&lt;raw&gt;</em> faz parte do <em>&lt;raw&gt;</em>. Esta é uma das limitações do formato delimitado, pois é impossível fornecer um bloco de dados que não tenha um <code>LF</code> como último byte.</p>
</div>
<div class="paragraph">
<p>O <code>LF</code> após <em>&lt;delim&gt;</em> <code>LF</code> é opcional (costumava ser necessário).</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_alias"><code>alias</code></h3>
<div class="paragraph">
<p>Registre que uma marcação se refere a um determinado objeto sem criar primeiro nenhum novo objeto.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'alias' LF
        mark
        'to' SP &lt;commit-ish&gt; LF
        LF?</pre>
</div>
</div>
<div class="paragraph">
<p>Para uma descrição detalhada do <em>&lt;commit-ish&gt;</em> veja acima em <code>from</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_checkpoint"><code>checkpoint</code></h3>
<div class="paragraph">
<p>Impõem o <code>fast-import</code> a fechar o arquivo de pacote atual, iniciar um novo e salvar todas os <code>refs</code>, tags e marcas das ramificações atuais.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'checkpoint' LF
        LF?</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que a importação rápida alterna automaticamente os pacote de arquivos quando o pacote de arquivos atual atinge <code>--max-pack-size</code> ou 4 GiB, o que for menor. Durante uma troca automática do pacote de arquivos, a importação rápida não atualiza as referências, as etiquetas ou as marcações do ramo.</p>
</div>
<div class="paragraph">
<p>Como um <code>checkpoint</code> pode exigir uma quantidade significativa de tempo de CPU e E/S de disco (para calcular a soma de verificação SHA-1 do pacote geral, gerar o arquivo do índice correspondente e atualizar as <code>refs</code>), pode levar vários minutos para um único comando <code>checkpoint</code> para concluir.</p>
</div>
<div class="paragraph">
<p>Os "front-ends" podem optar por emitir pontos de controle durante importações extremamente grandes e de longa duração, ou quando precisarem permitir que outro processo do Git acesse um ramo. No entanto, como um repositório "Subversion" com 30 GiB pode ser carregado no Git através da importação rápida em cerca de 3 horas, o ponto de verificação explícito pode não ser necessário.</p>
</div>
<div class="paragraph">
<p>O <code>LF</code> após o comando é opcional (costumava ser necessário).</p>
</div>
</div>
<div class="sect2">
<h3 id="_progress"><code>progress</code></h3>
<div class="paragraph">
<p>Faz com que a importação rápida imprima toda a linha <code>progress</code> sem alterações em seu canal de saída predefinida (descritor de arquivo 1) quando o comando é processado a partir do fluxo de entrada. O comando não tem impacto sobre a importação atual ou sobre qualquer condição interna da importação rápida.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'progress' SP &lt;any&gt; LF
        LF?</pre>
</div>
</div>
<div class="paragraph">
<p>A parte <em>&lt;qualquer&gt;</em> do comando pode conter qualquer sequência de bytes que não contenha um <code>LF</code>. O <code>LF</code> após o comando é opcional. Os invocadores podem querer processar a saída através de uma ferramenta como <code>sed</code> para remover a parte inicial da linha, por exemplo:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>frontend | git fast-import | sed 's/^progress //'</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A colocação de um comando <code>progress</code> imediatamente após um <code>checkpoint</code> informará ao leitor quando o <code>checkpoint</code> seja concluído e ele poderá acessar com segurança os <code>refs</code> que o <code>fast-import</code> atualizaram.</p>
</div>
</div>
<div class="sect2">
<h3 id="_get_mark"><code>get-mark</code></h3>
<div class="paragraph">
<p>Faz com que o <code>fast-import</code> imprima o SHA-1 correspondente a uma marcação em <code>stdout</code> ou ao descritor de arquivo previamente organizado com o argumento <code>--cat-blob-fd</code>. Caso contrário, o comando não tem impacto na importação atual; seu objetivo é recuperar o SHA-1s que commits posteriores podem querer se referir em suas mensagens de commit.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'get-mark' SP ':' &lt;idnum&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>Consulte &#8220;RESPOSTAS AOS COMANDOS&#8221; abaixo para obter detalhes sobre como ler esta saída com segurança.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cat_blob"><code>cat-blob</code></h3>
<div class="paragraph">
<p>Faz com que a importação rápida grave uma bolha num descritor de arquivo previamente organizado com a opção <code>--cat-blob-fd</code>. O comando não tem impacto sobre a importação atual; o seu principal objetivo é recuperar as bolhas que podem estar na memória da importação rápida, mas que não podem ser acessadas pelo repositório de destino.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'cat-blob' SP &lt;dataref&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>O <em>&lt;dataref&gt;</em> pode ser uma marcação de referência (<code>:</code><em>&lt;idnum&gt;</em>) definida anteriormente ou um SHA-1 completo com 40 bytes de uma bolha Git pré-existente ou pronta para ser gravada.</p>
</div>
<div class="paragraph">
<p>A saída usa o mesmo formato que <code>git</code> <code>cat-file</code> <code>--batch</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>&lt;sha1&gt; SP 'blob' SP &lt;tamanho&gt; LF
&lt;contents&gt; LF</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Este comando também pode ser usado quando um comando <code>filemodify</code> aparecer, permitindo que ele seja usado no meio de um commit. Para um <code>filemodify</code> que usa um comando em linha, ele também pode aparecer logo antes da opção <code>data</code>.</p>
</div>
<div class="paragraph">
<p>Consulte &#8220;RESPOSTAS AOS COMANDOS&#8221; abaixo para obter detalhes sobre como ler esta saída com segurança.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ls"><code>ls</code></h3>
<div class="paragraph">
<p>Exibe informações sobre o objeto num caminho para num descritor de arquivo previamente organizado com a opção <code>--cat-blob-fd</code>. Isso permite a exibição de uma bolha ativa do commit (com <code>cat-blob</code>) ou a cópia de uma bolha ou de uma árvore de um commit anterior para que seja usada no atual (com <code>filemodify</code>).</p>
</div>
<div class="paragraph">
<p>O comando <code>ls</code> também pode ser usado onde uma diretiva <code>filemodify</code> possa aparecer, permitindo que ela seja usada no meio de um commit.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Lendo a partir do commit ativo</dt>
<dd>
<p>Este formulário só pode ser usado no meio de um <code>commit</code>. O caminho nomeia uma entrada de diretório no commit ativo da importação rápida. Neste caso, o caminho deve ser citado.</p>
<div class="literalblock">
<div class="content">
<pre>        'ls' SP &lt;caminho&gt; LF</pre>
</div>
</div>
</dd>
<dt class="hdlist1">Lendo de uma árvore nomeada</dt>
<dd>
<p>O <em>&lt;dataref&gt;</em> pode ser uma referência de marcação (<code>:</code><em>&lt;idnum&gt;</em>) ou o SHA-1 completo com 40 bytes de uma etiqueta, de um commit ou de um objeto pré-existente na árvore do Git, ou aguardando para ser gravado. O caminho é relativo ao cume da árvore denominada por <em>&lt;dataref&gt;</em>.</p>
<div class="literalblock">
<div class="content">
<pre>        'ls' SP &lt;dataref&gt; SP &lt;caminho&gt; LF</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Consulte <code>filemodify</code> acima para uma descrição detalhada de <em>&lt;caminho&gt;</em>.</p>
</div>
<div class="paragraph">
<p>A saída usa o mesmo formato que <code>git</code> <code>ls-tree</code> &lt;árvore&gt; <code>--</code> <em>&lt;caminho&gt;</em>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>&lt;mode&gt; SP ('blob' | 'tree' | 'commit') SP &lt;dataref&gt; HT &lt;caminho&gt; LF</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>O &lt;dataref&gt; representa o objeto bolha, árvore ou commit no &lt;caminho&gt; e pode ser utilizado posteriormente nos comandos <code>get-mark</code>, <code>cat-blob</code>, <code>filemodify</code> ou <code>ls</code>.</p>
</div>
<div class="paragraph">
<p>Caso não haja um arquivo ou subárvore nesse caminho, o <code>git</code> <code>fast-import</code> o reportará</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>missing SP &lt;caminho&gt; LF</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Consulte &#8220;RESPOSTAS AOS COMANDOS&#8221; abaixo para obter detalhes sobre como ler esta saída com segurança.</p>
</div>
</div>
<div class="sect2">
<h3 id="_feature"><code>feature</code></h3>
<div class="paragraph">
<p>Exija que a importação rápida ofereça suporte ao recurso especificado ou o anule.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        'feature' SP &lt;característica&gt; ('=' &lt;argumento&gt;)? LF</pre>
</div>
</div>
<div class="paragraph">
<p>A parte &lt;característica&gt; do comando pode ser qualquer um dos seguintes:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">date-format</dt>
<dt class="hdlist1">export-marks</dt>
<dt class="hdlist1">relative-marks</dt>
<dt class="hdlist1">no-relative-marks</dt>
<dt class="hdlist1">force</dt>
<dd>
<p>Aja como se a opção da linha de comando coincida com um <code>--</code> inicial fosse passada na linha de comando (consulte OPÇÕES, acima).</p>
</dd>
<dt class="hdlist1">import-marks</dt>
<dt class="hdlist1">import-marks-if-exists</dt>
<dd>
<p>Como --import-marks, exceto em três aspectos: primeiro, apenas um comando "feature import-marks" ou "feature import-marks-if-exists" é permitido por fluxo; segundo, uma opção de linha de comando <code>--import-marks=</code> ou <code>--import-marks-if-exists</code> substitui qualquer um desses comandos "feature" no fluxo; terceiro, "feature import-marks-if-exists", como uma opção de linha de comando correspondente, ignora silenciosamente um arquivo inexistente.</p>
</dd>
<dt class="hdlist1">get-mark</dt>
<dt class="hdlist1">cat-blob</dt>
<dt class="hdlist1">ls</dt>
<dd>
<p>Exige que o "backend" seja compatível com os comandos <em>get-mark</em>, <em>cat-blob</em> ou <em>ls</em>, respectivamente. As versões da importação rápida que não sejam compatíveis com o comando especificado serão encerrados com uma mensagem indicando isso. Isso permite que o erro de importação seja corrigido antecipadamente com uma mensagem clara, evitando perder tempo na parte inicial de uma importação antes que o comando não compatível seja detectado.</p>
</dd>
<dt class="hdlist1">notes</dt>
<dd>
<p>Requer que o backend ofereça suporte ao subcomando "notemodify" (N) para o comando "commit". As versões da importação rápida que não sejam compatíveis com anotações serão encerradas com uma mensagem indicando isso.</p>
</dd>
<dt class="hdlist1">done</dt>
<dd>
<p>Ocorrerá um erro no caso de um fluxo seja encerrado sem um comando "done". Sem este recurso, os erros que fazem com que o frontend termine abruptamente num ponto conveniente do fluxo podem não ser detectados. Isso pode acontecer se, por exemplo, um frontend de importação for encerrado no meio da operação sem emitir um "SIGTERM" ou "SIGKILL" em sua instância subordinada do comando <code>git</code> <code>fast-import</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_option"><code>option</code></h3>
<div class="paragraph">
<p>Processa a opção especificada para que o comando <code>git</code> <code>fast-import</code> se comporte de uma forma que atenda às necessidades do frontend. Observe que as opções especificadas pelo frontend são substituídas por quaisquer opções que o usuário possa definir para o próprio comando <code>git</code> <code>fast-import</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    'option' SP &lt;opção&gt; LF</pre>
</div>
</div>
<div class="paragraph">
<p>A parte &lt;opção&gt; do comando pode conter qualquer uma das opções listadas na seção OPTIONS que não alteram a semântica de importação, sem o <code>--</code> principal e são tratadas da mesma maneira.</p>
</div>
<div class="paragraph">
<p>Os comandos de opção devem ser os primeiros comandos na entrada (sem contar os comandos de recurso), para fornecer um comando de opção após um erro que não seja de opção.</p>
</div>
<div class="paragraph">
<p>As seguintes opções de linha de comando alteram a semântica de importação e, portanto, não podem ser passadas como opção:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>date-format</p>
</li>
<li>
<p>import-marks</p>
</li>
<li>
<p>export-marks</p>
</li>
<li>
<p>cat-blob-fd</p>
</li>
<li>
<p>force</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_done"><code>done</code></h3>
<div class="paragraph">
<p>Se o recurso <code>done</code> não estiver em uso, será tratado como se um <code>EOF</code> tivesse sido lido. Isso pode ser usado para dizer à importação rápida para encerrar mais cedo.</p>
</div>
<div class="paragraph">
<p>Caso a opção de linha de comando <code>--done</code> ou o comando <code>feature</code> <code>done</code> estiver em uso, o comando <code>done</code> é obrigatório e marca o final do fluxo.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_respostas_aos_comandos">RESPOSTAS AOS COMANDOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os novos objetos gravados pela importação rápida não estão disponíveis imediatamente. A maioria dos comandos de importação rápida não tem efeito visível até o próximo ponto de verificação "checkpoint" (ou conclusão). Ao simplificar o agendamento, O frontend pode enviar comandos para preencher o canal de entrada da importação rápida sem se preocupar com a rapidez com que eles terão efeito, o que melhora o desempenho.</p>
</div>
<div class="paragraph">
<p>No entanto, para alguns frontends, é útil poder ler dados do repositório atual à medida que ele estão sendo atualizados (quando o material de origem descreve objetos em termos de correções que serão aplicados nos objetos importados anteriormente por exemplo). Isso pode ser feito conectando o frontend e a importação rápida através de tubos bidirecionais:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>mkfifo fast-import-output
frontend &lt;fast-import-output |
git fast-import &gt;fast-import-output</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Um front-end configurado desta maneira pode usar os comandos <code>progress</code>, <code>get-mark</code>, <code>ls</code> e <code>cat-blob</code> para ler as informações das importações em andamento.</p>
</div>
<div class="paragraph">
<p>Para evitar um impasse, tais front-ends devem consumir completamente quaisquer saída pendente que for gerada com <code>progress</code>, <code>ls</code>, <code>get-mark</code> e <code>cat-blob</code> antes de realizar as escritas que o <code>fast-import</code> possa bloquear.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_relatórios_de_crash">RELATÓRIOS DE CRASH</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Se a importação rápida receber uma entrada inválida, ele será encerrado com uma condição de encerramento diferente de zero e criará um relatório de falha no nível superior do repositório Git para o qual estava importando. Os relatórios de falhas contêm um instantâneo do estado interno de importação rápida, bem como os comandos mais recentes que resultaram na falha.</p>
</div>
<div class="paragraph">
<p>Todos os comandos recentes (incluindo os comentários no fluxo, as alterações dos arquivos e os comandos de progresso) são mostrados no histórico de comandos dentro do relatório de falhas, mas os dados brutos dos arquivos e as mensagens do commit são excluídos do relatório de falhas. Esta exclusão economiza espaço no arquivo de relatório e reduz a quantidade de memória intermédia que o comando <code>fast-import</code> deve realizar durante a execução.</p>
</div>
<div class="paragraph">
<p>Após a conclusão do registro do relatório de falha, o <code>fast-import</code> fechará o pacote de arquivo atual e exportará a tabela de marcações. Isso permite que o desenvolvedor do frontend inspecione a condição do repositório e retome a importação a partir do ponto onde houve falha. As ramificações e as etiquetas alteradas não são atualizadas durante uma falha, pois a importação não foi concluída com êxito. As informações de ramificação e as etiquetas podem ser encontradas no relatório de falha e devem ser aplicadas manualmente caso a atualização seja necessária.</p>
</div>
<div class="paragraph">
<p>Um exemplo de falha:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>$ cat &gt;in &lt;&lt;END_OF_INPUT
# my very first test commit
commit refs/heads/master
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
# who is that guy anyway?
data &lt;&lt;EOF
this is my commit
EOF
M 644 inline .gitignore
data &lt;&lt;EOF
.gitignore
EOF
M 777 inline bob
END_OF_INPUT</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git fast-import &lt;in
fatal: Corrupt mode: M 777 inline bob
fast-import: dumping crash report to .git/fast_import_crash_8434</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat .git/fast_import_crash_8434
fast-import crash report:
    fast-import process: 8434
    parent process     : 1391
    at Sat Sep 1 00:58:12 2007</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>fatal: Corrupt mode: M 777 inline bob</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Most Recent Commands Before Crash
---------------------------------
  # my very first test commit
  commit refs/heads/master
  committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
  # who is that guy anyway?
  data &lt;&lt;EOF
  M 644 inline .gitignore
  data &lt;&lt;EOF
* M 777 inline bob</pre>
</div>
</div>
<div class="paragraph">
<p>Ramo Ativo LRU</p>
</div>
<div class="listingblock">
<div class="content">
<pre>active_branches = 1 cur, 5 max

          pos clock name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           1)      0 refs/heads/master

Inactive Branches</pre>
</div>
</div>
<div class="paragraph">
<p>refs/heads/master:
status      : active loaded dirty
tip commit  : 0000000000000000000000000000000000000000
old tree    : 0000000000000000000000000000000000000000
cur tree    : 0000000000000000000000000000000000000000
commit clock: 0
last pack   :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>------------------- END OF CRASH REPORT</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dicas_e_truques">DICAS E TRUQUES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As dicas e truques a seguir foram coletadas de vários usuários do <code>fast-import</code> e são oferecidas aqui apenas como sugestões.</p>
</div>
<div class="sect2">
<h3 id="_utilize_uma_marcação_por_commit">Utilize uma Marcação por Commit</h3>
<div class="paragraph">
<p>Ao fazer uma conversão do repositório, use uma marcação exclusiva por commit (<code>mark</code> <code>:</code><em>&lt;n&gt;</em>) e use a opção <code>--export-marks</code> na linha de comando. O comando <code>fast-import</code> fará o despejo de um arquivo que lista todas as marcações e o objeto SHA-1 do Git que lhes corresponda. Se o frontend puder vincular as marcações ao repositório de origem, será fácil verificar a precisão e a integridade da importação comparando cada commit do Git com a revisão de origem correspondente.</p>
</div>
<div class="paragraph">
<p>Vindo de um sistema como o "Perforce" ou o "Subversion", isso deve ser bastante simples, pois a marcação do <code>fast-import</code> também pode ser o número do conjunto de alterações do "Perforce" ou o número da revisão do "Subversion".</p>
</div>
</div>
<div class="sect2">
<h3 id="_ir_livremente_em_torno_dos_ramos">Ir Livremente em Torno dos Ramos</h3>
<div class="paragraph">
<p>Não se preocupe em tentar otimizar o frontend para se ater a um ramo de cada vez durante uma importação. Embora isso possa ser um pouco mais rápido para a importação rápida, tende a aumentar consideravelmente a complexidade do código do frontend.</p>
</div>
<div class="paragraph">
<p>O LRU do ramo incorporado ao <code>fast-import</code> tende a se comportar muito bem e o custo de ativar uma ramo inativo é tão baixo que o movimento entre os ramos praticamente não tem impacto no desempenho da importação.</p>
</div>
</div>
<div class="sect2">
<h3 id="_manipulando_renomeações">Manipulando Renomeações</h3>
<div class="paragraph">
<p>Ao importar um arquivo ou diretório renomeado, basta excluir o(s) nome(s) antigo(s) e alterar o(s) novo(s) nome(s) durante o commit correspondente. O Git realiza a detecção de renomeação após o fato, em vez de fazê-lo explicitamente durante um commit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_utilizando_ramificações_para_a_correção_das_tags">Utilizando Ramificações para a Correção das Tags</h3>
<div class="paragraph">
<p>Alguns outros sistemas SCM permitem que o usuário crie uma etiqueta a partir de vários arquivos que não sejam do mesmo commit ou de um conjunto de alterações. Ou para criar etiquetas que sejam um subconjunto dos arquivos disponíveis no repositório.</p>
</div>
<div class="paragraph">
<p>É impossível importar estas etiquetas como estão no Git sem fazer pelo menos um commit que "corrija" os arquivos para que então correspondam ao conteúdo da etiqueta. Use o comando <code>reset</code> do <code>fast-import</code> para redefinir um ramo fictício fora do seu espaço normal de ramificações para o commit base da etiqueta, depois faça um ou mais commits para correção de arquivos e, finalmente, marque a ramificação fantasia.</p>
</div>
<div class="paragraph">
<p>Por exemplo, como todas as ramificações normais são armazenadas em <code>refs/heads/</code>, nomeie a etiqueta da ramificação de correção como <code>TAG_FIXUP</code>. Desta maneira, é impossível que o ramo de correção usado pelo importador tenha conflitos no espaço de nome com ramos reais que foram importados da fonte (o nome <code>TAG_FIXUP</code> não é <code>refs/heads/TAG_FIXUP</code>).</p>
</div>
<div class="paragraph">
<p>Ao fazer o commit com as correções, considere o uso de <code>merge</code> para conectar o(s) commit(s) que está(ão) fornecendo revisões dos arquivos ao ramo com as correções. Isso permitirá que ferramentas como o <em>git blame</em> rastreiem o histórico real dos commits e anotem corretamente os arquivos de origem.</p>
</div>
<div class="paragraph">
<p>Quando o <code>fast-import</code> encerrar, o front-end precisará executar o comando <code>rm</code> <code>.git/TAG_FIXUP</code> para remover a ramificação fantasia.</p>
</div>
</div>
<div class="sect2">
<h3 id="_importe_agora_reembale_depois">Importe Agora, Reembale Depois</h3>
<div class="paragraph">
<p>Assim que o comando <code>fast-import</code> for concluído, o repositório Git estará completamente válido e pronto para uso. Normalmente, isso leva muito pouco tempo, mesmo em projetos consideravelmente grandes (com mais de 100.000 commits).</p>
</div>
<div class="paragraph">
<p>No entanto, é necessário reempacotar o repositório para melhorar a localidade dos dados e o desempenho do acesso. Isso também pode levar horas em projetos extremamente grandes (especialmente se for usado o parâmetro <code>-f</code> e uma grande janela <code>--window</code>). Como o reempacotamento é seguro para ser executado junto com os leitores e os escritores, execute o reempacotamento em segundo plano e deixe-o ser concluído quando acabar. Não há razão para esperar a exploração do seu novo projeto Git!</p>
</div>
<div class="paragraph">
<p>Se você optar por esperar o reempacotamento, não tente executar "benchmarks" ou testes de desempenho até a conclusão do reempacotamento. A importação rápida gera pacotes com arquivos abaixo do ideal que nunca são vistos em situações reais de uso.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reempacotando_dados_históricos">Reempacotando Dados Históricos</h3>
<div class="paragraph">
<p>Se estiver reempacotando e importando dados muito antigos (mais antigos que o último ano por exemplo), considere gastar algum tempo extra de CPU e usar a opção <code>--window=50</code> (ou mais) ao executar o comando <em>git repack</em>. Vai demorar mais, contudo, produzirá pacote de arquivos menores. Você só precisa se esforçar uma vez, e todos os usuários do seu projeto se beneficiarão de um repositório menor.</p>
</div>
</div>
<div class="sect2">
<h3 id="_incluir_algumas_mensagens_de_progresso">Incluir Algumas Mensagens de Progresso</h3>
<div class="paragraph">
<p>De vez em quando, faça com que o seu frontend emita uma mensagem de progresso <code>progress</code> para o comando <code>fast-import</code>. O conteúdo das mensagens é totalmente livre, portanto, uma sugestão seria exibir o mês e o ano atual sempre que a data do commit atual passar para o mês seguinte. Os seus usuários se sentirão melhor sabendo quanto do fluxo de dados foi processado.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_otimização_dos_pacotes">OTIMIZAÇÃO DOS PACOTES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ao empacotar uma bolha, o <code>fast-import</code> sempre tenta delatar a última bolha gravada. A menos que seja especificamente organizado pelo frontend, provavelmente não será uma versão anterior do mesmo arquivo, portanto, o delta gerado não será o menor possível. O pacote de arquivos resultante será compactado, mas não será o ideal.</p>
</div>
<div class="paragraph">
<p>Os frontends que têm acesso eficiente a todas as revisões de um único arquivo (a leitura de um arquivo RCS/CVS ,v por exemplo) podem optar por fornecer todas as revisões desse arquivo como uma sequência de comandos <code>blob</code> consecutivos. Isso permite que a importação rápida delitifique as diferentes revisões de arquivos entre si, economizando espaço no pacote de arquivo final. As marcações de identificação podem ser usadas para identificar posteriormente as revisões individuais dos arquivos durante uma sequência de comandos <code>commit</code>.</p>
</div>
<div class="paragraph">
<p>O(s) pacote(s) de arquivo(s) criado(s) pelo <code>fast-import</code> não incentiva(m) bons padrões de acesso ao disco. Isso é causado pelo <code>fast-import</code> que escreve os dados na ordem em que são recebidos na entrada predefinida, enquanto o Git normalmente organiza os dados dentro dos pacote de arquivos para fazer com que os dados mais recentes (cume atual) apareçam antes dos dados históricos. O Git também agrupa os commits, acelerando a passagem da revisão através de uma melhor localização do cache.</p>
</div>
<div class="paragraph">
<p>Por esse motivo, é altamente recomendável que os usuários reempacotem o repositório com o comando <code>git</code> <code>repack</code> <code>-a</code> <code>-d</code> após a conclusão do <code>fast-import</code>, permitindo que o Git reorganize os pacote de arquivos visando um acesso mais rápido aos dados. Se os deltas das bolhas estiverem abaixo do ideal (veja acima), adicione também a opção <code>-f</code> para impor que seja feito uma recomputação de todos os deltas visando reduzir significativamente o tamanho final do pacote de arquivos (algo em torno de 30-50% menor pode ser bastante comum).</p>
</div>
<div class="paragraph">
<p>Em vez de executar o <code>git</code> <code>repack</code>, é possível também executar o <code>git</code> <code>gc</code> <code>--aggressive</code>, que também otimizará outras coisas após uma importação (refazer os pacotes refs soltos por exemplo). Como observado na seção "AGGRESSIVE" no <a href="git-gc.html">git-gc(1)</a> a opção <code>--aggressive</code> encontrará os novos deltas com a opção <code>-f</code> para <a href="git-repack.html">git-repack(1)</a>. Pelas razões descritas acima, a utilização da opção <code>--aggressive</code> após uma importação rápida, este é um dos poucos casos em que se sabe que vale a pena ser feito.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_utilização_de_memória">UTILIZAÇÃO DE MEMÓRIA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Há vários fatores que afetam a quantidade de memória que o <code>fast-import</code> requer para realizar uma importação. Assim como as seções críticas do núcleo do Git, o <code>fast-import</code> usa os seus próprios alocadores de memória para amortizar qualquer sobrecarga associada ao malloc. Na prática, o <code>fast-import</code> tende a amortizar qualquer sobrecarga de malloc para 0, devido ao uso de grandes alocações de blocos.</p>
</div>
<div class="sect2">
<h3 id="_por_objeto">por objeto</h3>
<div class="paragraph">
<p>O <code>fast-import</code> mantém uma estrutura na memória para cada objeto registrado nessa execução. Num sistema com 32 bits, a estrutura é de 32 bytes; num sistema com 64 bits, a estrutura é de 40 bytes (devido ao tamanho maior do ponteiro). Os objetos da tabela não são desalocados até a conclusão do <code>fast-import</code>. A importação de 2 milhões de objetos num sistema com 32 bits exigirá aproximadamente 64 MiB de memória.</p>
</div>
<div class="paragraph">
<p>A tabela de objetos é, na verdade, uma tabela hash com a chave no nome do objeto (o SHA-1 exclusivo). Essa configuração de armazenamento permite que o <code>fast-import</code> reutilize um objeto já existente ou que já tenha sido gravado e evite gravar duplicatas no pacote de arquivos que for gerado. As bolhas duplicadas são surpreendentemente comuns numa importação, geralmente devido a mesclas das ramificações na origem.</p>
</div>
</div>
<div class="sect2">
<h3 id="_por_marcação">por marcação</h3>
<div class="paragraph">
<p>As marcações são armazenadas numa matriz esparsa, usando 1 ponteiro (4 bytes ou 8 bytes, dependendo do tamanho do ponteiro) por marcação. Embora a matriz seja esparsa, os frontends ainda são fortemente incentivados a usar marcações entre 1 e n, onde n é o número total de marcações necessárias para essa importação.</p>
</div>
</div>
<div class="sect2">
<h3 id="_por_ramo">por ramo</h3>
<div class="paragraph">
<p>As ramificações são classificadas como ativa e inativa. O uso de memória das duas classes é consideravelmente diferente.</p>
</div>
<div class="paragraph">
<p>As ramificações inativas são armazenadas numa estrutura que usa 96 ou 120 bytes (nos sistemas com 32 bits ou 64 bits, respectivamente), mais o comprimento do nome da ramificação (normalmente abaixo de 200 bytes), por ramificação. O <code>fast-import</code> processa facilmente até 10.000 ramificações inativas usando menos de 2 MiB de memória.</p>
</div>
<div class="paragraph">
<p>Os ramos ativos têm a mesma sobrecarga dos ramos inativos, mas também contêm cópias de todas as árvores que foram alteradas recentemente neste ramo. Se a subárvore <code>include</code> não tiver sido alterada desde que a ramificação se tornou ativa, o seu conteúdo não será carregado na memória, mas se a subárvore <code>src</code> tiver sido alterada por um commit desde que a ramificação se tornou ativa, o seu conteúdo será carregado na memória.</p>
</div>
<div class="paragraph">
<p>À medida que as ramificações ativas armazenam metadados sobre os arquivos existentes nessa ramificação, o tamanho do armazenamento na memória pode aumentar consideravelmente (veja abaixo).</p>
</div>
<div class="paragraph">
<p>O <code>fast-import</code> move automaticamente as ramificações ativas para a condição inativa com base num algoritmo simples de uso menos recente. A cadeia LRU é atualizada em cada comando <code>commit</code>. A quantidade máxima de ramificações ativas pode ser aumentada ou diminuída na linha de comando com <code>--active-branches=</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_por_árvore_ativa">por árvore ativa</h3>
<div class="paragraph">
<p>As árvores (também conhecidas como diretórios) usam apenas 12 bytes de memória além da memória necessária para as suas respectivas inserções (consulte &#8220;por arquivo ativo&#8221; abaixo). O custo de uma árvore é praticamente zero, pois a sua sobrecarga é amortizada pelas entradas individuais do arquivo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_por_entrada_de_arquivo_ativa">por entrada de arquivo ativa</h3>
<div class="paragraph">
<p>Os arquivos (e os ponteiros para as subárvores) dentro das árvores ativas precisam de 52 ou 64 bytes (nas plataformas com 32/64 bits) por entrada. Para economizar espaço, os nomes dos arquivos e árvores são agrupados numa tabela de strings comum, o que permite que o nome do arquivo &#8220;Makefile&#8221; use apenas 16 bytes (após incluir a sobreposição do cabeçalho da string), independentemente da quantidade de vezes que isso ocorra no projeto.</p>
</div>
<div class="paragraph">
<p>O LRU do ramo ativo, quando associado ao conjunto da cadeia de caracteres do nome do arquivo e ao carregamento lento das subárvores, permite que a eficiência da importação rápida dos projetos com mais de 2.000 ramificações e mais de 45.114 arquivos num espaço de memória muito limitado (menos de 2,7 MiB por ramo ativo).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sinais">SINAIS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O envio de <strong>SIGUSR1</strong> para o comando <em>git fast-import</em> encerra antecipadamente o processo do pacote de arquivos atual, simulando um comando <code>checkpoint</code>. O operador impaciente pode usar esse recurso para ver os objetos e as referências de uma importação em andamento, ao custo de algum tempo de execução adicional e uma compactação pior.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração">CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Tudo abaixo desta linha nesta seção, está seletivamente incluído na documentação <a href="git-config.html">git-config(1)</a>. O conteúdo é o mesmo que é encontrado ali:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in git-fast-import.adoc - include::config/fastimport.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também">VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="git-fast-export.html">git-fast-export(1)</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git">GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href="git.html">git(1)</a></p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-03-23 12:03:41 +0100
</div>
</div>
</body>
</html>