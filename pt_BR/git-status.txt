git-status(1)
=============

NOME
----
git-status - Exibe o a condição da árvore de trabalho


SINOPSE
-------
[verse]
'git status' [<opções>...] [--] [<pathspec>...]

DESCRIÇÃO
---------
Exibe os caminhos que têm diferenças entre o arquivo do índice e o commit
atual no `HEAD`, os caminhos que têm diferenças entre a árvore de trabalho e
o arquivo do índice, os caminhos na árvore de trabalho que não são
rastreados pelo Git (e não foram ignorados pelo linkgit:gitignore[5]). O
primeiro é o que você _confirmaria_ executando o comando `git commit`; o
segundo e o terceiro são os que você pode confirmar, executando o comando
`git add` antes de executar o comando `git commit`.

OPÇÕES
------

-s::
--short::
	Dar a saída em um formato curto.

-b::
--branch::
	Exibe o ramo e a informação de rastreio quando estiver em formato curto.

--show-stash::
	Exibe a quantidade de entradas ocultas atualmente.

--porcelain[=<versão>]::
	Forneça a saída em um formato fácil de analisar para os scripts. Isso é
	semelhante à saída curta, mas permanecerá estável nas versões do Git e
	independentemente da configuração do usuário. Veja abaixo os detalhes.
+
O parâmetro da versão é utilizado para definir a versão do formato.  Este é
opcional e é predefinido ter o formato da versão original 'v1'.

--long::
	Dar a saída em um formato longo. Esta é a predefinição.

-v::
--verbose::
	Além dos nomes dos arquivos que foram alterados, exiba também as alterações
	textuais que são preparadas para o commit (ou seja, como a saída do `git
	diff --cached`). Caso a opção `-v` seja usada duas vezes, também exiba as
	alterações na árvore de trabalho que ainda não foram preparadas (ou seja,
	como a saída do comando `git diff`).

-u[<modo>]::
--untracked-files[=<modo>]::
	Exibe arquivos sem rastreamento.
+
--
O parâmetro `modo` é usado para definir a manipulação dos arquivos não
rastreados.  É opcional: a predefinição é 'all' e se definido, deve estar
preso à opção (por exemplo, `-uno`, mas não `-u no`).

As opções disponíveis são:

	- 'no'     - Não exibe qualquer arquivo que não tenham sido rastreados.
	- 'normal' - Exibe todos os arquivo e diretórios que não foram rastreados.
	- 'all'    - Exibe todos os arquivos individualmente nos diretórios não rastreados.

Quando a opção `-u` não é usada, os arquivos e diretórios não rastreados são
exibidos (ou seja, o mesmo que usar `normal`), para ajudar a evitar o
esquecimento de adicionar os arquivos recém-criados.  Como é necessário um
trabalho extra para encontrar os arquivos que não foram rastreados no
sistema de arquivos, esse modo pode levar algum tempo em uma grande árvore
de trabalho.  Considere ativar o cache não rastreado e dividir o índice, se
suportado (consulte `git update-index --untracked-cache` e `git update-index
--split-index`). Caso contrário, você pode usar `no` para obter o retorno do
comando `git status` mais rapidamente sem mostrar quais os arquivos não
foram rastreados.

A predefinição pode ser alterada usando a variável de configuração
`status.showUntrackedFiles` documentada em linkgit:git-config[1].
--

--ignore-submodules[=<quando>]::
	Ignore as alterações nos submódulos ao procurar alterações. <quando> pode
	ser "none", "Untracked", "dirty" ou "all", que é a predefinição. O uso de
	"none" considerará o submódulo modificado quando ele conter os arquivos não
	rastreados ou modificados ou o seu `HEAD` diferir do commit registrado no
	`superproject` e pode ser usado para substituir qualquer configuração da
	opção 'ignorar' no linkgit:git-config[1] ou linkgit:gitmodules[5]. Quando
	"untracked" for usado, os submódulos não são considerados sujos quando
	contêm apenas conteúdo não rastreado (mas ainda são verificados quanto ao
	conteúdo modificado). O uso de "dirty" ignora todas as alterações na árvore
	de trabalho dos submódulos, apenas as alterações nos commit armazenados no
	superprojeto são mostradas (esse era o comportamento anterior à 1.7.0). O
	uso de "all" oculta todas as alterações nos submódulos (e suprime a saída
	dos resumos dos submódulos quando a opção de configuração
	`status.submoduleSummary` está definida).

--ignored[=<modo>]::
	Exibir os arquivos ignorados também.
+
--
O parâmetro de modo é utilizado para definir o manuseio dos arquivos
ignorados.  É opcional: a sua predefinição é 'traditional'.

As opções disponíveis são:

	- 'traditional' - Exibe os arquivos e diretórios ignorados, a menos que
			  --untracked-files=all está especificado, nesse caso
			  os arquivos individuais nos diretórios ignorados são
			  exibidos.
	- 'no'	        - Não exibe os arquivos ignorados.
	- 'matching'    - Exibe os arquivos e diretórios ignorados que correspondem a um
			  ignora o padrão.

Quando o modo 'matching' é usado, os caminhos que coincidam explicitamente a
um padrão ignorado são exibidos. Caso um diretório coincidir com um padrão a
ser ignorado, ele será exibido, mas não os caminhos contidos no diretório
ignorado. Caso um diretório não coincida com um padrão a ser ignorado, mas
todo o conteúdo for ignorado, o diretório não será exibido, mas todo o resto
do conteúdo será.
--

-z::
	Terminar as entradas com `NUL`, em vez de `LF`.  Isto implica o formato de
	saída `--porcelain=v1` caso nenhum outro formato seja usado.

--column[=<opções>]::
--no-column::
	Exiba os arquivos que não foram rastreados em colunas. Veja a variável de
	configuração `column.status` para ver a sintaxe dessa opção.`--column` e
	`--no-column` sem opções são equivalentes a 'always' e 'never'
	respectivamente.

--ahead-behind::
--no-ahead-behind::
	Exiba ou não as contagens detalhadas antecipadas/atrasadas da ramificação em
	relação à ramificação `upstream`.  A predefinição é `true`.

--renames::
--no-renames::
	Ligue/desligue a detecção de renomeação, independentemente da configuração
	do utilizador.  Consulte tambémlinkgit:git-diff[1] `--no-renames`.

--find-renames[=<n>]::
	Liga a detecção de renomeação, configurando opcionalmente o limite de
	similaridade.  Consulte também linkgit:git-diff[1] `--find-renames'.

<pathspec>...::
	Consulte a entrada 'pathspec' em linkgit:gitglossary[7].

SAÍDA
-----
A saída deste comando foi projetada para ser usada como um comentário modelo
do commit.  A predefinição é utilizar o formato longo, foi projetado para
ser legível por seres humanos, detalhado e descritivo.  Seu conteúdo e
formato estão sujeitos a alterações a qualquer momento.

Os caminhos mencionados na saída, diferentemente de muitos outros comandos
Git, são feitos em relação ao diretório atual. Caso esteja trabalhando em um
subdiretório (isso é proposital, para ajudar a cortar e colar). Consulte a
opção de configuração `status.relativePaths` abaixo.

Formato Curto
~~~~~~~~~~~~~

No formato curto, a condição de cada caminho é exibido como uma das
seguintes formas

	XY PATH
	XY ORIG_PATH -> PATH

onde `ORIG_PATH` é de onde veio o conteúdo renomeado/copiado. O `ORIG_PATH`
só é exibido quando a entrada é renomeada ou copiada. O `XY` é um código de
condição com duas letras.

Os campos (incluindo o `->`) estão separados um do outro por um único
espaço. Caso um nome do arquivo contenha um espaço em branco ou outros
caracteres não imprimíveis, este campo será citado na forma de uma string C
literal: cercado por caracteres ASCII com aspas duplas (34) e com os
caracteres especiais internos escapados por barra invertida.

Para os caminhos com conflitos de mesclagem, `X` e `Y` exibem a condição das
modificações de cada lado da mesclagem. Para os caminhos que não possuam
conflitos de mesclagem, `X` mostra a condição do índice e `Y` exibe a
condição da árvore de trabalho. Para os caminhos não rastreados, `XY` é
`??`. Os outros códigos das condições podem ser interpretados da seguinte
maneira:

* ' ' = não modificado
* 'M' = modificado
* 'A' = adicionado
* 'D' = excluído
* 'R' = renomeado
* 'C' = copiado
* 'U' = atualizado, mas não mesclado

Os arquivos ignorados não estão listados, a menos que a opção `--ignored`
esteja em vigor; nesse caso, `XY` é `!!`.

....
X          Y     Significado
-------------------------------------------------
	 [AMD]   não atualizado
M        [ MD]   atualizado no índice
A        [ MD]   adicionado ao índice
D                excluído do índice
R        [ MD]   renomeado no índice
C        [ MD]   copiado para o índice
[MARC]           índice e correspondências na árvore de trabalho
[ MARC]     M    mudanças na árvore de trabalho deste o índice
[ MARC]     D    excluído da árvore de trabalho
[ D]        R    renomeado na árvore de trabalho
[ D]        C    copiado na árvore de trabalho
-------------------------------------------------
D           D    unmerged, ambos excluídos
A           U    unmerged, adicionados por nós
U           D    unmerged, excluído por eles
U           A    unmerged, adicionado por nós
D           U    unmerged, excluído por nós
A           A    unmerged, ambos adicionados
U           U    unmerged, ambos modificados
-------------------------------------------------
?           ?    não rastreado
!           !    ignorado
-------------------------------------------------
....

Os submódulos têm mais condição e, em vez disso, relatam
		M    o submódulo possui um `head` diferente da
		     gravada no índice
		m    o submódulo modificou o conteúdo
		?    o submódulo possui arquivos não rastreados
pois conteúdo modificado ou arquivos não rastreados em um
submódulo não podem ser adicionados via `git add` no `superproject` para preparar um commit.

'm' e '?' são aplicados recursivamente. Por exemplo, se um submódulo
aninhado em um submódulo contiver um arquivo não rastreado, isso será
relatado como '?' também.

Caso `-b` seja usado, a condição de formato curto será precedido por uma
linha

    ## info de  rastreio do nome do ramo

Formato de Porcelana Versão 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

O formato de porcelana da versão 1 é semelhante ao formato curto, no entanto
é garantido que não seja alterado de maneira que seja incompatível com as
versões anteriores das versões do Git ou com a base na configuração do
usuário. Isso o torna ideal para ser analisado por scripts.  A descrição do
formato curto acima também descreve o formato de porcelana, com algumas
exceções:

1. Caso a configuração da variável `color.status` do usuário não seja
   respeitada; a cor estará sempre desligada.

2. Caso a configuração da variável `status.relativePaths` do usuário não seja
   respeitada; os caminhos exibidos sempre serão relativos à raiz do
   repositório.

Há também um formato alternativo `-z` recomendado para a análise de
máquina. Neste formato, o campo do status é o mesmo, porém algumas outras
coisas mudam.  Primeiro, o '\ ->' é omitido das entradas de renomeação e a
ordem dos campos é revertida (por exemplo, 'from \-> to' se torna 'to
from'). Segundo, um `NUL` (ASCII 0) segue cada nome de arquivo substituindo
o espaço como um separador de campos e a nova linha final (porém um espaço
ainda separa o campo de status do primeiro nome do arquivo).  Terceiro, os
nomes dos arquivos que contenha caracteres especiais não são especialmente
formatados; nenhuma citação ou barra de escape invertida é executada.

Quaisquer alterações no submódulo são relatadas como `M` modificado em vez
de `m` ou um único `?`.

Formato de Porcelana Versão 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

O formato da versão 2 adiciona informações mais detalhadas sobre a condição
da árvore de trabalho e os itens que foram alterados.  Na versão 2 também é
definido um conjunto extensível de cabeçalhos opcionais fáceis de serem
analisados.

As linhas do cabeçalho começam com o símbolo "#" e são adicionadas em
resposta aos argumentos específicos da linha de comando.  Os analisadores
devem ignorar os cabeçalhos que não sejam reconhecidos.

Cabeçalho dos Ramos
^^^^^^^^^^^^^^^^^^^

Caso `--branch` seja usado, uma série de linhas de cabeçalho será impressa
com as informações sobre a ramificação atual.

....
Line                                     Notes
------------------------------------------------------------
# branch.oid <commit> | (inicial)        Commit atual.
# branch.head <ramo> | (desanexado)      Commit atual.
# branch.upstream <ramo_upstream>      caso o upstream esteja definido.
# branch.ab +<adiante> -<atrás>           caso o upstream esteja definido e
					 o commit esteja presente.
------------------------------------------------------------
....

Entradas Rastreadas que Foram Alteradas
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Após os cabeçalhos, uma série de linhas é impressa para entradas que são
rastreadas.  Um dos três formatos diferentes da linha podem ser usados para
descrever uma entrada, dependendo do tipo da alteração.  As entradas
rastreadas são impressas em uma ordem indefinida; os analisadores devem
permitir uma mistura dos três tipos de linha e em qualquer ordem.

Os itens comuns que foram alterados têm o seguinte formato:

    1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <caminho>

As entradas que foram renomeadas ou copiadas têm o seguinte formato:

    2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <caminho><sep><caminho original>

....
Campo       Significado
--------------------------------------------------------
<XY>        Um campo com 2 caracteres contendo valores XY
	    montados e não montados descrito em um formato curto,
	    sem modificações indicadas por um "." em vez de
	    um espaço em branco.
<sub>       Um campo com 4 caracteres descrevendo a condição do submódulo.
	    "N..." quando a entrada não for um submódulo.
	    "S<c><m><u>" quando a entrada for um submódulo.
	    <c> is "C" caso o commit seja modificado; senão ".".
	    <m> is "M" caso haja mudanças rastreadas; senão ".".
	    <u> is "U" caso não haja mudanças rastreadas; senão ".".
<mH>        O modo de um arquivo octal no HEAD.
<mI>        O modo de um arquivo octal no index.
<mW>        O modo de um arquivo octal no árvore de trabalho.
<hH>        O nome do objeto no HEAD.
<hI>        O nome do objeto no índice.
<X><score>  O renomeamento ou a cópia do score "placar"(denota a porcentagem
	    ou a similaridade entre a fonte e o destino da ação de
	    mover ou copiar. Por exemplo, "R100" ou "C75".
<path>      O `pathname` "nome do caminho".  Em um lançamento de renomeação/cópia,
	    este é o caminho de destino.
<sep>       Quando a opção `-z` for utilizada, os 2 `pathnames` são separados
	    com um byte `NUL` (ASCII 0x00); senão um byte tab (ASCII 0x09)
	    que os separam.
<origPath>  O `pathname` dentro do commit localizado no HEAD ou no índice.
	    Só está presente no caso de um lançamento de renomeação ou cópia
	    assim como informa de onde a renomeação ou cópia vieram.
--------------------------------------------------------
....

As entradas que não forem mescladas têm o seguinte formato; o primeiro
caractere é um "u" para se distinguir das entradas comum que foram
alteradas.

    u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <caminho>

....
Campo       Significado
--------------------------------------------------------
<XY>        Um campo com 2 caracteres descrevendo o tipo de conflito
	    como descrito em um formato curto.
<sub>       Um campo com 4 caracteres descrevendo a condição do submódulo
	    como descrito abaixo.
<m1>        O modo de um arquivo octal no estágio 1.
<m2>        O modo de um arquivo octal no estágio 2.
<m3>        O modo de um arquivo octal no estágio 3.
<mW>        O modo de um arquivo octal na árvore de trabalho.
<h1>        O nome do objeto no estágio 1.
<h2>        O nome do objeto no estágio 2.
<h3>        O nome do objeto no estágio 3.
<path>      O pathname.
--------------------------------------------------------
....

Outros itens
^^^^^^^^^^^^

Seguindo as entradas rastreadas (se for solicitado), uma série de linhas
será impressa para os itens não rastreados e depois ignorados para os itens
encontrados na árvore de trabalho.

Itens não rastreados têm o seguinte formato:

    ? <caminho>

Os itens ignorados tem o seguinte formato:

    ! <caminho>

Notas sobre o formato do `pathname` e `-z`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Quando a opção `z` é usada os `pathnames` são exibidos como estão e sem
nenhuma citação e as linhas são terminadas com um byte NUL (ASCII 0x00).

Sem a opção `z`, os `pathnames` com caracteres "incomuns" são citados
conforme explicado na variável de configuração `core.quotePath` (consulte
linkgit:git-config[1]).


CONFIGURAÇÃO
------------

O comando segue a variável `color.status` (ou `status.color`, ambos têm o
mesmo significado, o último é mantido para compatibilidade com versões
anteriores). As variáveis de configuração `color.status.` serve para para
colorir a saída.

Se a variável de configuração `status.relativePaths` estiver configurada
como `false`, todos os caminhos exibidos serão relativos à raiz do
repositório e não ao diretório atual.

Se a variável `status.submoduleSummary` for definida como um número
diferente de zero ou `true` (idêntico a `-1` ou um número ilimitado), o
resumo do submódulo será ativado para o formato longo e um resumo das
confirmações para os submódulos modificados serão exibidos (consulte a opção
--summary-limit de linkgit:git-submodule[1]). Por favor note que a saída
resumida do comando status será suprimida para todos os submódulos quando a
variávle `diff.ignoreSubmodules` estiver definida como `all` ou apenas para
aqueles submódulos em onde seja o mesmo que
`submodule.<name>.ignore=all`. Para visualizar também o resumo dos
submódulos ignorados, você pode usar a opção de clinha de comando
`--ignore-submodules=dirty ` ou o comando `git submodule summary`, que exibe
uma saída semelhante porém não respeita estas configurações.

ATUALIZAÇÃO DO PLANO DE FUNDO
-----------------------------

É predefinido que o 'status git' atualize automaticamente o índice, que
atualize também as estatísticas das informações armazenadas em cache da
árvore de trabalho e gravando o resultado. Escrever o índice atualizado é
uma otimização que não é estritamente necessária (o `status` calcula os
valores por si só, mas escrevê-los é apenas para evitar que os programas
subsequentes refaçam o nosso processamento). Quando o `status` é executado
em segundo plano o bloqueio mantido durante a gravação pode entrar em
conflito com outros processos que estejam sendo executados simultaneamente,
fazendo com que eles falhem. Os scripts que executam `status` em segundo
plano devem considerar o uso de`git --no-optional-locks status` (para mais
detalhes consulte linkgit:git[1]).

VEJA TAMBÉM
-----------
linkgit:gitignore[5]

GIT
---
Parte do linkgit:git[1] suite
