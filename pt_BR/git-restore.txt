git-restore(1)
==============

NOME
----
git-restore - Restaura os arquivos das árvores de trabalho

SINOPSE
-------
[verse]
'git restore' [<opções>] [--source=<árvore>] [--staged] [--worktree] [--] <pathspec>...
'git restore' [<opções>] [--source=<árvore>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul]
'git restore' (-p|--patch) [<opções>] [--source=<árvore>] [--staged] [--worktree] [--] [<pathspec>...]

DESCRIÇÃO
---------
Restore specified paths in the working tree with some contents from a
restore source. If a path is tracked but does not exist in the restore
source, it will be removed to match the source.

The command can also be used to restore the content in the index with
`--staged`, or restore both the working tree and the index with `--staged
--worktree`.

By default, if `--staged` is given, the contents are restored from `HEAD`,
otherwise from the index. Use `--source` to restore from a different commit.

Para as diferenças entre os três comandos consulte "Redefinir, restaurar e
reverter" em linkgit:git[1].

ESTE COMANDO É EXPERIMENTAL. O SEU COMPORTAMENTO PODE MUDAR.

OPÇÕES
------
-s <árvore>::
--source=<árvore>::
	Restaure arquivos da árvore de trabalho com o conteúdo da árvore
	informada. É comum especificar a árvore de origem nomeando um commit, ramo
	ou tag associado com ela.
+
If not specified, the contents are restored from `HEAD` if `--staged` is
given, otherwise from the index.

-p::
--patch::
	Selecione a diferença entre os blocos interativamente entre a origem da
	restauração e o local da restauração. Consulte a seção ``Modo Interativo''
	do linkgit:git-add[1] para aprender como operar o modo `--patch`.
+
Note que o comando `--patch` pode não aceitar nenhum `pathspec` e solicitará
a restauração de todos os caminhos modificados.

-W::
--worktree::
-S::
--staged::
	Especifica o local da restauração. É predefinido que caso nenhuma opção seja
	utilizada a árvore de trabalho será restaurada. Ao usar a opção `--staged`
	apenas a índice será restaurado. A utilização de ambas as opções faz a
	restauração de ambos.

-q::
--quiet::
	Silencioso, suprima as mensagens de feedback. Implies `--no-progress`.

--progress::
--no-progress::
	O status de progresso é relatado no fluxo de erro padrão por padrão quando
	ele é anexado a um terminal, a menos que `--quiet` seja especificado. Este
	sinalizador permite relatórios de progresso, mesmo que não estejam anexados
	a um terminal, independentemente de `--quiet`.

--ours::
--theirs::
	Ao restaurar os arquivos no índice da árvore de trabalho, utilize o estágio
	#2 ('nosso') ou #3 ('deles') para os caminhos que não foram mesclados.
+
Note que durante o `git rebase` e` git pull --rebase`, o 'nosso' e o 'deles'
podem aparecer trocados. Para mais detalhes, consulte a explicação das
mesmas opções em linkgit:git-checkout[1].

-m::
--merge::
	Ao restaurar os arquivos no índice da árvore de trabalho, recrie a mesclagem
	conflitante nos caminhos que ainda não foram mesclados.

--conflito=<estilo>::
	O mesmo que a opção `--merge acima` porém altera a forma como os blocos
	conflitantes são apresentados, substituindo a variável de configuração
	`merge.conflictStyle`.  Os valores possíveis são "merge" (padrão) e "diff3"
	(além do que é mostrado pelo estilo "merge", exibe o conteúdo original).

--ignore-unmerged::
	Não aborte a operação ao restaurar os arquivos no índice da árvore de
	trabalho caso existam entradas que não foram mescladas e tão pouco as opções
	`--ours`, `--theirs`, `--merge` ou `--conflict` tenham sido utilizadas. Nada
	acontece com os caminhos das árvores de trabalho caso eles não tenham sido
	mesclados.

--ignore-skip-worktree-bits::
	É predefinido que no modo de checkout esparso apenas as entradas que sejam
	coincidentes com `<pathspec>` e com os padrões esparsos em
	`$GIT_DIR/info/sparse-checkout`. Esta opção ignora os padrões esparsos e os
	adiciona de volta nos arquivos em `<pathspec>`.

--recurse-submodules::
--no-recurse-submodules::
	Caso o`<pathspec>` dê nome para um submódulo ativo e o ponto de restauração
	inclua a árvore de trabalho, o submódulo apenas será atualizado caso essa
	informação seja utilizada, no caso, a sua árvore de trabalho será restaurado
	ao commit registrado no superprojeto e quaisquer alterações locais será
	substituida. Caso nenhum (ou `--no-recurse-submodules`) seja utilizado, os
	submódulos nas árvores de trabalho não serão atualizados. Assim como
	linkgit:git-checkout[1], isso irá desanexar o `HEAD` do submódulo.

--overlay::
--no-overlay::
	No modo de sobreposição, o comando nunca remove os arquivos durante a
	restauração. No modo sem sobreposição, os arquivos rastreados que não
	aparecem na árvore `--source` são removidos para fazê-los coincidir
	exatamente com a `<árvore>`. A predefinição é sem sobreposição.

--pathspec-from-file=<arquivo>::
	O "pathspec" é passado com `<arquivo>` em vez dos argumentos da linha de
	comando. Caso o `<arquivo>` seja exatamente `-`, a entrada predefinida será
	utilizada. Os elementos do "pathspec" são separados por caracteres de
	término de linha `LF` ou `CR/LF`. Os elementos do "pathspec" podem ser
	citados conforme explicado na variável da configuração `core.quotePath`
	(consulte linkgit:git-config[1]). Consulte também opção
	`--pathspec-file-nul` e o global `--literal-pathspecs`.

--pathspec-file-nul::
	Só faz algum sentido caso seja utilizado junto com a opção
	`--pathspec-from-file`. Os elementos "pathspec" são separados com caracteres
	`NUL` e todos os outros caracteres são considerados de forma literal
	(incluindo as novas linhas e as citações).

\--::
	Não interprete mais argumentos como opções.

<pathspec>...::
	Limita os caminhos afetados pela operação.
+
Para mais detalhes sobre a sintaxe <pathspec>, veja a entrada 'pathspec' em
linkgit:gitglossary[7].

EXEMPLOS
--------

A sequência a seguir muda para o ramo `master`, reverte o` Makefile` para
duas revisões anteriores, apaga o hello.c por engano e o recupera do índice.

------------
$ git switch master
$ git restore --source master~2 Makefile  <1>
$ rm -f hello.c
$ git restore hello.c                     <2>
------------

<1> tirar um arquivo de outro commit
<2> restaurar o hello.c do índice

Caso queira restaurar _TODOS_ os arquivos do código fonte C para que
coincidam com a versão do índice, você pode usar

------------
$ git restore '*.c'
------------

Observe as aspas em torno de `* .c`.  O arquivo `hello.c` também será
restaurado ainda que não esteja mais na árvore de trabalho, pois o
agrupamento dos arquivos é utilizado para coincidir com as entradas do
índice (não na árvore de trabalho pelo shell).

Para restaurar todos os arquivos no diretório atual

------------
$ git restore .
------------

ou para restaurar todos os arquivos do cume da árvore de trabalho com a
mágica do "pathspec" (consulte linkgit:gitglossary[7])

------------
$ git restore :/
------------

Para restaurar um arquivo no índice que coincida com a versão em `HEAD` (é o
mesmo que usar linkgit:git-reset[1])

------------
$ git restore --staged hello.c
------------

ou você pode restaurar o índice e a árvore de trabalho (é o mesmo que usar
linkgit:git-checkout[1])

------------
$ git restore --source=HEAD --staged --worktree hello.c
------------

ou a forma abreviada que é mais prática, mas menos legível:

------------
$ git restore -s@ -SW hello.c
------------

VEJA TAMBÉM
-----------
linkgit:git-checkout[1], linkgit:git-reset[1]

GIT
---
Parte do conjunto linkgit:git[1]
