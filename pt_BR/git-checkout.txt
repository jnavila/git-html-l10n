git-checkout(1)
===============

NOME
----
git-checkout - Alterne entre os ramos ou restaure os arquivos da árvore de
trabalho

SINOPSE
-------
[verse]
'git checkout' [-q] [-f] [-m] [<ramo>]
'git checkout' [-q] [-f] [-m] --detach [<ramo>]
'git checkout' [-q] [-f] [-m] [--detach] <commit>
'git checkout' [-q] [-f] [-m] [[-b|-B|--orphan] <novo_ramo>] [<ponto_de_inicio>]
'git checkout' [-f|--ours|--theirs|-m|--conflict=<estilo>] [<tree-ish>] [--] <pathspec>...
'git checkout' [-f|--ours|--theirs|-m|--conflict=<estilo>] [<tree-ish>] --pathspec-from-file=<arquivo> [--pathspec-file-nul]
'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]

DESCRIÇÃO
---------
Atualiza os arquivos na árvore de trabalho para coincidir com a versão no
índice ou na árvore informada.  Se nenhum "pathspec" seja utilizado, o
comando 'git checkout' também atualizará o `HEAD` para definir o ramo
informado como o ramo atual.

'git checkout' [<ramo>]::
	Para se preparar para trabalhar em um `<ramo>`, alterne para ele atualizando
	o índice, os arquivos na árvore de trabalho e apontando para o `HEAD` do
	ramo. As modificações locais são mantidas nos arquivos da árvore de
	trabalho, para que o commit possa ser no `<ramo>`.
+
Caso o `<ramificação>` não seja encontrada mas exista uma monitorada
remotamente (chame-o de `<remoto>`) com um nome que coincida e quando
`--no-guess` não seja utilizado, trate-o como um equivalente a
+
------------
$ git checkout -b <ramo> --track <remote>/<ramo>
------------
+
Você pode omitir o `<ramo>` no caso em que o comando se degenera para
"verificar o branch atual", que é um glorificado não-op com efeitos
colaterais bastante dispendiosos para exibir apenas as informações de
rastreamento, caso existam, para o ramo atual.

'git checkout' -b|-B <new_branch> [<ponto de início>]::

	Especificar `-b` faz com que uma nova ramificação seja criada como se
	linkgit:git-branch[1] fosse chamado e, em seguida, retirado. Neste caso você
	pode usar as opções `--track` ou` --não-track`, que serão passadas para 'git
	branch'. Por conveniência, `--track` sem` -b` implica criação de
	ramificação; veja a descrição de `--track` abaixo.
+
Caso `-B` seja dado, o `<novo_branch>` é criado se ainda não existir; caso
contrário, é redefinido. Este é o equivalente transacional de
+
------------
$ git branch -f <branch> [<ponto de partida>]
$ git verificar <branch>
------------
+
isto é, a ramificação não é redefinida/criada a menos que "git verificar"
seja bem-sucedido.

'git checkout' --detach [<ramo>]::
'git checkout' [--detach] <commit>::

	Prepare-se para trabalhar em cima de `<commit>`, desanexando o `HEAD` nele
	(consulte a seção "DESTACADO HEAD") e atualizando o índice e os arquivos na
	árvore de trabalho.  As modificações locais nos arquivos na árvore de
	trabalho são mantidas de forma que a árvore de trabalho resultante seja o
	estado registrado no commit, mais as modificações locais.
+
Quando o argumento `<commit>` é um nome de ramificação a opção `--detach`
pode ser utilizada para desanexar o `HEAD` na ponta do ramo (` git checkout
<branch>` verificaria aquela ramificação sem desanexar o `HEAD`).
+
Ao omitir o `<branch>` isso desanexa o `HEAD` na ponta do ramo atual.

'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>...::
'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]::

	Substitua o conteúdo dos arquivos que correspondem ao `pathspec`.  Quando o
	`<tree-ish>` (na maioria das vezes um commit) não for informado, substitua a
	árvore de trabalho pelo conteúdo do índice.  Quando o `` for informado,
	substitua o índice e a árvore de trabalho pelo conteúdo em `<tree-ish>`.
+
O índice pode conter entradas não mescladas devido a uma mesclagem anterior
com falha.  Por padrão, se você tentar verificar essa entrada do índice, a
operação de check-out falhará e nada será retirado. Usar `-f` irá ignorar
essas entradas não-mescladas.  O conteúdo de um lado específico da mesclagem
pode ser retirado do índice usando `--ours` ou` --theirs`.  Com `-m`, as
alterações feitas no arquivo da árvore de trabalho podem ser descartadas
para recriar o resultado da mesclagem original em conflito.

'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]::
	Isso é semelhante ao modo anterior, porém permite usar a interface
	interativa para mostrar a saída "diff" e escolher quais blocos usar no
	resultado.  Veja abaixo a descrição da opção `--patch`.

OPÇÕES
------
-q::
--quiet::
	Silencioso, suprima as mensagens de feedback.

--progress::
--no-progress::
	O status de progresso é relatado no fluxo de erro padrão por padrão quando
	ele é anexado a um terminal, a menos que `--quiet` seja especificado. Este
	sinalizador permite relatórios de progresso, mesmo que não estejam anexados
	a um terminal, independentemente de `--quiet`.

-f::
--force::
	Ao alternar as ramificações, continue mesmo se o índice ou a árvore de
	trabalho forem diferentes do `HEAD`.  Isto é usado para descartar as
	alterações locais.
+
Ao verificar os caminhos do índice, não falhe em entradas não mescladas; Em
vez disso, as entradas não mescladas são ignoradas.

--ours::
--theirs::
	Ao verificar os caminhos do índice, confira o estágio #2 ('nosso') ou #3
	('deles') para paths não mesclados.
+
Observe que durante o `git rebase` e o `git pull --rebase`, o 'ours' (nosso)
e o 'theirs' (deles) podem aparecer trocados; `--ours` informa a versão do
ramo onde as alterações são feitas, enquanto `--theirs` informa a versão do
ramo que contém o seu trabalho que está sendo feito o "rebase".
+
Isso ocorre porque o `rebase` é utilizado em um fluxo de trabalho que trata
o histórico no ramo remoto como o canônico compartilhado e trata o trabalho
realizado no ramo que você está fazendo o "rebase" como o trabalho de
terceiros que será integrado, você está temporariamente assumindo o papel do
guardião da história canônica durante o rebase.  Como o guardião da história
canônica, você precisa ver a história do ramo remoto como "nosso" (isto é,
"nossa história canônica compartilhada"), enquanto o que você fez no seu
ramo lateral como "seu" (isto é, "um trabalho de colaborador" em cima dele
").

-b <novo_branch>::
	Crie uma nova ramificação chamada `<new_branch>` e inicie-a em
	`<start_point>`; para mais detalhes consulte linkgit:git-branch[1].

-B <novo_branch>::
	Cria uma nova ramificação `<new_branch>` e a inicia em `<start_point>`; caso
	já exista, então reinicia em `<start_point>`. Isso é o equivalente que rodar
	"git branch" com "-f"; para mais detalhes consulte linkgit:git-branch[1].

-t::
--track::
	Ao criar um novo branch, configure "upstream". Veja "--track" em
	linkgit:git-branch[1] para detalhes.
+
Se nenhuma opção `-b` for dada o nome da nova ramificação será derivada da
ramificação remota, observando-se a parte local do "refspec" configurada
para a sua correspondente remota, em seguida, removendo a parte inicial para
o "*".  Isto nos mostra para usar `hack` como uma ramificação local ao se
ramificar de `remotes/origin/hack` ou até mesmo
`refs/remotes/origin/hack`).  Caso o nome dado não tenha barra ou se a
suposição acima resultar em um nome vazio, a adivinhação será abortada. Você
pode dar explicitamente em tal caso um nome com a opção `-b`.

--no-track::
	Não configure "upstream" mesmo que a variável da configuração
	`branch.autoSetupMerge` seja verdadeira.

--guess::
--no-guess::
	Caso o `<ramo>` não seja encontrado mas exista uma ramificação de
	rastreamento exatamente em uma localidade remota (chame-o <remoto>) que
	coincida com um nome, trate como equivalente a
+
------------
$ git checkout -b <ramo> --track <remote>/<ramo>
------------
+
Caso o ramo exista em diversos pontos remotos e um deles for nomeado pela
variável de configuração `checkout.defaultRemote`, para propósitos de
desambiguação usaremos aquele que, mesmo que `<ramo>` não seja o único em
todos os outros ramos remotos . Defina como, por exemplo
`checkout.defaultRemote=origin` que sempre verifique as ramificações remotas
de lá caso `<ramo>` seja ambíguo e ainda assim `origin` exista. Consulte
também `checkout.defaultRemote` im linkgit:git-config[1].
+
Utilize a opção `--no-guess` para desativar.

-l::
	Crie o reflog da nova ramificação; veja linkgit:git-branch[1] para detalhes.

--detach::
	Em vez de verificar um ramo para trabalhar nele, confira um commit para
	inspeções e experiências descartáveis.  Este é o comportamento padrão de
	`git checkout <commit>` quando `<commit>` não for um nome de
	ramificação. Veja a seção "DESASSOCIANDO O HEAD" abaixo para detalhes.

--orfão <novo_branch>::
	Crie uma nova ramificação 'orphan' denominada `<new_branch>` iniciada a
	partir do <start_point> e mude para ela. O primeiro commit feito nesta nova
	ramificação não terá as origens e será a raiz de uma nova história
	totalmente desconectada de todas os outros ramos e commits.
+
O índice e a árvore de trabalho são ajustadas como se você tivesse executado
`git checkout <start_point>` anteriormente. Isso permite que você inicie um
novo histórico que registra um conjunto de "paths" semelhante ao
`<start_point>` sendo executado facilmente com `git commit -a` para fazer o
commit principal.
+
Isso pode ser útil quando você deseja publicar a árvore de um commit sem
expor seu histórico completo. Você pode querer fazer isso para publicar uma
ramificação de código aberto de um projeto cuja árvore atual esteja "limpa",
mas cujo histórico completo contenha bits de código proprietários ou de
outra forma onerados.
+
Caso queira iniciar um histórico desconectado que registra um conjunto de
caminhos totalmente diferente do `<start_point>`, então você deve limpar o
índice e a árvore de trabalho logo após criar a ramificação órfã executando
`git rm -rf.` do topo da árvore de trabalho. Depois disso, você estará
pronto para preparar os seus novos arquivos, preenchendo a árvore de
trabalho, copiando-os de outro lugar, extraindo um tarball, etc.

--ignore-skip-worktree-bits::
	É predefinido que no modo de checkout esparso apenas as entradas que sejam
	coincidentes com `<pathspec>` e com os padrões esparsos em
	`$GIT_DIR/info/sparse-checkout`. Esta opção ignora os padrões esparsos e os
	adiciona de volta nos arquivos em `<pathspec>`.

-m::
--merge::
	Ao alternar ramificações, se você tiver modificações locais em um ou mais
	arquivos que sejam diferentes entre a ramificação atual e a ramificação para
	a qual você está alternando, o comando se recusará a alternar as
	ramificações para preservar suas modificações no contexto.  No entanto, com
	essa opção, uma mesclagem de três vias entre a ramificação atual, o conteúdo
	da árvore de trabalho e a nova ramificação é concluída e você estará na nova
	ramificação.
+
Quando ocorre um conflito de mesclagem, as entradas de índice para caminhos
conflitantes são deixadas sem migração, e você precisa resolver os conflitos
e marcar os paths resolvidos com `git add` (ou` git rm` se a mesclagem
resultar na exclusão do caminho) .
+
Ao efetuar o check-out de caminhos do índice, essa opção permite recriar a
mesclagem conflitante nos caminhos especificados.
+
Ao alternar as ramificações com `--merge` as alterações que já foram
organizadas podem ser perdidas.

--conflito=<estilo>::
	O mesmo que a opção `--merge acima` porém altera a forma como os blocos
	conflitantes são apresentados, substituindo a variável de configuração
	`merge.conflictStyle`.  Os valores possíveis são "merge" (padrão) e "diff3"
	(além do que é mostrado pelo estilo "merge", exibe o conteúdo original).

-p::
--patch::
	Selecione interativamente os pedaços na diferença entre o `<tree-ish>` (ou o
	índice, se não for especificado) e a árvore de trabalho.  Os pedaços
	escolhidos são então aplicados em reverso à árvore de trabalho (e caso um
	`<tree-ish>` for especificado, o índice).
+
Isso significa que você pode usar o `git checkout -p` para descartar
seletivamente as edições da sua árvore de trabalho atual. Veja a seção
``Interactive Mode'' do linkgit:git-add[1] para aprender como operar o modo
`--patch`.
+
Observe que por predefinição esta opção usa o modo sem sobreposição
(consulte também `--overlay`), assim como, atualmente também não é
compatível com o modo de sobreposição.

--ignore-other-worktrees::
	`git checkout` recusa-se quando a referência desejada já foi verificada por
	outra worktree. Esta opção faz com que verifique o ref fora de qualquer
	maneira. Em outras palavras, o ref pode ser mantido por mais de uma árvore
	de trabalho.

--overwrite-ignore::
--no-overwrite-ignore::
	Substitua silenciosamente os arquivos ignorados ao alternar
	ramificações. Este é o comportamento predefinido. Utilize
	`--no-overwrite-ignore` para interromper a operação quando o novo ramo
	contiver os arquivos que foram ignorados.

--recurse-submodules::
--no-recurse-submodules::
	Usando `--recurse-submodules` irá atualizar o conteúdo de todos os
	submódulos ativados de acordo com o commit registrado no
	"superproject". Caso as modificações locais em um submódulo sejam
	sobrescritas, o check-out falhará, a menos que `-f` seja usado. Caso nada
	(ou `--no-recurse-submodules`)  seja utilizado, os submódulos das árvores de
	trabalho não serão atualizados. Assim como o linkgit:git-submodule[1], isso
	desanexará os submódulos do `HEAD`.

--overlay::
--no-overlay::
	No modo predefinido de sobreposição, o `git checkout` nunca remove os
	arquivos do índice ou da árvore de trabalho.  Ao usar `--no-overlay` os
	arquivos que aparecem no índice e na árvore de trabalho, mas não em
	`<tree-ish>` são removidos, para fazê-los coincidir exatamente com
	`<tree-ish>`.

--pathspec-from-file=<arquivo>::
	O "pathspec" é passado com `<arquivo>` em vez dos argumentos da linha de
	comando. Caso o `<arquivo>` seja exatamente `-`, a entrada predefinida será
	utilizada. Os elementos do "pathspec" são separados por caracteres de
	término de linha `LF` ou `CR/LF`. Os elementos do "pathspec" podem ser
	citados conforme explicado na variável da configuração `core.quotePath`
	(consulte linkgit:git-config[1]). Consulte também opção
	`--pathspec-file-nul` e o global `--literal-pathspecs`.

--pathspec-file-nul::
	Só faz algum sentido caso seja utilizado junto com a opção
	`--pathspec-from-file`. Os elementos "pathspec" são separados com caracteres
	`NUL` e todos os outros caracteres são considerados de forma literal
	(incluindo as novas linhas e as citações).

<ramo>::
	Ramificação que será extraída; se refere a um ramo (ou seja, um nome que
	quando preparado com "refs/heads/", for um "ref" válido) então este ramo é
	extraído. Caso contrário, caso se referira a um commit válido, seu `HEAD` se
	torna "desanexado" e você não está mais em nenhuma ramificação (veja abaixo
	para detalhes).
+
Você pode usar a sintaxe `@{- N}` para se referir ao último ramo/commit
finalizado utilizando o comando "git checkout". Também é possível utilizar
`-` que é um sinônimo para `@{-1}`.
+
Como um caso especial, você pode usar `A...B` como um atalho para a
mesclagem na base de `A` e` B` se houver exatamente uma base a ser
mesclada. Você pode deixar de fora, no máximo, um de `A` e` B`, no caso, a
predefinição é `HEAD`.

<novo_branch>::
	Nome para o novo branch.

<ponto_de_partida>::
	O nome do commit na qual deve se iniciar uma nova ramificação; para mais
	detalhes consulte linkgit:git-branch[1]. Padrão para `HEAD`.
+
Como um caso especial, é possível utilizar `"A...B"` como um atalho como uma
base para a mesclagem de `A` e `B` caso exista exatamente uma base de
merge. Você pode deixar de fora, no máximo, um de `A` e` B`, caso em que a
predefinição é `HEAD`.

<tree-ish>::
	Árvore para checkout (quando os paths são dados). Se não especificado, o
	índice será usado.

\--::
	Não interprete mais argumentos como opções.

<pathspec>...::
	Limita os caminhos afetados pela operação.
+
Para mais detalhes sobre a sintaxe <pathspec>, veja a entrada 'pathspec' em
linkgit:gitglossary[7].

CABEÇA DESTACADA
----------------
Em geral `HEAD` refere-se a um ramo ou ramificação de nome próprio (como
`master` por exemplo). Enquanto isso, cada ramo ou ramificação tem como
referência um "commit" específico. Vamos olhar para um repositório com três
commits onde um deles está marcado como ramificação `master`:

------------
           HEAD (refere-se ao ramo 'master')
            |
            v
a---b---c  ramo 'master' (refere-se ao commit 'c')
    ^
    |
  tag 'v2.0' (refere-se ao commit 'b')
------------

Quando uma confirmação é criada nesta condição a ramificação é atualizada
com referência ao novo commit. Especificamente, o comando 'git commit' cria
um novo commit `d`, cuja origem seja o commit 'c' e então atualiza o ramo
`master` para se referir ao novo commit `d`. `HEAD` ainda se refere à
ramificação `master` e então indiretamente agora se refere ao commit `d`:

------------
$ editar; git adicionar; git commit

               HEAD (refere-se ao ramo 'master')
                |
                v
a---b---c---d  branch 'master' (refere-se ao commit 'd')
    ^
    |
  tag 'v2.0' (refere-se ao commit 'b')
------------

Às vezes é útil poder fazer o checkout do nome de um commit que não esteja
no topo de qualquer ramificação ou mesmo criar um novo commit que não tenha
referência em uma ramificação conhecida por nome. Vejamos o que acontece
quando fazemos o checkout commit `b` (aqui demostramos duas maneiras de como
isso pode ser feito):

------------
$ git verificar v2.0  # ou
$ git verificar master^^

   HEAD (refere-se ao commit 'b')
    |
    v
a---b---c---d  branch 'master' (refere-se ao commit 'd')
    ^
    |
  tag 'v2.0' (refere-se ao commit 'b')
------------

Observe que, independente do comando "checkout" utilizado o `HEAD` agora se
refere diretamente ao commit `b`. Isso é conhecido como uma condição em
desanexo (detached ) do `HEAD`.  Simplesmente significa que o `HEAD` tem
referência a um commit em específico em vez de se referir ao nome de um
ramo. Vejamos o que acontece quando criamos um commit:

------------
$ editar; git adicionar; git commit

     HEAD (refere-se ao commit 'e')
      |
      v
      e
     /
a---b---c---d  branch 'master' (refere-se ao commit 'd')
    ^
    |
  tag 'v2.0' (refere-se ao commit 'b')
------------

Agora existe um novo commit `e`, porém a sua referência existe apenas no
`HEAD`. Nessa condição fica claro que podemos adicionar mais um commit:

------------
$ editar; git adicionar; git commit

	 HEAD (refere-se ao commit 'f')
	  |
	  v
      e---f
     /
a---b---c---d  branch 'master' (refere-se ao commit 'd')
    ^
    |
  tag 'v2.0' (refere-se ao commit 'b')
------------

De fato, podemos executar todas as operações normais do Git. Porém vejamos o
que acontece quando fazemos um checkout do `master`:

------------
$ git verificar master

               HEAD (refere-se ao ramo 'master')
      e---f     |
     /          v
a---b---c---d  branch 'master' (refere-se ao commit 'd')
    ^
    |
  tag 'v2.0' (refere-se ao commit 'b')
------------

É importante perceber que neste momento nada se refere ao commit
`f`. Eventualmente o commit `f` (e de tabela o commit `e`) será excluído
pelo processo rotineiro da coleta de lixo do Git, antes que isso aconteça é
preciso criar uma referência. Se ainda não nos afastamos do commit `f`,
qualquer um deles criará uma referência a ele:

------------
$ git checkout -b foo   <1>
$ git branch foo        <2>
$ git tag foo           <3>
------------

<1> cria uma nova ramificação `foo` com referência ao commit `f`, atualiza HEAD
    com referência ao ramo `foo`. Isso significa que agora não estamos mais
    desanexados do `HEAD` após este comando.

<2> similarmente cria um novo ramo `foo` com referência ao commit `f` deixando
    `HEAD` desanexado.

<3> cria uma nova tag `foo`com referência ao commit `f` deixando HEAD
    desanexado.

Se nos afastamos do commit `f`, primeiro precisamos recuperar o nome do
objeto (normalmente utilizando `git reflog`) e em seguida, podemos criar uma
referência para ele. Para ver os dois últimos commits aos quais o `HEAD` se
refere, podemos usar um destes comandos, por exemplo:

------------
$ git reflog -2 HEAD # ou
$ git log -g -2 HEAD
------------

DISAMBIGUAÇÃO DE ARGUMENTOS
---------------------------

Quando há apenas um argumento que não seja `--` (como `git checkout abc`) e
quando ambos os argumento `<tree-ish>` são válidos (como a existência do
ramo `abc`) e `<pathspec>` também for válido (caso um arquivo ou diretório
exista e cujo nome seja "abc" por exemplo), o Git normalmente solicita que
você desambigue.  Contudo, como fazer o checkout de uma ramificação é uma
operação tão comum, o comando `git checkout abc` considera "abc" nessa
situação como `<tree-ish>`.  Utilize `git checkout -- <pathspec>` caso
queira eliminar estes caminhos de dentro do índice.

EXEMPLOS
--------

. A sequência a seguir exclui o ramo `master`, reverte o` Makefile` para duas
  revisões anteriores, exclui o arquivo hello.c por engano e faz a recuperação
  do índice.
+
------------
$ git checkout master             <1>
$ git checkout master~2 Makefile  <2>
$ rm -f hello.c
$ git checkout hello.c            <3>
------------
+
<1> comutação de branch
<2> tirar um arquivo de outro commit
<3> restaura do índice o arquivo `hello.c`
+
Caso queira verificar _todos_ os arquivos "*.c" do código-fonte diretamente
do índice, você pode utilizar
+
------------
$ git verificar -- '*.c'
------------
+
Observe as aspas em torno de `* .c`.  O arquivo `hello.c` também será
retirado, mesmo que não esteja mais na árvore de trabalho, porque o
agrupamento dos arquivos é utilizado para coincidir com as entradas no
índice (não na árvore de trabalho pelo shell).
+
Se você tem um ramo infeliz chamado `hello.c`, este passo seria confundido
como uma instrução para mudar para esse ramo.  Você deve escrever:
+
------------
$ git verificar -- hello.c
------------

. Depois de trabalhar no ramo errado, mudar para o ramo correto seria feito
  utilizando:
+
------------
$ git checkout meu tópico
------------
+
No entanto, o seu ramo "errado" e o correto "mytopic" podem diferir nos
arquivos modificados localmente por você. Que dessa maneira, a verificação
acima falhará assim:
+
------------
$ git verificar meu tópico
erro: você tem alterações locais em 'frotz'; não comutação de branches.
------------
+
Você pode dar o sinalizador `-m` ao comando, que tentaria uma merge de três
vias:
+
------------
$ git verificar -m meu tópico
Auto-merging frotz
------------
+
Após esta mesclagem de três vias, as alterações locais não serão registradas
no seu arquivo do índice, portanto, o `git diff` exibirá quais foram as
alterações feitas desde o cume do novo ramo.

. Quando um conflito de mesclagem acontece durante a troca de branches com a
  opção `-m`, você veria algo assim:
+
------------
$ git verificar -m meu tópico
Auto-merging frotz
ERRO: Merger conflito em frotz
fatal: falha no programa de merge
------------
+
Neste ponto, o `git diff` mostra as mudanças mescladas como no exemplo
anterior, bem como as mudanças nos arquivos conflitantes.  Editar, resolver
o conflito e marcá-lo como resolvido com o comando `git add` como de
costume:
+
------------
$ editar frotz
$ git adicionar frotz
------------

VEJA TAMBÉM
-----------
linkgit:git-switch[1], linkgit:git-restore[1]

GIT
---
Parte do conjunto linkgit:git[1]
