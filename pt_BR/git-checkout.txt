git-checkout(1)
===============

NOME
----
git-checkout - Alterne entre ramos ou restaure os arquivos da árvore de
trabalho

SINOPSE
-------
[verse]
'git checkout' [-q] [-f] [-m] [<branch>]
'git checkout' [-q] [-f] [-m] --detach [<branch>]
'git checkout' [-q] [-f] [-m] [--detach] <commit>
'git checkout' [-q] [-f] [-m] [[-b|-B|--orphan] <new_branch>] [<start_point>]
'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>...
'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]
'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]

DESCRIÇÃO
---------
Atualiza arquivos na árvore de trabalho para corresponder à versão no índice
ou na árvore especificada.  Caso nenhum caminho "pathspec" seja fornecido o
'git checkout' também atualizará `HEAD` definindo o ramo especificado como o
ramo atual.

'git checkout' [<branch>]::
	Para se preparar para trabalhar em `<branch>`, alterne para ele atualizando
	o índice e os arquivos na árvore de trabalho ao apontar para HEAD na
	ramificação. As modificações locais nos arquivos na árvore de trabalho são
	mantidas para que commits possam ser feitas no `<branch>`.
+
Caso o `<branch>` não seja encontrado mas existir uma ramificação de
rastreamento em um ponto remoto (chame-o de `<remoto>`) com um nome
correspondente e quando `--no-guess` não for especificado, trate-o como um
equivalente a
+
------------
$ git checkout -b <branch> --track <remote>/<branch>
------------
+
Você pode omitir o `<branch>` no caso em que o comando se degenera para
"verificar o branch atual", que é um glorificado não-op com efeitos
colaterais bastante caros para mostrar apenas as informações de
rastreamento, caso exista, para o branch atual.

'git verificar' -b|-B <novo_branch> [<start point>]::

	Especificar `-b` faz com que uma nova ramificação seja criada como se
	linkgit:git-branch[1] fosse chamado e, em seguida, retirado. Neste caso você
	pode usar as opções `--track` ou` --não-track`, que serão passadas para 'git
	branch'. Por conveniência, `--track` sem` -b` implica criação de
	ramificação; veja a descrição de `--track` abaixo.
+
Caso `-B` seja dado, o `<novo_branch>` é criado se ainda não existir; caso
contrário, é redefinido. Este é o equivalente transacional de
+
------------
$ git branch -f <branch> [<ponto de partida>]
$ git verificar <branch>
------------
+
isto é, a ramificação não é redefinida/criada a menos que "git verificar"
seja bem-sucedido.

'git verificar' --desanexar [<branch>]::
'git verificar' [--desanexar] <commit>::

	Prepare-se para trabalhar em cima de `<commit>`, desanexando o `HEAD` nele
	(consulte a seção "DESTACADO HEAD") e atualizando o índice e os arquivos na
	árvore de trabalho.  As modificações locais nos arquivos na árvore de
	trabalho são mantidas de forma que a árvore de trabalho resultante seja o
	estado registrado no commit, mais as modificações locais.
+
Quando o argumento `<commit>` é um nome de ramificação a opção `--detach`
pode ser usada para desanexar o `HEAD` na ponta da ramificação (` git
checkout <branch>` verificaria aquela ramificação sem desanexar o `HEAD`).
+
Ao omitir o `<branch>` isso desanexa o `HEAD` na ponta do ramo atual.

'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>...::
'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]::

	Overwrite the contents of the files that match the pathspec.  When the
	`<tree-ish>` (most often a commit) is not given, overwrite working tree with
	the contents in the index.  When the `<tree-ish>` is given, overwrite both
	the index and the working tree with the contents at the `<tree-ish>`.
+
O índice pode conter entradas não mescladas devido a uma mesclagem anterior
com falha.  Por padrão, se você tentar verificar essa entrada do índice, a
operação de check-out falhará e nada será retirado. Usar `-f` irá ignorar
essas entradas não-mescladas.  O conteúdo de um lado específico da mesclagem
pode ser retirado do índice usando `--ours` ou` --theirs`.  Com `-m`, as
alterações feitas no arquivo da árvore de trabalho podem ser descartadas
para recriar o resultado da mesclagem original em conflito.

'git verificar' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]::
	Isso é semelhante ao modo anterior, porém permite usar a interface
	interativa para mostrar a saída "diff" e escolher quais blocos usar no
	resultado.  Veja abaixo a descrição da opção `--patch`.

OPÇÕES
------
-q::
--quiet::
	Silencioso, suprima as mensagens de feedback.

--progress::
--no-progress::
	O status de progresso é relatado no fluxo de erro padrão por padrão quando
	ele é anexado a um terminal, a menos que `--quiet` seja especificado. Este
	sinalizador permite relatórios de progresso, mesmo que não estejam anexados
	a um terminal, independentemente de `--quiet`.

-f::
--force::
	Ao alternar as ramificações, continue mesmo se o índice ou a árvore de
	trabalho forem diferentes do `HEAD`.  Isto é usado para descartar as
	alterações locais.
+
Ao verificar os caminhos do índice, não falhe em entradas não mescladas; Em
vez disso, as entradas não mescladas são ignoradas.

--ours::
--theirs::
	Ao verificar os caminhos do índice, confira o estágio #2 ('nosso') ou #3
	('deles') para paths não mesclados.
+
Note que durante o `git rebase` e` git pull --rebase`, 'ours' e 'theirs'
podem aparecer trocados; `--ours` fornece a versão da ramificação onde as
alterações são feitas, enquanto` --theirs` fornece a versão da ramificação
que contém o seu trabalho que está sendo rebaixado.
+
Isso ocorre porque o `rebase` é usado em um fluxo de trabalho que trata o
histórico no remoto como o canônico compartilhado e trata o trabalho
realizado na ramificação que você está rebaixando como o trabalho de
terceiros a ser integrado, e você está temporariamente assumindo o papel do
guardião da história canônica durante o rebase.
 Como guardião da história canônica, você precisa ver a história do controle
remoto como "nosso" (isto é, "nossa história canônica compartilhada"),
enquanto o que você fez em seu ramo lateral como "seu" (isto é, "um trabalho
de colaborador" em cima dele ").

-b <novo_branch>::
	Crie uma nova ramificação chamada `<new_branch>` e inicie-a em
	`<start_point>`; para mais detalhes consulte linkgit:git-branch[1].

-B <novo_branch>::
	Cria uma nova ramificação `<new_branch>` e a inicia em `<start_point>`; caso
	já exista, então reinicia em `<start_point>`. Isso é o equivalente que rodar
	"git branch" com "-f"; para mais detalhes consulte linkgit:git-branch[1].

-t::
--track::
	Ao criar um novo branch, configure "upstream". Veja "--track" em
	linkgit:git-branch[1] para detalhes.
+
Se nenhuma opção `-b` for dada o nome da nova ramificação será derivada da
ramificação remota, observando-se a parte local do "refspec" configurada
para a sua correspondente remota, em seguida, removendo a parte inicial para
o "*".  Isto nos mostra para usar `hack` como uma ramificação local ao se
ramificar de `remotes/origin/hack` ou até mesmo
`refs/remotes/origin/hack`).  Caso o nome dado não tenha barra ou se a
suposição acima resultar em um nome vazio, a adivinhação será abortada. Você
pode dar explicitamente em tal caso um nome com a opção `-b`.

--no-track::
	Não configure "upstream" mesmo que a variável de configuração
	`branch.autoSetupMerge` seja verdadeira.

--guess::
--no-guess::
	Caso `<branch>` não seja encontrado mas existir uma ramificação de
	rastreamento em exatamente uma localidade remota (chame-o <remoto>) com um
	nome correspondente, trate como equivalente a
+
------------
$ git checkout -b <branch> --track <remote>/<branch>
------------
+
Se o branch existir em múltiplos controles remotos e um deles for nomeado
pela variável de configuração `verificar.padrãoRemoto`, usaremos aquele para
propósitos de desambiguação, mesmo que o` <branch> `não seja único em todos
os remotos . Definir como, por exemplo `verificar.padrãoRemoto=origem` para
sempre verificar as ramificações remotas de lá se` <branch> `for ambíguo,
mas existir no remoto de 'origem'. Veja também `verificar.padrãoRemoto` no
linkgit:gitconfig[1].
+
Use `--no-guess` to disable this.

-l::
	Crie o reflog da nova ramificação; veja linkgit:git-branch[1] para detalhes.

--detach::
	Em vez de verificar um ramo para trabalhar nele, confira um commit para
	inspeções e experiências descartáveis.  Este é o comportamento padrão de
	`git checkout <commit>` quando `<commit>` não for um nome de
	ramificação. Veja a seção "DESASSOCIANDO O HEAD" abaixo para detalhes.

--orfão <novo_branch>::
	Crie uma nova ramificação 'orphan' denominada `<new_branch>` iniciada a
	partir do <start_point> e mude para ela. O primeiro commit feito nesta nova
	ramificação não terá matrizes e será a raiz de uma nova história totalmente
	desconectada de todas as outras ramificações e commits.
+
O índice e a árvore de trabalho são ajustadas como se você tivesse executado
`git checkout <start_point>` anteriormente. Isso permite que você inicie um
novo histórico que registra um conjunto de "paths" semelhante ao
`<start_point>` sendo executado facilmente com `git commit -a` para fazer o
commit principal.
+
Isso pode ser útil quando você deseja publicar a árvore de um commit sem
expor seu histórico completo. Você pode querer fazer isso para publicar uma
ramificação de código aberto de um projeto cuja árvore atual esteja "limpa",
mas cujo histórico completo contenha bits de código proprietários ou de
outra forma onerados.
+
Caso queira iniciar um histórico desconectado que registra um conjunto de
caminhos totalmente diferente do `<start_point>`, então você deve limpar o
índice e a árvore de trabalho logo após criar a ramificação órfã executando
`git rm -rf.` do topo da árvore de trabalho. Depois disso, você estará
pronto para preparar os seus novos arquivos, preenchendo a árvore de
trabalho, copiando-os de outro lugar, extraindo um tarball, etc.

--ignore-skip-worktree-bits::
	No modo de checkout esparso, o comando `git checkout -- <paths>` atualizaria
	apenas as entradas correspondidas por `<paths>` e os padrões esparsos em
	`$GIT_DIR/info/sparse-checkout`. Esta opção ignora os padrões esparsos e
	adiciona de volta os arquivos em `<paths>`.

-m::
--merge::
	Ao alternar ramificações, se você tiver modificações locais em um ou mais
	arquivos que sejam diferentes entre a ramificação atual e a ramificação para
	a qual você está alternando, o comando se recusará a alternar as
	ramificações para preservar suas modificações no contexto.  No entanto, com
	essa opção, uma mesclagem de três vias entre a ramificação atual, o conteúdo
	da árvore de trabalho e a nova ramificação é concluída e você estará na nova
	ramificação.
+
Quando ocorre um conflito de mesclagem, as entradas de índice para caminhos
conflitantes são deixadas sem migração, e você precisa resolver os conflitos
e marcar os paths resolvidos com `git add` (ou` git rm` se a mesclagem
resultar na exclusão do caminho) .
+
Ao efetuar o check-out de caminhos do índice, essa opção permite recriar a
mesclagem conflitante nos caminhos especificados.
+
When switching branches with `--merge`, staged changes may be lost.

--conflito=<estilo>::
	O mesmo que a opção `--merge acima` porém altera a forma como os blocos
	conflitantes são apresentados, substituindo a variável de configuração
	`merge.conflictStyle`.  Os valores possíveis são "merge" (padrão) e "diff3"
	(além do que é mostrado pelo estilo "merge", exibe o conteúdo original).

-p::
--patch::
	Selecione interativamente os pedaços na diferença entre o `<tree-ish>` (ou o
	índice, se não for especificado) e a árvore de trabalho.  Os pedaços
	escolhidos são então aplicados em reverso à árvore de trabalho (e caso um
	`<tree-ish>` for especificado, o índice).
+
Isso significa que você pode usar o `git checkout -p` para descartar
seletivamente as edições da sua árvore de trabalho atual. Veja a seção ``
Interactive Mode '' do linkgit:git-add[1] para aprender como operar o modo
`--patch`.
+
Note that this option uses the no overlay mode by default (see also
`--overlay`), and currently doesn't support overlay mode.

--ignore-other-worktrees::
	`git checkout` recusa-se quando a referência desejada já foi verificada por
	outra worktree. Esta opção faz com que verifique o ref fora de qualquer
	maneira. Em outras palavras, o ref pode ser mantido por mais de uma árvore
	de trabalho.

--overwrite-ignore::
--no-overwrite-ignore::
	Silently overwrite ignored files when switching branches. This is the
	default behavior. Use `--no-overwrite-ignore` to abort the operation when
	the new branch contains ignored files.

--recurse-submodules::
--no-recurse-submodules::
	Usando `--recurse-submodules` irá atualizar o conteúdo de todos os
	submódulos inicializados de acordo com o commit registrado no
	"superproject". Caso as modificações locais em um submódulo sejam
	sobrescritas, o check-out falhará, a menos que `-f` seja usado. Caso nada
	(ou `--no-recurse-submodules`)  seja usado, as árvores de trabalho dos
	submódulos não serão atualizadas. Assim como o linkgit:git-submodule[1],
	isso desanexará os submódulos do `HEAD`.

--overlay::
--no-overlay::
	In the default overlay mode, `git checkout` never removes files from the
	index or the working tree.  When specifying `--no-overlay`, files that
	appear in the index and working tree, but not in `<tree-ish>` are removed,
	to make them match `<tree-ish>` exactly.

--pathspec-from-file=<file>::
	Pathspec é passado em `<file>` em vez de argumentos da linha de
	comando. Caso `<file>` seja exatamente `-` então a entrada padrão é
	usada. Os elementos pathspec são separados por LF ou CR/LF. Os elementos
	pathspec podem ser citados conforme explicado na configuração da variável
	'core.quotePath' (consulte linkgit:git-config[1]). Consulte também
	`-pathspec-file-nul` e global `-literal-pathspecs`.

--pathspec-file-nul::
	Só faz algum sentido se for usado junto com `--pathspec-from-file`. Os
	elementos "pathspec" são separados com caracteres NUL e todos os outros
	caracteres são considerados de forma literal (incluindo novas linhas e
	citações).

<branch>::
	Ramificação que será extraída; se refere a um ramo (ou seja, um nome que
	quando preparado com "refs/heads/", for um "ref" válido) então este ramo é
	extraído. Caso contrário, caso se referira a um commit válido, seu `HEAD` se
	torna "desanexado" e você não está mais em nenhuma ramificação (veja abaixo
	para detalhes).
+
Você pode usar a sintaxe `@{- N}` para se referir ao último ramo/commit
finalizado usando a operação "git checkout". Você também pode especificar
`-` que é um sinônimo de`@{-1}`.
+
Como um caso especial, você pode usar `A...B` como um atalho para a
mesclagem na base de `A` e` B` se houver exatamente uma base a ser
mesclada. Você pode deixar de fora, no máximo, um de `A` e` B`, neste caso
ele é o padrão para `HEAD`.

<novo_branch>::
	Nome para o novo branch.

<ponto_de_partida>::
	O nome do commit na qual deve se iniciar uma nova ramificação; para mais
	detalhes consulte linkgit:git-branch[1]. Padrão para `HEAD`.
+
Como um caso especial, você pode usar `"A ... B"` como um atalho para a base
de mesclagem de `A` e` B` se houver exatamente uma base de merge. Você pode
deixar de fora, no máximo, um de `A` e` B`, caso em que o padrão é `HEAD`.

<tree-ish>::
	Árvore para checkout (quando os paths são dados). Se não especificado, o
	índice será usado.

\--::
	Não interprete mais argumentos como opções.

<pathspec>...::
	Limits the paths affected by the operation.
+
Para mais detalhes sobre a sintaxe <pathspec>, veja a entrada 'pathspec' em
linkgit:gitglossary[7].

CABEÇA DESTACADA
----------------
`HEAD` normalmente se refere a um branch ou ramificação de nome próprio
(como `master` por exemplo). Enquanto isso, cada ramo ou ramificação tem
como referência um "commit" específico. Vamos olhar para um repositório com
três commits onde um deles está marcado como ramificação `master`:

------------
           HEAD (refers to branch 'master')
            |
            v
a---b---c  branch 'master' (refers to commit 'c')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
------------

Quando uma confirmação é criada nesta condição a ramificação é atualizada
com referência ao novo commit. Especificamente, o comando 'git commit' cria
um novo commit `d`, cuja matriz é o commit 'c' e então atualiza o ramo
`master` para se referir ao novo commit `d`. `HEAD` ainda se refere à
ramificação `master` e então indiretamente agora se refere ao commit `d`:

------------
$ editar; git adicionar; git commit

               HEAD (refers to branch 'master')
                |
                v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
------------

Às vezes é útil poder fazer o checkout do nome de um commit que não esteja
no topo de qualquer ramificação ou mesmo criar um novo commit que não tenha
referência em uma ramificação conhecida por nome. Vejamos o que acontece
quando fazemos o checkout commit `b` (aqui demostramos duas maneiras de como
isso pode ser feito):

------------
$ git verificar v2.0  # ou
$ git verificar master^^

   HEAD (refers to commit 'b')
    |
    v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
------------

Observe que, independente do comando checkout usado o `HEAD` agora se refere
diretamente ao commit `b`. Isso é conhecido como condição em desanexo do
HEAD. Simplesmente significa que `HEAD` tem referência a um commit em
específico em vez de se referir ao nome de um ramo. Vejamos o que acontece
quando criamos um commit:

------------
$ editar; git adicionar; git commit

     HEAD (refers to commit 'e')
      |
      v
      e
     /
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
------------

Agora existe um novo commit `e`, com referência apenas em` HEAD`. Nessa
condição fica claro que podemos adicionar mais um commit:

------------
$ editar; git adicionar; git commit

	 HEAD (refers to commit 'f')
	  |
	  v
      e---f
     /
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
------------

De fato, podemos executar todas as operações normais do Git. Porém vejamos o
que acontece quando fazemos um checkout do `master`:

------------
$ git verificar master

               HEAD (refers to branch 'master')
      e---f     |
     /          v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')
------------

É importante perceber que neste momento nada se refere ao commit
`f`. Eventualmente o commit `f` (e de tabela o commit `e`) será excluído
pelo processo rotineiro da coleta de lixo do Git, antes que isso aconteça é
preciso criar uma referência. Se ainda não nos afastamos do commit `f`,
qualquer um deles criará uma referência a ele:

------------
$ git verificar -b foo   <1>
$ git branch foo        <2>
$ git tag foo           <3>
------------

<1> cria uma nova ramificação `foo` com referência ao commit `f`, atualiza HEAD
    com referência ao ramo `foo`. Isso significa que agora não estamos mais
    desanexados do `HEAD` após este comando.

<2> similarmente cria um novo ramo `foo` com referência ao commit `f` deixando
    `HEAD` desanexado.

<3> cria uma nova tag `foo`com referência ao commit `f` deixando HEAD
    desanexado.

Se nos afastamos do commit `f`, primeiro precisamos recuperar o nome do
objeto (normalmente usando git reflog) e em seguida, podemos criar uma
referência para ele. Para ver os dois últimos commits aos quais o `HEAD` se
refere, podemos usar um destes comandos, por exemplo:

------------
$ git reflog -2 HEAD # or
$ git log -g -2 HEAD
------------

DISAMBIGUAÇÃO DE ARGUMENTOS
---------------------------

Quando há apenas um argumento que não seja `--` (como `git checkout abc`) e
quando ambos os argumento `<tree-ish>` são válidos (como a existência do
ramo `abc`) e `<pathspec>` também for válido (caso um arquivo ou diretório
exista e cujo nome seja "abc" por exemplo), o Git normalmente solicita que
você desambigue. Contudo, como fazer o checkout de uma ramificação é uma
operação tão comum, o comando `git checkout abc` considera "abc" nessa
situação como `<tree-ish>`. Use `git checkout -- <pathspec>` caso queira
eliminar estes caminhos de dentro do índice.

EXEMPLOS
--------

. A sequência a seguir exclui o ramo `master`, reverte o` Makefile` para duas
  revisões anteriores, exclui o arquivo hello.c "por engano" e faz a
  recuperação do índice.
+
------------
$ git verificar master             <1>
$ git verificar master~2 Fazer arquivo  <2>
$ rm -f hello.c
$ git verificar hello.c            <3>
------------
+
<1> comutação de branch
<2> tirar um arquivo de outro commit
<3> restaura do índice o arquivo `hello.c`
+
Se você quiser dar uma olhada nos arquivos de código-fonte, todos fora do
índice, você pode dizer
+
------------
$ git verificar -- '*.c'
------------
+
Observe as aspas em torno de `* .c`.  O arquivo `hello.c` também será
retirado, mesmo que não esteja mais na árvore de trabalho, porque o
agrupamento de arquivos é usado para corresponder entradas no índice (não na
árvore de trabalho pelo shell).
+
Se você tem um ramo infeliz chamado `hello.c`, este passo seria confundido
como uma instrução para mudar para esse ramo.  Você deve escrever:
+
------------
$ git verificar -- hello.c
------------

. Depois de trabalhar no ramo errado, mudar para o ramo correto seria feito
  usando:
+
------------
$ git checkout meu tópico
------------
+
No entanto o seu ramo "errado" e o `mytopic` do ramo correto podem diferir
nos arquivos que você modificou localmente. Que dessa maneira, a verificação
acima falhará assim:
+
------------
$ git verificar meu tópico
erro: você tem alterações locais em 'frotz'; não comutação de branches.
------------
+
Você pode dar o sinalizador `-m` ao comando, que tentaria uma merge de três
vias:
+
------------
$ git verificar -m meu tópico
Auto-merging frotz
------------
+
Após essa mesclagem de três vias, as modificações locais não serão
registradas em seu arquivo de índice, portanto, o `git diff` mostrará quais
alterações foram feitas desde a dica da nova ramificação.

. Quando um conflito de mesclagem acontece durante a troca de branches com a
  opção `-m`, você veria algo assim:
+
------------
$ git verificar -m meu tópico
Auto-merging frotz
ERRO: Merger conflito em frotz
fatal: falha no programa de merge
------------
+
Neste ponto, o `git diff` mostra as mudanças mescladas como no exemplo
anterior, bem como as mudanças nos arquivos conflitantes.
 Editar e resolver o conflito e marcá-lo resolvido com `git add` como de
costume:
+
------------
$ editar frotz
$ git adicionar frotz
------------

VEJA TAMBÉM
-----------
linkgit:git-switch[1], linkgit:git-restore[1]

GIT
---
Parte do linkgit:git[1] suite
