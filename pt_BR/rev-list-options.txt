Limitação do Commit
~~~~~~~~~~~~~~~~~~~

Além de especificar uma série de commits que devem ser listados utilizando as notações especiais explicadas na descrição, podem ser aplicadas limitações adicionais ao commit.

O uso de mais opções geralmente limita ainda mais a saída (por exemplo, limites `--since=<date1>` para commits mais recentes que `<data1>`, e usá-lo com `--grep=<padrão>` limita ainda mais para os commits cuja mensagem de registro log possua uma linha que coincida com `<padrão>`), a menos que indicado de outra maneira.

Observe que eles são aplicados antes da organização do commit e das opções de formatação como `--reverse`.

-<quantidade>::
-n <quantidade>::
--max-count=<quantidade>::
	Limita a quantidade de commits na saída.

--skip=<quantidade>::
	Ignora a 'quantidade'de commits antes começa a exibir a saída do commit.

--since=<data>::
--after=<data>::
	Exiba os commits com data mais recente das que foram informada.

--since-as-filter=<data>::
	Mostra todos os commits mais recentes do que uma determinada data. Isso avalia todos os commits que estejam neste intervalo, em vez de parar no primeiro commit que for o mais antigo que uma determinada data.

--until=<data>::
--before=<data>::
	Exiba os commits mais antigos com data mais antiga das que foram informada.

ifdef::git-rev-list[]
--max-age=<timestamp>::
--min-age=<timestamp>::
	Limita a saída dos commits para um período de tempo específico.
endif::git-rev-list[]

--author=<padrão>::
--committer=<padrão>::
	Limite os commits gerados para aqueles com linhas de cabeçalho do autor e de quem fez o commit que coincida com determinado padrão (expressão regular). Com um ou mais de um `--author=<padrão>`, são selecionados os commits cujo autor coincida com qualquer um dos padrões informados (é similar para vários `--committer=<padrão>`).

--grep-reflog=<padrão>::
	Limite o commit gerado para aqueles com entradas de reflog que coincidam ao padrão informado (expressão regular). Com mais de uma opção `--grep-reflog`, são escolhidos os commits cuja mensagem do reflog coincida com qualquer um dos padrões informado. É um erro usar esta opção, a menos que o `--walk-reflogs` esteja em uso.

--grep=<padrão>::
	Limite o commit gerado para aqueles com mensagem do registro log que coincida ao padrão informado (expressão regular). Com mais de uma opção `--grep=<padrão>`, os commits cuja mensagem coincida com qualquer um dos padrões informados (porém consulte `--all-match`).
ifndef::git-rev-list[]
+
Quando `--notes` está em vigor, a mensagem das anotações é coincidida como se fizesse parte da mensagem do registro log.
endif::git-rev-list[]

--all-match::
	Limita a saída dos commits para aqueles que coincidam com todos os comandos `--grep` utilizado, em vez daqueles que coincidam com apenas um.

--invert-grep::
	Limita a saída dos commits para aqueles com uma mensagem do registro log que não coincida com o padrão utilizado em com o comando `--grep=<padrão>`.

-i::
--regexp-ignore-case::
	Coincida a expressão regular limitando o padrão sem considerar o tamanho das letras.

--basic-regexp::
	Considere os padrões limitadores como expressões regulares básicas; Essa é a predefinição.

-E::
--extended-regexp::
	Considere os padrões de limitação a serem estendidos nas expressões regulares em vez das expressões regulares básicas predefinidas.

-F::
--fixed-strings::
	Considere os padrões limitadores como cadeias de caracteres fixos (não interprete o padrão como uma expressão regular).

-p::
--perl-regexp::
	Considere os padrões limitadores como expressões regulares compatíveis com o Perl.
+
A compatibilidade para estes tipos de expressões regulares é uma dependência opcional no momento da compilação. Caso o Git não tenha sido compilado com este suporte, o Git será encerrado caso esta opção seja utilizada.

--remove-empty::
	Pare quando um caminho informado tenha desaparecido da árvore.

--merges::
	Exiba apenas os commits que foram mesclados. É exatamente o mesmo que a opção `--min-parents=2`.

--no-merges::
	Não imprima os commits com mais de um pai. É exatamente o mesmo que a opção `--max-parents=1`.

--min-parents=<quantidade>::
--max-parents=<quantidade>::
--no-min-parents::
--no-max-parents::
	Exibe apenas os commits que tenham pelo menos (ou no máximo) aquela quantidade de pais dos commits. Em particular, `--max-parents=1` é o mesmo que `--no-merges`, `--min-parents=2` é o mesmo que `--merges`. A opção `--max-parents=0` informa todos os commits raiz e `--min-parents=3` todas as mesclagens "polvo".
+
As opções `--no-min-parents` e `--no-max-parents` redefinem estes limites (para nenhum limite) novamente. As formas equivalentes são `--min-parents=0` (qualquer commit que tenha 0 ou mais pais) e `--max-parents=-1` (os números negativos indicam nenhum limite acima).

--first-parent::
	Ao encontrar os commits que serão incluídos, siga apenas o primeiro commit principal ao ver a mesclagem de um commit. Essa opção pode lhe fornecer uma melhor visão geral durante a visualização da evolução de um tópico específico no ramo, pois faz a mesclagem em um tópico no ramo e tende a ser apenas sobre o ajuste das atualizações upstream de tempos em tempos, esta opção permite ignorar os commits individuais trazidas para o seu histórico feitas por essa mesclagem.
ifdef::git-log[]
+
Esta opção também muda o formato diff padrão para a mesclagem dos commits para `first-parent`, consulte `--diff-merges=first-parent` para mais detalhes.
endif::git-log[]

--exclude-first-parent-only::
	Ao encontrar os commits para serem excluídos (com um '{caret}'), siga apenas o primeiro commit principal ao ver um commit para ser mesclado. Isso pode ser usado para encontrar o conjunto de alterações num determinado ramo a partir do ponto em que ele divergiu do ramo remoto, dado que as mesclagens arbitrárias podem ser alterações válidas no tópico do ramo.

--not::
	Inverte o significado do prefixo '{cursor}' (ou falta dele) para todos os especificadores das revisões seguintes, até o próximo `--not`.

--all::
	Finja como se todos os refs em `refs/` junto com `HEAD` estejam listados na linha de comando como '<commit>'.

--branches[=<padrão>]::
	Finja como se todas as refs no `refs/heads` estejam listadas na linha de comando como '<commit>'. Caso '<padrão>' seja utilizado, limite os ramos para aqueles que coincidam com a "shell blob" informada. Caso o padrão não tenha '?', '{asterisco}', ou '[', '/{asterisco}' no final é implícito.

--tags[=<padrão>]::
	Finja como se todas as refs no `refs/remotes` estejam listados na linha de comando como '<commit>'. Caso '<padrão>' seja utilizado, limite os ramos para aqueles que coincidam com a "shell blob" informada. Caso o padrão não tenha '?', '{asterisco}', ou '[', '/{asterisco}' no final é implícito.

--remotes[=<padrão>]::
	Finja como se todos as refs no `refs/remotes` estejam listados na linha de comando como '<commit>'. Caso um '<padrão>' seja utilizado, limite as ramificações rastreadas remotamente que coincidam com aqueles da "shel glob" informada. Caso o padrão não tenha '?', '{asterisco}', ou '[', '/{asterisco}' no final é implícito.

--glob=<glob-pattern>::
	Finja como se todos as refs coincidentes com "shell glob" '<glob-pattern>' estejam listados na linha de comando como '<commit>'. A 'refs/' principal é anexada automaticamente caso esteja ausente. Caso o padrão não tenha '?', '{asterisco}', ou '[', '/{asterisco}' no final é implícito.

--exclude=<glob-pattern>::

	Não inclua as refs que coincidam com `<glob-pattern>` em que as próximas opções `--all`, `--branches`, `--tags`, `--remotes` ou `--glob` considerariam de outra forma. As repetições destas opções acumulam padrões de exclusão até a próxima opção `--all`, `--branches`, `--tags`, `--remotes` ou `--glob` (outras opções ou argumentos não limpam os padrões acumulados).
+
Os padrões informados não devem começar com `refs/heads`, `refs/tags`, ou `refs/remotes` quando aplicadas as opções `--branches`, `--tags`, ou `--remotes` respectivamente, e devem começar com `refs/` quando for aplicado ao `--glob` ou `--all`. Se a intenção for um delimitador '/{asterisco}', este deve ser utilizado de forma explicita.

--exclude-hidden=[receive|uploadpack]::
	Não inclua refs que seriam ocultados por `git-receive-pack` ou `git-upload-pack` durante a consulta da configuração apropriada de `receive.hideRefs` ou `uploadpack.hideRefs` junto com `transfer.hideRefs` (consulte linkgit :git-config[1]). Esta opção afeta a próxima opção pseudo-ref `--all` ou `--glob` e é zerada após o processamento.

--reflog::
	Finja que todos os objetos mencionados pelos `reflogs` estejam listados na linha de comando como `<commit>`.

--alternate-refs::
	Finja como se todos os objetos mencionados como dicas "ref" dos repositórios alternativos fossem listados na linha de comando. Um repositório alternativo é qualquer repositório cujo diretório dos objetos seja definido no `objects/info/alternates`. O conjunto dos objetos incluídos podem ser modificados pelo `core.alternateRefsCommand`, etc. Consulte linkgit:git-config[1].

--single-worktree::
	É predefinido que todas as árvores de trabalho serão examinadas através das seguintes opções quando houver mais de uma (consulte linkgit:git-worktree[1]): `--all`, `--reflog` e `--indexed-objects`. Esta opção impõem o exame seja feito apenas na árvore de trabalho atual.

--ignore-missing::
	Ao ver um nome de objeto inválido na entrada, finja que a entrada incorreta não foi informada.

ifndef::git-rev-list[]
--bisect::
	Finja como se uma bisseção ruim "ref" `refs/bisect/bad` estivesse listada e como se fosse seguida por `--not` e a boa bisseção refs `refs/bisect/good-*` na linha de comando.
endif::git-rev-list[]

--stdin::
	Além dos '<commits>' listados na linha de comando, leia-os na entrada padrão. Caso um separador `--` seja visto, pare de ler os commits e comece a ler os caminhos para limitar o resultado.

ifdef::git-rev-list[]
--quiet::
	Não imprima nada na saída padrão. Este formulário tem como principal objetivo, permitir que a pessoa que chame, teste a condição da saída para verificar se um conjunto de objetos está totalmente conectado (ou não). É mais rápido que redirecionar o stdout para `/dev/null`, pois a saída não precisa ser formatada.

--disk-usage::
--disk-usage=human::
	Suprime a saída normal; em vez disso, imprime a soma dos bytes usados para o armazenamento em disco feito pelos commits ou pelos objetos que foram selecionados. Isso é equivalente a canalizar a saída para `git cat-file --batch-check='%(objectsize:disk)'`, exceto que ele roda muito mais rápido (especialmente com `--use-bitmap-index`). Consulte a seção `RESSALVAS` em linkgit:git-cat-file[1] para conhecer o significado da limitações do "armazenamento em disco". Com o valor opcional `human`, o tamanho do armazenamento no disco será mostrado numa string humanamente legível (12,24 Kib, 3,50 Mib por exemplo).
endif::git-rev-list[]

--cherry-mark::
	Como `--cherry-pick` (veja abaixo), porém marque os commits equivalentes com `=` ao invés de omiti-los e equivalentes com `+`.

--cherry-pick::
	Omitir qualquer commit que apresente a mesma alteração como em outro commit do ``outro lado" quando o conjunto de commits são limitadas com diferença simétrica.
+
Como por exemplo, caso você tenha dois ramos, `A` e `B`, uma maneira comum de listar todos os commits em apenas um lado deles é com a opção `--left-right` (veja o exemplo abaixo na descrição da opção `--left-right`). No entanto, exibe os commits que foram selecionados de forma seletiva no outro ramo (por exemplo, ``3º no b'' pode ser a escolha seletiva do ramo `A`). Com esta opção, estes pares de commits são excluídos da saída.

--left-only::
--right-only::
	Liste apenas os commits nos respectivos lados de um "diff" simétrico, ou seja, apenas aqueles que seriam marcados como `<` resp. `>` por `--left-right`.
+
Por exemplo, a opção `--cherry-pick --right-only A...B` omite os commits de `B` que estão em `A` ou são equivalentes ao patch para um commit em `A`. Em outras palavras, lista os commits com sinal `+` do `git cherry A B`. Mais precisamente, `--cherry-pick --right-only --no-merges` informa a lista exata.

--cherry::
	Um sinônimo para `--right-only --cherry-mark --no-merges`; útil para limitar a saída dos commits do nosso lado e marcar aqueles que forem marcados no histórico bifurcado do outro lado com `git log --cherry upstream...meu-ramo`, semelhante ao `git cherry upstream meu-ramo`.

-g::
--walk-reflogs::
	Em vez de percorrer a cadeia de ancestralidade do commit, passe pelas entradas do reflog vindo da mais recente para as mais antigas. Quando esta opção é utilizada, você não pode definir os commits para exclusão (ou seja, as notações '{caret}commit', 'commit1..commit2' e 'commit1\...commit2' não podem ser utilizadas).
+
Com o formato `--pretty` diferente do `oneline` e `reference` (por razões óbvias), isto faz com que a saída tenha duas linhas extras das informações extraídas do reflog. O designador reflog na saída pode ser exibido como `ref@{Nth}` (onde `Nth` é o índice cronológico reverso no reflog) ou como `ref@{timestamp}` (com o registro de data e hora para esta entrada), dependendo de algumas regras:
+
--
1. Caso o ponto inicial seja utilizado como `ref@{Nth}`, exiba o formato do índice.
+
2. Caso o ponto inicial seja utilizado como `ref@{now}`, exiba o formato do registro de data e hora.
+
3. Caso nenhum deles tenha sido utilizado, mas a opção `--data` foi utilizado na linha de comando, exibe o registro de data e hora no formato solicitado por `--data`.
+
4. Caso contrário, exibe o formato do índice.
--
+
Em `pretty=oneline`, a mensagem do commit é prefixada com estas informações na mesma linha. Esta opção não pode ser combinada com `--reverse`. Consulte também linkgit:git-reflog[1].
+
Esta informação não será exibida de forma alguma sob `--pretty = reference`.

--merge::
	Após uma falha na mesclagem, exiba as refs que estão em atrito com os arquivos e não existam em todos os `HEADS` que serão mesclados.

--boundary::
	O limite da exclusão dos commits que forem gerados. Os limites entre os commits são prefixados com `-`.

ifdef::git-rev-list[]
--use-bitmap-index::

	Tente acelerar a passagem usando o índice do pacote bitmap (caso haja um disponível). Observe que ao percorrer com `--objects`, as árvores e as bolhas não terão o seu caminho associado impresso.

--progress=<header>::
	Exibe os relatórios de progresso no stderr à medida que os objetos são considerados. O texto `<header>` será impresso a cada atualização do progresso.
endif::git-rev-list[]

Simplificação do histórico
~~~~~~~~~~~~~~~~~~~~~~~~~~

Às vezes, você está interessado apenas nas partes do histórico, por exemplo, os commit que alteraram um determinado <caminho>. Porém existem duas partes da 'Simplificação do Histórico', uma parte é a seleção dos commits e a outra é como fazê-lo, pois existem várias estratégias para simplificar o histórico.

As seguintes opções selecionam os commits que serão exibidos:

<caminhos>::
	São selecionados os commits que alterarem os <caminhos> informados.

--simplify-by-decoration::
	São selecionados os commits utilizados como referência por algumas ramificações ou tags.

Observe que os commits extras podem ser exibidos para fornecer um histórico significativo.

As seguintes opções afetam a maneira como a simplificação é feita:

Modo predefinido::
	Simplifique o histórico para o mais simples, explicando a condição final da árvore. Mais simples, porque elimina algumas ramificações laterais caso o resultado final for o mesmo (ou seja, mescle os ramos com o mesmo conteúdo)

--show-pulls::
	Inclua todas os commits no modo predefinido, porém também qualquer commits mesclado que não sejam 'TREESAME' para o primeiro parente, porém sejam 'TREESAME' para um parente posterior. Este modo auxilia na exibição do commit mesclado que "introduziu primeiro" a alteração em um ramo.

--full-history::
	O mesmo que o modo predefinido, mas não corta parte do histórico.

--dense::
	Apenas os commits selecionados são exibidos e mais alguns que tenham algum histórico significante.

--sparse::
	São exibidos todos os commits com um histórico simplificado.

--simplify-merges::
	Opção adicional para `--full-history` para remover algumas mesclagens desnecessárias do histórico resultante, pois não há commits selecionados contribuindo para essa mesclagem.

--ancestry-path[=<commit>]::
	Ao receber um intervalo de commits para mostrar ('commit1..commit2' ou 'commit2 {caret}commit1' por exemplo), exibe apenas os commits nesse intervalo que sejam ancestrais do <commit>, descendentes do <commit> ou o <commit> em si. Caso nenhum commit seja definido, use 'commit1' (a parte excluída do intervalo) como <commit>. Pode ser passado mais de uma vez; em caso afirmativo, um commit é incluído caso seja qualquer um dos commits informados ou caso seja um ancestral ou descendente de um deles.

Segue explicações com mais detalhes.

Suponha que você defina `foo` como o <caminho>. Vamos chamar os commits que alteraram `foo` '!TREESAME', e o restante 'TREESAME'. (Em um diff filtrado pelo `foo`, eles parecem diferentes e iguais, respectivamente.)

A seguir, sempre nos referiremos ao mesmo exemplo do histórico para ilustrar as diferenças entre as configurações de simplificação. Assumimos que esteja filtrando um arquivo `foo` neste grafo do commit:
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /   /
	I     B   C   D   E   Y
	 \   /   /   /   /   /
	  `-------------'   X
-----------------------------------------------------------------------
A linha horizontal do histórico 'A---Q' é considerada o primeira origem de cada mesclagem. Os commits são:

* O `I` é o commit inicial onde `foo` existe com o conteúdo ``asdf'' e existe um arquivo `quux` com o conteúdo` `quux ''. Os commits iniciais são comparados com uma árvore vazia, então o `I` é !TREESAME.

* Em `A`, `foo` contém apenas ``foo''.

* O `B` contém a mesma alteração que `A`. A mesclagem `M` é trivial e portanto, 'TREESAME' para todos os pais.

* O `C` não muda `foo`, mas a sua mesclagem `N` o altera para ``foobar'', portanto não é 'TREESAME' para nenhum dos pais.

* `D` define `foo` para ``baz''. Mescla `O` combinado com textos vindos de ` N` e `D` a ``foobarbaz''; ou seja, não é "TREESAME" para nenhuma das origens.

* O `E` altera `quux` para ``xyzzy'' e a sua mesclagem `P` combina as sequências dos caracteres para ``quux xyzzy''. O `P` é 'TREESAME' para `O`, porém não para `E`.

* O `X` é um commit raiz independente que adicionou um novo arquivo `side`, e `Y` o alterou. O `Y` é 'TREESAME' para `X`. Mescla `Q` adicionou `side` para `P`, e `Q` e 'TREESAME' para `P`, mas não para `Y`.

O `rev list` retrocede no histórico, incluindo ou excluindo os commits com base no uso do `--full-history` e/ou na reescrita dos pais (através da opção `--parents` ou `--children`). As seguintes configurações estão disponíveis.

Modo predefinido::
	Os commits serão incluídas caso não sejam 'TREESAME' para nenhum dos parentes (embora isso possa ser alterado, consulte a opção `--sparse` abaixo). Se o commit foi uma mesclagem e também foi um 'TREESAME' para um parente, siga apenas este parente. (Mesmo que haja vários parentes 'TREESAME', siga apenas um deles.) Caso contrário, siga todos.
+
Isso resulta em:
+
-----------------------------------------------------------------------
	  .-A---N---O
	 /     /   /
	I---------D
-----------------------------------------------------------------------
+
Observe como a regra para seguir apenas a origem TREESAME, caso haja um, removeu `B` completamente. `C` foi considerado através do `N`, mas é o TREESAME. Os commits raiz são comparadas com uma árvore vazia, então `I` é !TREESAME.
+
As relações entre pai/filho são visíveis apenas com `--parents`, porém isso não afeta os commits selecionados no modo predefinido, portanto, mostramos as linhas dos pais.

`--full-history` sem reescrita anterior::
	Este modo difere da predefinição em um ponto: sempre siga todos os pais de uma mesclagem, mesmo que seja 'TREESAME' para um deles. Mesmo se mais de um lado da mesclagem tiver commits que estejam inclusos, isso não implica que a própria mesclagem seja! No exemplo, nós temos
+
-----------------------------------------------------------------------
	I  A  B  N  D  O  P  Q
-----------------------------------------------------------------------
+
O `M` foi excluído porque é 'TREESAME' para ambos os pais. `E`, `C` e `B` foram todos percorridos, porém apenas `B` foi '!TREESAME', para que os outros não apareçam.
+
Observe que, sem reescrever os pais, não é realmente possível falar sobre os relacionamentos pai/filho entre os commits, portanto, mostramos-lhes desconectados.

`--full-history` com reescrita anterior::
	Os commits comuns são incluídos apenas se forem '!TREESAME' (embora é possível alterar isso, consulte `--sparse` abaixo).
+
As mesclagens estão sempre inclusas. No entanto, sua lista de origens é reescrita: em cada origem, remova os commit que não foram inclusos. Isto resulta no
+
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /
	I     B   /   D   /
	 \   /   /   /   /
	  `-------------'
-----------------------------------------------------------------------
+
Compare com a opção `--full-history` sem reescrever acima. Observe que `E` foi removido porque é um 'TREESAME', porém a lista dos parentes `P` foi reescrita para conter `E` parente do `I`. O mesmo aconteceu para `C` e `N`, e `X`, `Y` e `Q`.

Além das configurações acima, é possível alterar se o 'TREESAME' afeta a inclusão:

--dense::
	Os commits encaminhados serão incluídos caso não sejam um 'TREESAME' para nenhum dos parentes.

--sparse::
	Todos os commits que forem passados serão incluidos.
+
Observe que sem o `--full-history', isso ainda simplifica as mesclagens: caso um dos pais seja 'TREESAME', seguiremos apenas este, para que os outros lados da mesclagem nunca sejam percorridos.

--simplify-merges::
	Primeiro, construa um grafo do histórico da mesma maneira que `--full-history` com a reescrita dos parentes (veja acima).
+
Simplifique cada commit `C` para a sua reposição `C'` no histórico final, de acordo com as seguintes regras:
+
--
* Defina `C'` para `C`.
+
* Substitua cada pai `P` do `C'` por sua simplificação `P'`. No processo, solte os pais que são ancestrais dos outros pais ou que os commits raiz 'TREESAME' em uma árvore vazia e remova as duplicatas, porém tome cuidado para nunca descartar todos os pais já que somos 'TREESAME' também.
+
* Se após esta reescrita da origem, o `C'` for um commit raiz ou uma mesclagem (tem zero ou > origens), um commit limite ou !TREESAME, será mantido. Caso contrário, será substituído pela sua única origem.
--
+
O efeito disso é melhor mostrado através da comparação com a opção `--full-history` com a reescrita dos pais. O exemplo se transforma em:
+
-----------------------------------------------------------------------
	  .-A---M---N---O
	 /     /       /
	I     B       D
	 \   /       /
	  `---------'
-----------------------------------------------------------------------
+
Observe que as maiores diferenças entre `N`, `P`, e `Q` sobre `--full-history`:
+
--
* A lista dos pais de `N` teve `I` removida, porque é um ancestral do outro pai `M`. Ainda assim, `N` permaneceu porque é '!TREESAME'.
+
* A lista de pais de `P` também removeu o `I`. O `P` foi então removido completamente, porque tinha um pai e é 'TREESAME'.
+
* A lista de pais de `Q` tinha` Y` simplificado para `X`. O `X` foi então removido, porque era uma raiz 'TREESAME'. O `Q` foi removido completamente, porque tinha um pai e é 'TREESAME'.
--

Há um outra modo de simplificação disponível:

--ancestry-path[=<commit>]::
	Limite os commits exibidos àqueles que sejam ancestrais do <commit>, ou que sejam descendentes do <commit>, ou são o <commit> em si.
+
Como um exemplo de caso, considere o seguinte histórico do commit:
+
-----------------------------------------------------------------------
	    D---E-------F
	   /     \       \
	  B---C---G---H---I---J
	 /                     \
	A-------K---------------L--M
-----------------------------------------------------------------------
+
Um 'D..M' regular calcula o conjunto dos commits que são ancestrais do `M`, mas exclui os que são ancestrais do `D`. Isso é útil para ver o que aconteceu com a história que levou a `M` desde o `D`, no sentido que ``o que `M` possui e que não existia em `D`''. O resultado neste exemplo seria todos os commits, exceto `A` e `B` (e `D`, obviamente).
+
Quando queremos descobrir o qual commit em `M` está contaminado com o bug introduzido por `D` e precisa ser corrigido, contudo, podemos querer visualizar apenas o subconjunto 'D..M' que são realmente descendentes do `D`, por exemplo, excluindo `C` e `K`. É exatamente isso que a opção `--ancestry-path` faz. Aplicado à faixa 'D..M', resulta em:
+
-----------------------------------------------------------------------
		E-------F
		 \       \
		  G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
Também podemos usar `--ancestry-path=D` em vez de `--ancestry-path` que significa a mesma coisa quando é aplicado ao intervalo 'D..M', porém, é apenas mais explícito.
+
Se, em vez disso, estivermos interessados num determinado assunto dentro desse intervalo e todos os commits afetados por esse assunto, podemos querer apenas visualizar o subconjunto de `D..M` que contém esse assunto em seu caminho ancestral. Então, ao usar `--ancestry-path=H D..M`, por exemplo, resultaria em:
+
-----------------------------------------------------------------------
		E
		 \
		  G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
Onde `--ancestry-path=K D..M` resultará em
+
-----------------------------------------------------------------------
		K---------------L--M
-----------------------------------------------------------------------

Antes de discutir outra opção, `--show-pulls`, precisamos criar um novo histórico de exemplo.

Um problema comum que os usuários enfrentam ao examinar o histórico simplificado é que um commit que eles conhecem alterou um arquivo e que de alguma maneira não aparece no histórico simplificado do arquivo. Vamos demonstrar um novo exemplo e exibir como as opções como `--full-history` e `--simplify-merges` funcionam neste caso:

-----------------------------------------------------------------------
	  .-A---M-----C--N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`-Z'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `---Y--'
-----------------------------------------------------------------------

Para este exemplo, suponha que `I` tenha criado o `file.txt` que foi modificado por `A`, `B` e` X` de maneiras diferentes. O único parente fa o commit `C`, `Z` e `Y` não alteram o `file.txt`. O commit mesclado `M` foi criado resolvendo o conflito da mesclagem para incluir as alterações de `A` e `B`, portanto, também não é um 'TREESAME'. O commit mesclado `R`, no entanto, foi criado ignorando o conteúdo do `file.txt` no `M` e levando apenas o conteúdo de `file.txt` no `X`. Portanto, `R` é o 'TREESAME' para `X`, mas não para `M`. Finalmente, a resolução de mesclagem natural para criar `N` é levar o conteúdo do `file.txt` para `R`, de modo onde `N` seja um 'TREESAME' para `R`, mas não para `C`. O commit mesclado `O` e `P` são 'TREESAME' para seus primeiros parentes, mas não para seus os parentes secundários, `Z` e `Y` respectivamente.

Ao utilizar os modos predefinidos, ambos os `N` e `R` tem um pai TREESAME, então aquelas bordas são percorridas e outras são ignoradas. E o grafo resultante no histórico é:

-----------------------------------------------------------------------
	I---X
-----------------------------------------------------------------------

Ao utilizar a opção `--full-history`, O Git percorre cada canto. Descobre se os commits `A`, `B` e o mesclado `M`, porém também revela se o commit mesclado `O` e `P`. Com a reescrita do pai, o resultado do grafo é:

-----------------------------------------------------------------------
	  .-A---M--------N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`--'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `------'
-----------------------------------------------------------------------

Aqui, a mesclagem do commit `O` e `P` contribuem com um ruído extra, pois na verdade não contribuíram com uma alteração no `file.txt`. Eles mesclaram apenas um 'topic' com base numa versão mais antiga do `file.txt`. Este é um problema comum em repositórios que utilizam um fluxo de trabalho onde que muitos colaboradores trabalham em paralelo e mesclam as suas ramificações dos tópicos em um único tronco: muitas mesclagens não relacionadas aparecem nos resultados da opção `--full-history`.

Ao utilizar a opção `--simplify-merges`, os commits `O` e `P` desaparecem dos resultados. Pois as reescritas do segundo pai de `O` e `P` são acessíveis a partir dos seus primeiros pais. Estes cantos são removidos e então os commits se parecem com commits com pai singular só que são TREESAME em relação aos seus pais. Isso também acontece ao commit `N`, resultando no histórico a seguir:

-----------------------------------------------------------------------
	  .-A---M--.
	 /     /    \
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------

Nesta visão, vemos todas as alterações importantes da única origem vindas de `A`, `B` e `X`. Também vemos a mesclagem cuidadosamente resolvida de `M` e a mesclagem nem tão bem resolvida do `R`. Geralmente são informações suficientes para determinar por que os commit `A` e `B` "desapareceram" do histórico na visualização predefinida. No entanto, existem alguns problemas com esta abordagem.

O primeiro problema é o desempenho. Diferente das opções anteriores, a opção `--simplify-merges` precisa percorrer todo o histórico do commit antes de retornar um único resultado. Isso pode fazer com que a opção seja difícil de usar em repositórios muito grandes.

O segundo problema é a auditoria. Quando muitos colaboradores estão trabalhando no mesmo repositório, é importante saber qual mesclagem do commit introduziu uma importante alteração no ramo. A mesclagem problemática `R` acima não parece ser o commit mesclado que foi utilizado na mesclagem de um ramo importante. Em vez disso, a mesclagem `N` foi utilizada para mesclar `R` e `X` em um importante ramo. Este commit por ter informação sobre o por que do `X` chegou a substituir as alterações do `A` e `B` em suas mensagens do commit.

--show-pulls::
	Além dos commits exibidos no histórico predefinido, exiba cada mesclagem do commit que não seja 'TREESAME' para o primeiro parente, porém que seja 'TREESAME' para um parente posterior.
+
Quando a mesclagem de um commit é incluso através da opção `--show-pulls`, a mesclagem é tratada como tivesse "capturado" as alterações de um outro ramo. Ao usar a opção `--show-pulls` nest exemplo (e em nenhuma outra opção) o grafo resultante será:
+
-----------------------------------------------------------------------
	I---X---R---N
-----------------------------------------------------------------------
+
Aqui, a mesclagem do commit `R` e `N` são incluídos porque obtiveram os commits `X` e `R` para o ramo base, respectivamente. Essas mesclagens são a razão pela qual os commits `A` e `B` não aparecem no histórico predefinido.
+
Quando a opção `--show-pulls` for usado em conjunto com `--simplify-merges`, o grafo incluí todas as informações necessárias:
+
-----------------------------------------------------------------------
	  .-A---M--.   N
	 /     /    \ /
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------
+
Repare que desde que `M` seja acessível de `R`, o canto de `N` para `M` foi simplificado. No entanto, o `N` ainda aparece no histórico como um commit importante porque ele "obteve" as alterações vindas de `R` para o ramo principal.

A opção `--simplify-by-decoration` permite exibir apenas o quadro geral da topologia do histórico, omitindo os commits que não sejam referenciadas pelas tags. Os commits são marcadas como '!TREESAME' (em outras palavras, mantidas após as regras da simplificação do histórico descritas acima) caso (1) sejam referenciadas pelas tags ou (2) alteram o conteúdo dos caminhos usados na linha de comando. Todos os outros commits são marcados como 'TREESAME' (assunto que será simplificado).

ifndef::git-shortlog[]
ifdef::git-rev-list[]
Auxiliares da Bisseção
~~~~~~~~~~~~~~~~~~~~~~

--bisect::
	Limite a geração do objeto para um único commit, que fica aproximadamente a meio caminho entre os commits incluídos e excluídos. Observe que a bisseção da "ref" ruim `refs/bisect/bad` é adicionada aos commits incluídos (caso existam) e a bisseção das boas refs `refs/bisect/good-*` é adicionada aos commits excluídos (caso existam). Assim, supondo que não haja nenhuma refs em `refs/bisect/`, se
+
-----------------------------------------------------------------------
	$ git rev-list --bisect foo ^bar ^baz
-----------------------------------------------------------------------
+
gera o 'midpoint', a saída dos dois comandos
+
-----------------------------------------------------------------------
	$ git rev-list foo ^midpoint
	$ git rev-list midpoint ^bar ^baz
-----------------------------------------------------------------------
+
teria aproximadamente o mesmo comprimento. Descobrir qual a alteração que apresenta uma regressão se resume, assim, a uma busca binária: gerar e testar repetidamente novos 'pontos médios' até que a sequência de commits seja de comprimento um.

--bisect-vars::
	Calcula o mesmo que `--bisect`, exceto que as refs no `refs/bisect/` não são usados e a menos que isso gere um texto pronto para ser avaliado pelo shell. Essas linhas atribuirão o nome da revisão do ponto intermediário à variável `bisect_rev`, e a quantidade esperada dos commits que serão testados depois que `bisect_rev` for testado como `bisect_nr`, a quantidade esperada dos commits que serão testados caso `bisect_rev` acabe sendo bom para `bisect_good`, a quantidade esperada dos commits que serão testados caso `bisect_rev` acabe sendo ruim para `bisect_bad`, a quantidade esperada dos commits que agora estamos fazendo o bisseção para `bisect_all`.

--bisect-all::
	Gera todos os objetos commit entre os commits incluídos e excluídos, ordenadas pela distância entre os commits incluídos e excluídos. As referências em `refs/bisect/` não são usadas. O mais distante deles é exibido primeiro. (Este é o único exibido através do `--bisect`.)
+
Isso é útil porque facilita a escolha de um bom commit para testar quando quiser evitar o teste de alguns deles por algum motivo (por eles não poderem ser compilados, por exemplo).
+
Esta opção pode ser utilizada junto com `--bisect-vars`, neste caso, quando todos os objetos commits forem classificados, haverá o mesmo texto como se `--bisect-vars` tivesse sido utilizado sozinho.
endif::git-rev-list[]
endif::git-shortlog[]

ifndef::git-shortlog[]
Ordenando os Commits
~~~~~~~~~~~~~~~~~~~~

É predefinido que os commits sejam exibidos em uma ordem cronológica reversa.

--date-order::
	Não exiba nenhuma origem antes de todos os herdeiros, porém exiba os commits com uma ordem de data e hora.

--author-date-order::
	Não exiba nenhuma origem antes de todos os herdeiros, porém exiba os commits com uma ordem de data e hora do autor.

--topo-order::
	Não exiba nenhuma origem antes de todos os herdeiros e evite exibir os commits com múltiplas linhas misturadas no histórico.
+
Por exemplo, em um histórico de commit como este:
+
----------------------------------------------------------------

    ---1----2----4----7
	\	       \
	 3----5----6----8---

----------------------------------------------------------------
+
onde os números indicam a ordem dos registros de data e hora do commit, o comando `git rev-list` e seus amigos `--date-order` exibem os commits na ordem de registro de data e hora: 8 7 6 5 4 3 2 1.
+
Com `--topo-order`, eles demonstrariam 8 6 5 3 7 4 2 1 (ou 8 7 4 2 6 5 3 1); alguns commits mais antigos são exibidos antes dos mais recentes, a fim de se evitar exibir os commits das duas trilhas de desenvolvimento paralelas misturadas juntas.

--reverse::
	Envie os commits escolhidos para serem exibidos (consulte a seção Limite do Commit acima) na ordem inversa. Não pode ser combinado com `--walk-reflogs`.
endif::git-shortlog[]

ifndef::git-shortlog[]
Passagem de Objeto
~~~~~~~~~~~~~~~~~~

Essas opções são direcionadas principalmente para o empacotamento dos repositórios Git.

ifdef::git-rev-list[]
--objects::
	Imprima as IDs do objeto de qualquer objeto referenciado pelos commits listados. Os `--objects foo ^bar` significa, portanto, ``me envie todas as IDs dos objetos que eu preciso baixar caso eu tenha o objeto commit _bar_ mas não _foo_''.

--in-commit-order::
	Imprima as IDs da árvore e da bolha na ordem dos commit. As IDs da árvore e da bolha são impressas após serem referenciados pelo commit.

--objects-edge::
	Semelhante a opção `--objects`, porém também imprime as IDs dos commits que foram excluídos e prefixados com um caractere ``-''. Isso é usado pelo linkgit:git-pack-objects[1] para criar um pacote ``thin'', que registra os objetos em um formato "deltificado" com base nos objetos existentes nestes commits excluídos para reduzir o tráfego da rede.

--objects-edge-aggressive::
	Semelhante a opção `--objects-edge`, porém se esforça mais para localizar os commits excluídos com o custo do tempo aumentado. É usado em vez da opão `--objects-edge` para criar os pacotes ``thin'' para os repositórios rasos.

--indexed-objects::
	Finja como se todas as árvores e as bolhas usadas pelo índice estivessem listados na linha de comando. Observe que você provavelmente queira utilizar a opção `--objects` também.

--unpacked::
	Útil apenas com a opção `--objects`; imprima as IDs do objeto que não estejam nos pacotes.

--object-names::
	Útil apenas com a opção `--objects`; imprima os nomes dos IDs dos objetos que forem encontrados. Este é o comportamento predefinido.

--no-object-names::
	Útil apenas com a opção `--objects`; não imprima os nomes das IDs dos objetos que forem encontrados. Isto inverte a opção `--object-names`. Esta opção permite que a saída seja analisada mais facilmente por comandos como linkgit:git-cat-file[1].

--filter=<filter-spec>::
	Útil apenas com um dos objetos `--objects*`; omite os objetos (geralmente bolhas) da lista dos objetos impressos. O '<filter-spec>' pode ser um dos seguintes:
+
O formulário '--filter=blob:none' omite todos as "bolhas".
+
O formulário '--filter=blob:limit=<n>[kmg]' omite as bolhas que forem maiores que 'n' bytes ou unidades. O 'n' pode ser zero. Os sufixos 'k', 'm' e 'g' podem ser utilizados para nomear as unidades em 'KiB', 'MiB' ou 'GiB'. Como, por exemplo, ''blob:limit=1k'' é o mesmo que 'blob:limit=1024'.
+
A forma '--filter=object:type=(tag|commit|tree|blob)' omite todo os objetos que não sejam do mesmo tipo que foi requisitado.
+
O formulário '--filter=sparse:oid=<blob-ish>' usa uma especificação de verificação esparsa contida na bolha (ou expressão bolha) '<blob-ish>' para omitir as bolhas que não seriam necessárias em uma verificação esparsa nas referências solicitadas.
+
O formulário '--filter=tree:<profundidade>' omite todas as bolhas e as árvores cuja profundidade da árvore raiz seja >= <profundidade> (a profundidade mínima caso um objeto estiver localizado em várias profundidades nos commits que forem percorridos). A <profundidade>=0 não incluirá nenhuma árvore ou bolhas, a menos que seja incluso de forma explícita na linha de comando (ou na entrada padrão quando stdin seja usado) A <profundidade>=1 incluirá apenas a árvore e as bolhas que são referenciados diretamente por um commit acessível de um objeto informado de forma explícita. A <profundidade>=2 é semelhante a <profundidade>=1 enquanto também inclui as árvores e as bolhas, mais um nível removido de um commit ou da árvore informada de forma explicita.
+
Observe que o formulário '--filter=sparse:path=<caminho>' deseja ler de um caminho arbitrário no sistema de arquivos que foi descartado por motivos de segurança.
+
Várias opções `--filter=` podem ser utilizados para fazer a combinação dos filtros. Somente os objetos que são aceitos por todos os filtros serão incluídos.
+
O formulário '--filter=combine:<filter1>+<filter2>+...<filterN>' também pode ser usado para combinar vários filtros, mas isso é mais difícil do que apenas repetir o comando '--filter' e geralmente não é necessário. Os filtros são unidos pelo '{plus}' e os filtros individuais são %-codificados (ou seja, URL-codificada). Além dos caracteres '{plus}' e '%' os seguintes caracteres são reservados e também devem ser codificados: `~!@#$^&*()[]{}\;",<>?`+&#39;&#96;+ assim como todos os caracteres com código ASCII &lt;= `0x20`, que inclui espaço e nova linha.
+
Outros caracteres arbitrários também podem ser codificados. Por exemplo, 'combine:tree:3+blob:none' e 'combine:tree%3A3+blob%3Anone' são equivalentes.

--no-filter::
	Desligue qualquer opção `--filter=` utilizada anteriormente.

--filter-provided-objects::
	Filtre a lista dos objetos explicitamente informados, que, de outra forma, sempre seriam exibidos, ainda que não correspondam a nenhum dos filtros. Útil apenas com `--filter=`.

--filter-print-omitted::
	Útil apenas com a opção `--filter=`; imprime uma lista dos objetos omitidos pelo filtro. As IDs dos objeto são prefixadas com um caractere ``~''.

--missing=<missing-action>::
	Uma opção de depuração para ajudar no desenvolvimento futuro do "clone parcial". Esta opção especifica como os objetos ausentes são manipulados.
+
A opção `--missing=error` solicita que os objetos do pacote parem com um erro caso um objeto perdido seja encontrado. Esta é a ação predefinida.
+
O formulário '--missing=allow-any' permitirá que a travessia do objeto continue caso um objeto ausente seja encontrado. Os objetos ausentes serão omitidos silenciosamente dos resultados.
+
A opção '--missing=allow-promisor' é como `allow-any`, mas só vai permitir que a travessia de objetos continue para os objetos prometedores PREVISTOS. Os objetos perdidos e inesperados provocarão um erro.
+
A opção `--missing=print' é como `allow any`, porém também imprime uma lista dos objetos perdidos. As IDs do objeto são prefixadas com um caractere `?`.

--exclude-promisor-objects::
	(Apenas para uso interno.) Uma pré-filtragem da travessia do objeto em um limite promissor Isso é utilizado com clone parcial. É mais forte do que `--missing=allow-promisor` porque limita a passagem, em vez de apenas silenciar os erros sobre os objetos perdidos.
endif::git-rev-list[]

--no-walk [=(com classificação|sem classificação)]::
	Exibe apenas determinados commits, mas não atravesse os seus ancestrais. Isso não tem nenhum efeito caso um intervalo seja especificado. Caso o argumento `unsorted` (sem classificação) seja utilizada, os commits serão exibidos na ordem em que foram utilizadas na linha de comando. Caso contrário (se o argumento `ordenado` ou nenhum outro seja utilizado), os commits serão exibidos em ordem cronológica reversa pela data do commit. Não pode ser combinado com `--graph`.

--do-walk::
	Substitui um `--no-walk` anterior.
endif::git-shortlog[]

ifndef::git-shortlog[]
Formatação do Commit
~~~~~~~~~~~~~~~~~~~~

ifdef::git-rev-list[]
Utilizando estas opções linkgit:git-rev-list[1] funcionará de maneira semelhante à família mais especializada de ferramentas do registro log do commit: linkgit:git-log[1], linkgit:git-show[1] e linkgit:git-whatchanged[1]
endif::git-rev-list[]

include::pretty-options.txt[]

--relative-date::
	É um sinônimo para `--date=relative`.

--date=<formato>::
	Somente entra em vigor para as datas demonstradas no formato legível para as pessoas como utilizada na opção `--pretty`. A variável de configuração `log.date` define um valor predefinido para a opção `--date` do comando do registro log. É predefinido que os horários sejam exibidas no fuso horário original (do autor do commit ou do autor). Caso `-local` seja anexado ao formato (por exemplo,`iso-local`), o fuso horário local do usuário será utilizado.
+
--
A opção `--date=relative` exibe as datas relativas à hora atual, por exemplo, ``2 horas atrás''. A opção `-local` não tem efeito para `--date=relative`.

`date=local` é um apelido para `date=default-local`.

A opção `--date=iso` (ou `date=iso`) exibe os registros de data e hora em formato semelhante ao ISO 8601. As diferenças para o formato rígido do ISO 8601 são:

	- um espaço em vez do `T` para delimitar data/hora
	- um espaço entre a hora e o fuso horário
	- sem dois pontos entre horas e minutos do fuso horário

a opção `--date=iso-strict` (ou `--date=iso8601-strict`) exibe o registro de data e hora com formato ISO 8601 restrito.

a opção `--date=rfc` (ou `--date=rfc2822`) exibe o registro de data e hora no formato RFC 2822, geralmente encontrado nas mensagens de e-mail.

`--date=short` exibe apenas a data em formato `AAAA-MM-DD` porém não a hora.

A opção `--date=raw` mostra a data como segundos desde a época (1970-01-01 00:00:00 UTC), seguido por um espaço e em seguida, o fuso horário como uma compensação do UTC (um `+` ou `-` com quatro dígitos; os dois primeiros são horas, e os dois seguintes são minutos). Ou seja, como se o registro de data e hora fosse formatado com `strftime("%s %z")`). Observe que a opção `-local` não afeta os segundos desde o valor da época (que é sempre medido em UTC), porém altera o valor do fuso horário que o acompanha.

A opção `--date=human` exibe o fuso horário como se o fuso horário não coincidisse com o fuso horário atual e não imprime a data inteira, caso coincida (por exemplo, ignore o ano da impressão para datas que são "este ano", mas também ignore a data inteira caso seja nos últimos dias e dizendo apenas qual o dia da semana era). Para datas mais antigas, a hora e os minutos também são omitidos.

A opção `date=unix` exibe a data como um carimbo de data/hora da época do Unix (segundos desde 1970). Assim como a opção `--raw`, isso sempre está no UTC e portanto, o `-local` não tem nenhum efeito.

A opção `--date=format:...` alimenta o formato `...` par ao seu sistema `strftime`, menos para %s, %z, e %Z, que são tratados internamente. Use a opção `--date=format:%c` para exibir a data no formato preferido do código do idioma do sistema. Consulte o manual do `strftime` para obter uma lista completa dos "placeholders". Ao utilizar o `-local`, a sintaxe correta é `--date=format-local:...`.

`--date=default` é o formato predefinido e tem como base na saída ctime(3). Ele mostra uma única linha com três letras do dia da semana, três letras do mês, dia do mês, hora-minuto-segundos no formato "HH:MM:SS", seguido do ano de 4 dígitos, além das informações do fuso horário, a menos que o fuso horário local seja usado, por ex. `Thu Jan 1 00:00:00 1970 +0000`.
--

ifdef::git-rev-list[]
--header::
	Exiba o conteúdo dos commits em formato bruto; cada registro é separado por um caractere `NUL`.

--no-commit-header::
	Exclui a linha do cabeçalho que contém o "commit" e o ID do objeto antes do formato especificado. Isto não afeta os formatos incorporados; apenas os formatos personalizados são afetados.

--commit-header::
	Substitui um `--no-commit-header` anterior.
endif::git-rev-list[]

--parents::
	Imprima também os pais do commit (no formato "commit parent..."). Também permite reescrever os pais, consulte 'Simplificação do Histórico' acima.

--children::
	Imprima também os filhos do commit (no formato "commit child..."). Também permite reescrever os pais, consulte 'Simplificação do Histórico' acima.

ifdef::git-rev-list[]
--timestamp::
	Exiba a data e hora do commit em formato bruto.
endif::git-rev-list[]

--left-right::
	Marque de que lado da diferença simétrica de onde um commit seja acessível. As confirmações do lado esquerdo são prefixadas com `<` e as da direita com `>`. Caso combinemos com `--boundary`, estes commits são prefixados com `-`.
+
Por exemplo, caso tenha essa topologia:
+
-----------------------------------------------------------------------
	     y---b---b  branch B
	    / \ /
	   /   .
	  /   / \
	 o---x---a---a  branch A
-----------------------------------------------------------------------
+
você obterá uma saída como essa:
+
-----------------------------------------------------------------------
	$ git rev-list --left-right --boundary --pretty=oneline A...B

	>bbbbbbb... 3º no b
	>bbbbbbb... 2º no b
	<aaaaaaa... 3º no a
	<aaaaaaa... 2º no a
	-yyyyyyy... 1º no b
	-xxxxxxx... 1º no a
-----------------------------------------------------------------------

--graph::
	Desenhe uma representação gráfica com base no texto do histórico de consolidação no lado esquerdo da saída. Pode fazer com que as linhas extras sejam impressas entre os commits, para que o histórico do grafo seja desenhado de forma correta. Não pode ser combinado com `--no-walk`.
+
Permite a reescrita dos pais, consulte 'Simplificação do Histórico' acima.
+
É predefinido que seja implícito o uso da opção `--topo-order`, porém a opção `--date-order` também possa ser utilizada.

--show-linear-break[=<barreira>]::
	Quando a opção `--graph` não é utilizado, todas as ramificações do histórico são achatadas, o que dificulta a visualização onde dois commits consecutivos não pertençam em um ramo linear. Neste caso, esta opção coloca uma barreira entre eles. Caso `<barreira>` seja utilizado, é a string que será exibida em vez do que estiver predefinido.

ifdef::git-rev-list[]
--count::
	Imprima um número informando quantos commits teriam sido listados e suprima todas as outras saídas. Quando usado em conjunto com a opção `--left-right`, imprima as contagens dos commits esquerdo e direito, separados por uma aba. Quando usado junto com a opção `--cherry-mark`, omita os commits equivalentes dos patches destas contagens e imprima a contagem para os commits equivalentes separados por uma aba.
endif::git-rev-list[]
endif::git-shortlog[]
