git(1)
======

NOME
----
git - o monitor estúpido de conteúdo


RESUMO
------
[verse]
'git' [-v | --version] [-h | --help] [-C <caminho>] [-c <nome>=<valor>]
    [--exec-path[=<caminho>]] [--html-path] [--man-path] [--info-path]
    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]
    [--git-dir=<caminho>] [--work-tree=<caminho>] [--namespace=<nome>]
    [--config-env=<name>=<envvar>] <command> [<args>]

DESCRIÇÃO
---------
O Git é um sistema de controle de revisão distribuído, rápido, escalável e com um conjunto de comandos incomumente rico que oferece operações de alto nível e acesso completo aos seus recursos.

Para começar, consulte linkgit:gittutorial[7] e depois linkgit:giteveryday[7] para conhecer um conjunto mínimo de comandos uteis. Para uma introdução mais aprofundada acesse o link:user-manual.html[Manual do Usuário do Git].

Depois de dominar os conceitos básicos, é possível voltar para esta página para aprender quais os outros comandos o Git oferece. É possível aprender mais sobre os comandos individuais do Git com o comando "git help nome-do-comando". A página do manual linkgit:gitcli[7] fornece uma visão geral da sintaxe dos comandos na linha de comando.

Uma cópia formatada e com hiperlink da documentação mais recente do Git pode ser visualizada em https://git.github.io/htmldocs/git.html ou https://git-scm.com/docs.


OPÇÕES
------
-v::
--version::
	Imprime a versão do pacote Git exibindo a sua origem.
+
Esta opção é convertida internamente para `git version ...` e aceita as mesmas opções que o comando linkgit:git-version[1]. Se a opção `--help' também for usada, ela tem precedência sobre a opção `--version`.

-h::
--help::
	Imprime a sinopse e uma lista dos comandos mais usados. Caso a opção `--all` ou `-a` seja usada, todos os comandos disponíveis serão impressos. Caso um comando Git seja informado, esta opção exibirá a página do manual deste comando.
+
Outras opções estão disponíveis para controlar como a página do manual é exibida. Para mais informações, consulte linkgit:git-help[1], pois o comando `git --help ...` é convertido internamente em `git help ...`.

-C <caminho>::
	Execute como se o git tivesse sido iniciado em '<caminho>' em vez do diretório de trabalho atual. Quando várias opções `-C` são usadas, cada `-C <caminho>` não absoluto subsequente é interpretado com relação ao `-C <caminho>` anterior. Se '<caminho>' estiver presente, porém vazio, por exemplo, `-C ""`, o diretório de trabalho atual permanecerá inalterado.
+
Esta opção afeta as opções que esperam o nome do caminho, como `--git-dir` e `work-tree`, pois as suas interpretações dos nomes dos caminhos seriam feitas em relação ao diretório de trabalho causado pela opção `-C`. Como, por exemplo, as seguintes invocações são equivalentes:

    git --git-dir=a.git --work-tree=b -C c status
    git --git-dir=c/a.git --work-tree=c/b status

-c <nome>=<valor>::
	Encaminhe um parâmetro de configuração para o comando O valor informado substituirá os valores dos arquivos de configuração. Um `<nome>` é esperado no mesmo formato listado pelo comando 'git config' (sub chaves separadas por pontos).
+
Note que ao omitir `=` no comando `git -c foo.bar ...` é permitido e define `foo.bar` com o valor booleano verdadeiro (assim como`[foo]bar` faria em um arquivo de configuração). Incluindo os iguais, porém com um valor vazio (como `git -c foo.bar= ...`) define `foo.bar` para a string vazia que `git config --type=bool` converterá para `false`.

--config-env=<nome>=<envvar>::
	Como `-c <nome>=<valor>`, dê à variável de configuração '<nome>' um valor onde <envvar> é o nome de uma variável de ambiente por onde o valor será recuperado. Ao contrário de `-c`, não há atalho para definir diretamente o valor para uma string vazia, em vez disso, a própria variável de ambiente deve ser definida como uma string vazia. É um erro caso o `<envvar>` não exista no ambiente. O `<envvar>` não pode ter um sinal de igual para evitar um equívoco com `<nome>` contendo um.
+
Isso é útil para casos onde você deseja passar opções de configuração transitórias para o git, porém está fazendo isso em sistemas operacionais onde outros processos possam ser capazes de ler o seu cmdline (`/proc/self/cmdline` por exemplo), mas não o seu ambiente (`/proc/self/Environment` por exemplo). Este é comportamento normal no Linux, mas pode não estar no seu sistema.
+
Observe que isso pode adicionar segurança para variáveis como `http.extraHeader` onde as informações confidenciais fazem parte do valor, mas não `url.<base>.insteadOf` por exemplo onde as informações confidenciais podem fazer parte da chave.

--exec-path[=<caminho>]::
	O caminho para onde os seus principais programas Git estão instalados. Isso também pode ser controlado configurando a variável de ambiente `GIT_EXEC_PATH`. Caso nenhum caminho seja informado, o 'git' imprimirá a configuração atual e encerrará.

--html-path::
	Imprima o caminho, sem barra, onde a documentação HTML do Git está instalada e encerre.

--man-path::
	Imprima o manpath (consulte `man(1)`) para as páginas do manual desta versão do Git e encerre.

--info-path::
	Imprima o caminho onde os arquivos Info que documentam esta versão do Git estão instalados e encerre.

-p::
--paginate::
	Canalize toda a saída para 'less' (ou caso esteja definido, `$PAGER`) caso a saída padrão seja um terminal. Isso substitui as opções de configuração `pager.<cmd>` (consulte a seção "Mecanismo de Configuração" abaixo).

-p::
--no-pager::
	Não canalize a saída do Git para um pager.

--git-dir=<caminho>::
	Define o caminho para o repositório (o diretório ".git"). Isso também pode ser controlado pela configuração da variável de ambiente `GIT_DIR`. Pode ser um caminho absoluto ou relativo ao diretório de trabalho atual.
+
A especificação do local do diretório ".git" usando esta opção (ou a variável de ambiente `GIT_DIR`) desativa a descoberta do repositório que tenta localizar um diretório com o ".git" dentro (que é como o repositório e o nível mais alto da descoberta da árvore de trabalho) e informa ao Git que você está no nível mais alto da árvore de trabalho. Caso não esteja no diretório no nível mais alto da árvore de trabalho, deve informar ao Git onde está este nível da árvore de trabalho, com a opção `--work-tree=<caminho>` (ou a variável de ambiente `GIT_WORK_TREE`)
+
Caso queira executar o git como se tivesse sido iniciado em `<caminho>`, utilize `git -C <caminho>`.

--work-tree=<caminho>::
	Define o caminho para a árvore de trabalho. Pode ser um caminho absoluto ou relativo ao diretório de trabalho atual. Também pode ser controlado atrvés da configuração da variável de ambiente `GIT_WORK_TREE` e da variável de configuração `core.worktree` (consulte `core.worktree` no linkgit:git-config[1] para uma discussão com mais detalhes).

--namespace=<caminho>::
	Define o espaço de nomes no Git. Para mais detalhes consulte linkgit:gitnamespaces[7]. É o mesmo que configurar a variável de ambiente `GIT_NAMESPACE`.

--bare::
	Trate o repositório como um repositório simples. Caso o ambiente `GIT_DIR` não estiver definido, ele será definido no diretório de trabalho atual.

--no-replace-objects::
	Não utilize substituições "ref" para substituir os objetos Git. Para mais informações consulte linkgit:git-replace[1].

--literal-pathspecs::
	Trate os pathspecs literalmente (ou seja, sem "globbing", sem a magia do "pathspec"). É o mesmo que definir a variável de ambiente `GIT_LITERAL_PATHSPECS` como `1`.

--glob-pathspecs::
	Adicione a magia 'glob' para todos os 'pathspec'. É como definir a variável de ambiente `GIT_GLOB_PATHSPECS` como `1`. A desativação do caractere curinga nos pathspecs individuais podem ser feitos utilizando a mágica do pathspec ": (literal)"

--noglob-pathspecs::
	Adicione a magia 'literal' a todos os "pathspec". É equivalente a definir a variável de ambiente `GIT_NOGLOB_PATHSPECS` para `1`. A ativação dos caracteres curinga nos "pathspecs" individuais podem ser feitos utilizando a mágica do pathspec ":(glob)"

--icase-pathspecs::
	Adicione a magia 'icase' em todos os pathspec. É como definir a variável de ambiente `GIT_ICASE_PATHSPECS` como `1`.

--no-optional-locks::
	Não execute operações opcionais que exijam bloqueios. Isso é equivalente que definir o `GIT_OPTIONAL_LOCKS` como `0`.

--list-cmds=group[,group...]::
	Liste os comandos por grupo. Essa é uma opção interna/experimental e pode mudar ou ser removido no futuro. Os grupos compatíveis são: `builtins`, `parseopt` (comandos internos que utilizam 'parse-options´), `main` (todos os comandos no diretório 'libexec'), `others` (todos os outros comandos no `$PATH` que possuem um prefixo git), `list- <categoria>` (consulte as categorias no 'command-list.txt'), `nohelpers` (exclua os comandos auxiliares), `alias` e `config` (recupera a lista dos comandos da variável `completion.commands`)

OS COMANDOS DO GIT
------------------

Dividimos o Git em comandos de alto nível ("porcelana") e de baixo nível ("encanamento").

Comandos de alto nível (porcelana)
----------------------------------

Separamos os comandos porcelana nos comandos principais e em alguns utilitários auxiliares do usuário.

Os principais comandos porcelana
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-mainporcelain.txt[]

Comandos Auxiliares
~~~~~~~~~~~~~~~~~~~
Manipuladores:

include::cmds-ancillarymanipulators.txt[]

Interrogadores:

include::cmds-ancillaryinterrogators.txt[]


Interagindo com os outros
~~~~~~~~~~~~~~~~~~~~~~~~~

Estes comandos são para interagir com um SCM externo e com as outras pessoas através de patch por e-mail.

include::cmds-foreignscminterface.txt[]

Redefina, restaure e reverta
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Existem três comandos com nomes semelhantes: `git reset`, `git restore` e o `git revert`.

* linkgit:git-revert[1] trata de fazer um novo commit que reverte as alterações feitas por outros commit.

* linkgit:git-restore[1] trata da restauração dos arquivos na árvore de trabalho do índice ou de outro commit. Este comando não atualiza o seu ramo. O comando também pode ser usado para restaurar os arquivos no índice do outro commit.

* linkgit:git-reset[1] trata da atualização do seu ramo, movendo o topo para adicionar ou remover os commits do ramo. Esta operação altera o histórico do commit.
+
O comando `git reset` também pode ser usado para restaurar o índice, sobrepondo com `git restore`.


Comandos de baixo nível (encanamento 'plumbing')
------------------------------------------------

Embora o Git inclua a sua própria camada de porcelana, os seus comandos de baixo nível são suficientes para apoiar o desenvolvimento de porcelanas alternativas. Os desenvolvedores destas porcelanas podem começar lendo sobre linkgit:git-update-index[1] e linkgit:git-read-tree[1].

A interface (entrada, saída, conjunto de opções e as semânticas) para esses comandos de baixo nível deve ser muito mais estável que os comandos porcelana, porque estes comandos são principalmente para uso com um script. A interface para os comandos Porcelana, por outro lado, está sujeita a alterações para melhorar a experiência do usuário final.

A descrição a seguir divide os comandos de baixo nível em comandos que manipulam os objetos (no repositório, índice e árvore de trabalho), comandos que interrogam, comparam objetos, comandos que movem objetos e suas referências entre os repositórios.


Comandos de manipulação
~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-plumbingmanipulators.txt[]


Comandos de interrogação
~~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-plumbinginterrogators.txt[]

Em geral, os comandos de interrogação não tocam nos arquivos da árvore de trabalho.


Sincronizando os repositórios
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

include::cmds-synchingrepositories.txt[]

A seguir, são apresentados os comandos auxiliares utilizados acima; os usuários finais normalmente não os utilizam diretamente.

include::cmds-synchelpers.txt[]


Comandos auxiliares internos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Estes são comandos auxiliares internos usados por outros comandos; os usuários finais normalmente não os utilizam diretamente.

include::cmds-purehelpers.txt[]

Guias
-----

As páginas da documentação a seguir são os guias sobre os conceitos do Git.

include::cmds-guide.txt[]

As interfaces do repositório, do comando e do arquivo
-----------------------------------------------------

Esta documentação discute as interfaces do repositório e os comandos com as quais os usuários devem interagir diretamente. Consulte `--user-formats` em linkgit:git-help[1] para obter mais detalhes sobre os critérios.

include::cmds-userinterfaces.txt[]

Formatos dos arquivos, protocolos e outras interfaces do desenvolvedor
----------------------------------------------------------------------

Esta documentação aborda os formatos dos arquivos, uma abordagem geral dos protocolos e das outras interfaces do desenvolvedor git. Consulte `--developer-interfaces` em linkgit:git-help[1].

include::cmds-developerinterfaces.txt[]

Mecanismo de Configuração
-------------------------

O Git utiliza um formato de texto simples para armazenar as personalizações por repositório e por usuário. Tal arquivo de configuração pode ficar assim:

------------
#
# Os caracteres '#' ou ';' indicam um comentário.
#

; variáveis principais
[core]
	; Não confie nos modos dos arquivos
	filemode = false

; identidade do usuário
[user]
	name = "Junio C Hamano"
	email = "gitster@pobox.com"

------------

Vários comandos são lidos no arquivo de configuração e ajustam a sua operação de acordo. Para obter uma lista e mais detalhes sobre o mecanismo de configuração, consulte linkgit:git-config[1].


Terminologia do Identificador
-----------------------------
<objeto>::
	Indica o nome do objeto para qualquer tipo de objeto.

<blob>::
	Indica um nome de um objeto bolha.

<árvore>::
	Indica um nome de um objeto árvore.

<commit>::
	Indica um nome de um objeto commit.

<árvore>::
	Indica uma árvore, nome de um objeto commit ou tag. Um comando que aceite um argumento <commit-ish> e queira operar em um objeto <commit>, porém remove a referência automaticamente dos objetos <tag> que apontem para um <commit>.

<commit-ish>::
	Indica um nome do objeto commit ou tag. Um comando que aceita um argumento <commit-ish> e queira operar em um objeto <commit>, porém remove a referência automaticamente dos objetos <tag> que apontem para um <commit>.

<tipo>::
	Indica que um tipo do objeto seja necessário. Atualmente um dos: `blob`, `tree`, `commit`, ou `tag`.

<arquivo>::
	Indica um nome do arquivo - quase sempre em relação à raiz da estrutura da árvore que o `GIT_INDEX_FILE` descreve.

Identificadores Simbólicos
--------------------------
Qualquer comando Git que aceite qualquer <objeto> também pode utilizar a seguinte notação simbólica:

HEAD::
	indica o cabeçalho do ramo atual.

<tag>::
	uma tag válida 'nome' (por exemplo, uma referência `refs/tags/<tag>`).

<head>::
	um cabeçalho válido 'nome' (por exemplo, uma referência `refs/heads/<head>`).

Para obter uma lista mais completa de maneiras de soletrar os nomes dos objetos, consulte a seção "DEFININDO AS REVISÕES" em linkgit:gitrevisions[7].


A Estrutura dos Arquivos/Diretórios
-----------------------------------

Favor consultar o documento linkgit:gitrepository-layout[5].

Para mais detalhes sobre cada gancho, consulte linkgit:githooks[5].

Os SCMs de alto nível podem fornecer e gerenciar informações adicionais no `$GIT_DIR`.


Terminologia
------------
Favor consultar linkgit:gitglossary[7].


As Variáveis do Ambiente
------------------------
Diversos comandos do Git respeitam às variáveis de ambiente e alteram seu comportamento de acordo. As variáveis de ambiente marcadas como "Booleanas" assumem seus valores da mesma maneira que as variáveis de configuração com valores booleanos, por exemplo, "true", "yes", "on" e números positivos são considerados como "yes".

Aqui estão as variáveis:

O Repositório Git
~~~~~~~~~~~~~~~~~
Essas variáveis de ambiente se aplicam a 'todos' os comandos principais do Git. Nb: é importante notar que eles podem ser usados/substituídos pelo SCMS acima do Git, portanto, tenha cuidado caso esteja usando um front-end externo.

`GIT_INDEX_FILE`::
	Essa variável de ambiente determina um arquivo alternativo do índice. Caso não seja definido, é utilizado o padrão `$GIT_DIR/index`.

`GIT_INDEX_VERSION`::
	Essa variável de ambiente determina qual a versão do índice é utilizada ao gravar o índice do arquivo . É predefinido que, a versão 2 ou 3 do índice do arquivo seja utilizado. Para obter mais informações consulte linkgit:git-update-index[1].

`GIT_OBJECT_DIRECTORY`::
	Caso o diretório de armazenamento dos objetos seja informado através desta variável de ambiente, os diretórios sha1 serão criados embaixo - caso contrário, o diretório predefinido `$GIT_DIR/objects` será utilizado.

`GIT_ALTERNATE_OBJECT_DIRECTORIES`::
	Devido à natureza imutável dos objetos Git, os objetos antigos podem ser arquivados em diretórios compartilhados com somente leitura apenas. Esta variável especifica uma lista ":" separada (no Windows ";") dos diretórios dos objetos Git que podem ser utilizados para localizar objetos Git. Os novos objetos não serão gravados nestes diretórios.
+
As entradas que começam com `"` (aspas duplas) serão interpretadas como caminhos entre as aspas no estilo C, removendo as aspas duplas iniciais e finais, respeitando as escapes da barra invertida. Como por exemplo, o valor `"path-with-\"-and-:-in-it":vanilla-path` possuí dois caminhos: `path-with-"-and-:-in-it` e `vanilla-path`.

`GIT_DIR`::
	Caso a variável de ambiente `GIT_DIR` esteja definida, ela definirá um caminho que será utilizado em vez do `.git` predefinido como sendo a base do repositório. A opção da linha de comando `--git-dir` também define este valor.

`GIT_WORK_TREE`::
	Defina o caminho para a raiz da árvore de trabalho. Isso também pode ser controlado pela opção da linha de comando `--work-tree` e pela variável de configuração `core.worktree`.

`GIT_NAMESPACE`::
	Define o espaço de nomes no Git; para mais detalhes consulte linkgit:gitnamespaces[7]. A opção da linha de comando `--namespace` também define este valor.

`GIT_CEILING_DIRECTORIES`::
	Essa deve ser uma lista separada por dois pontos com caminhos absolutos. Caso seja definido, é uma lista dos diretórios onde o Git não deve mudar de diretório (chdir) enquanto procura um diretório do repositório (útil para excluir os diretórios da rede com carregamento lento). Ele não excluirá o diretório de trabalho atual, um `GIT_DIR` definido na linha de comandos ou no ambiente. Normalmente, o Git precisa ler as entradas nesta lista e resolver qualquer link simbólico que possa estar presente para compará-las com o diretório atual. No entanto, mesmo que esse acesso seja lento, você pode adicionar uma entrada vazia à lista para informar ao Git que as entradas subsequentes não são links simbólicos e não precisam ser resolvidos; por exemplo, `GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink`.

`GIT_DISCOVERY_ACROSS_FILESYSTEM`::
	Quando executado em um diretório que não possui o diretório do repositório ".git", o Git tenta encontrar esse diretório nos diretórios pais para encontrar o cume da árvore de trabalho, porém, é predefinido que, ele não cruze os limites do sistema de arquivos. Essa variável de ambiente boleana pode ser configurada como 'true' para dizer ao Git para não parar nos limites do sistema de arquivos. Como o `GIT_CEILING_DIRECTORIES`, isso não afetará explicitamente um diretório do repositório definido através do `GIT_DIR` ou na linha de comando.

`GIT_COMMON_DIR`::
	Se essa variável estiver definida para um caminho, os arquivos que não são da árvore de trabalho, estão normalmente estão em $GIT_DIR e serão obtidos desse caminho. Os arquivos específicos da árvore de trabalho, como `HEAD` ou índice serão obtidos de $GIT_DIR. Para mais detalhes consulte linkgit:gitrepository-layout[5] e linkgit:git-worktree[1]. Essa variável tem precedência mais baixa do que outras variáveis de caminho como `GIT_INDEX_FILE`, `GIT_OBJECT_DIRECTORY`...

`GIT_DEFAULT_HASH`::
	Caso esta variável esteja definida, o algoritmo hash predefinido para os novos repositórios será definido com este valor. Este valor é atualmente ignorado durante a clonagem; em vez disso, a configuração do repositório remoto é utilizada. O valor predefinido é `sha1`. ESTA VARIÁVEL É EXPERIMENTAL! Consulte `--object-format` in linkgit:git-init[1].

Os Commits do Git
~~~~~~~~~~~~~~~~~
`GIT_AUTHOR_NAME`::
	O endereço legível do endereço de e-mail utilizado na identidade do autor ao criar os commits, na tag dos objetos ou ao gravar os reflogs. Substitui as definições de configuração `user.name` e `author.name`.

`GIT_AUTHOR_EMAIL`::
	O endereço de email utilizado na identidade do autor ao criar os commits, na marcação dos objetos ou ao gravar os reflogs. Substitui as definições da configuração `user.email` e `author.email`.

`GIT_AUTHOR_DATE`::
	A data utilizada para a identidade do autor ao criar objetos commit ou tags ou quando escrever "reflogs". Para conhecer os formatos válidos, consulte linkgit:git-commit[1].

`GIT_COMMITTER_NAME`::
	O endereço legível do nome utilizado na identidade do autor do commit ao criar os commits, na tag dos objetos ou ao gravar os reflogs. Substitui as definições de configuração `user.name` e `committer.name`.

`GIT_COMMITTER_EMAIL`::
	O endereço de email utilizado na identidade do autor ao criar os commits, na marcação dos objetos ou ao gravar os reflogs. Overrides the `user.email` and `committer.email` configuration settings.

`GIT_COMMITTER_DATE`::
	A data utilizada para a identidade de quem fez o commit durante a criação dos objetos as tags do commit ou ao gravar os reflogs. Para mais formatos válidos, consulte linkgit:git-commit[1].

`EMAIL`::
	O endereço de e-mail usado nas identidades do autor e do commit, caso nenhuma outra variável de ambiente ou da configuração relevante tiver sido definida.

Os Diffs do Git
~~~~~~~~~~~~~~~
`GIT_DIFF_OPTS`::
	A única opção válida é "--unified=??" ou "-u??" para definir o número de linhas de contexto mostradas quando um diff unificado for criado. Isso tem precedência sobre qualquer valor da opção "-U" ou "--unified" passado na linha de comando diff do Git.

`GIT_EXTERNAL_DIFF`::
	Quando a variável de ambiente `GIT_EXTERNAL_DIFF` é configurada, o programa informado nele é chamado para gerar os diffs, o Git não utiliza o seu mecanismo diff interno . Para um caminho que é adicionado, removido ou modificado, a variável `GIT_EXTERNAL_DIFF` é chamado com 7 parâmetros:

	path old-file old-hex old-mode new-file new-hex new-mode
+
onde:

	<old|new>-file:: são os arquivos que `GIT_EXTERNAL_DIFF` pode utilizar para ler o conteúdo do <antigo|novo>,
	<old|new>-hex:: 	são os hashes SHA-1 com 40 hexadecimais,
	<old|new>-mode:: 	são a representação octais dos modos dos arquivos.
+
Os parâmetros do arquivo podem apontar para o arquivo de trabalho do usuário (`new-file` em "git-diff-files" por exemplo), `/dev/null` (`old-file` quando um novo arquivo for adicionado por exemplo) ou um arquivo temporário (um `arquivo antigo` no índice por exemplo). A variável `GIT_EXTERNAL_DIFF` não deve se preocupar com o desvinculamento do arquivo temporário -- ele é removido quando a variável `GIT_EXTERNAL_DIFF` termina.
+
Para um caminho que não foi mesclado, `GIT_EXTERNAL_DIFF` é chamado com 1 parâmetro, <caminho>.
+
Para cada caminho `GIT_EXTERNAL_DIFF` que é chamado, duas variáveis de ambiente,`GIT_DIFF_PATH_COUNTER` e `GIT_DIFF_PATH_TOTAL` são definidas.

`GIT_DIFF_PATH_COUNTER`::
	Um contador com base 1 incrementado por um em cada caminho.

`GIT_DIFF_PATH_TOTAL`::
	A quantidade total dos caminhos.

Outros
~~~~~~
`GIT_MERGE_VERBOSITY`::
	Um número que controla a quantidade de saída demonstrada pela estratégia de mesclagem recursiva. Substitui o `merge.verbosity`. Consulte linkgit:git-merge[1]

`GIT_PAGER`::
	Essa variável de ambiente substitui o `$PAGER`. Caso esteja definido como uma string vazia ou com o valor "cat", o Git não iniciará um pager. Consulte também a opção `core.askPass` no linkgit:git-config[1].

`GIT_PROGRESS_DELAY`::
	Um número que controla quantos segundos atrasar antes de mostrar os indicadores opcionais do progresso. A predefinição retorna para `2`.

`GIT_EDITOR`::
	Essa variável de ambiente substitui o `$EDITOR` e o `$VISUAL`. É usado por vários comandos Git quando, no modo interativo, um editor deve ser iniciado. Consulte também linkgit:git-var[1] e a opção `core.editor` no linkgit:git-config[1].

`GIT_SEQUENCE_EDITOR`::
	Esta variável de ambiente substitui a configuração do editor do Git ao editar a lista de tarefas de um rebase interativo. Consulte também o comando linkgit:git-rebase[1] e a opção `sequence.editor` em linkgit:git-config[1].

`GIT_SSH`::
`GIT_SSH_COMMAND`::
	Caso alguma destas variáveis de ambiente esteja definida, o comando 'git fetch' e o 'git push' utilizarão o comando informado em vez do 'ssh' quando precisarem se conectar com um sistema remoto. Os parâmetros da linha de comando passados para o comando configurado, são determinados pela variante 'ssh'. Para mais detalhesm consulte a opção de configuração `ssh.variant` no linkgit:git-config[1].
+
A variável `$GIT_SSH_COMMAND` tem precedência sobre a variável `$GIT_SSH` que é interpretado pelo shell, permite que argumentos adicionais sejam incluídos. A variável `$GIT_SSH`, por outro lado, deve ser apenas o caminho para um programa (que pode ser um script shell do wrapper, caso as opções adicionais sejam necessárias).
+
Geralmente é mais fácil configurar as opções desejadas através do seu arquivo pessoal `.ssh/config`. Consulte a documentação do ssh para obter mais detalhes.

`GIT_SSH_VARIANT`::
	Se esta variável de ambiente estiver configurada, ela substitui a detecção automática do Git, caso `GIT_SSH`/`GIT_SSH_COMMAND`/`core.sshCommand` se refere ao OpenSSH, plink ou tortoiseplink. Esta variável substitui a configuração `ssh.variant` que serve ao mesmo propósito.

`GIT_SSL_NO_VERIFY`::
	Ao definir e exportar essa variável de ambiente para qualquer valor, informa ao Git para não verificar o certificado SSL ao buscar ou enviar via HTTPS.

`GIT_ASKPASS`::
	Caso esta variável do ambiente esteja definida, os comandos Git que precisam obter as senhas ou as frases secretas (para a autenticação HTTP ou IMAP por exemplo) chamarão esse programa com um prompt adequado como argumento da linha de comando e irão ler a senha em seu STDOUT. Consulte também a opção `core.askPass` no linkgit:git-config[1].

`GIT_TERMINAL_PROMPT`::
	Caso esta variável de ambiente boleana esteja definida como `false`, o git não será solicitado no terminal (ao solicitar uma autenticação HTTP por exemplo).

`GIT_CONFIG_GLOBAL`::
`GIT_CONFIG_SYSTEM`::
	Obtenha a configuração dos arquivos fornecidos em vez dos arquivos de configuração globais ou no nível do sistema. Caso a variável `GIT_CONFIG_SYSTEM` estiver definida, o arquivo de configuração do sistema definido no momento da compilação (normalmente `/etc/gitconfig`) não será lido. Da mesma forma, caso a variável `GIT_CONFIG_GLOBAL` esteja definida, nem `$HOME/.gitconfig`, nem `$XDG_CONFIG_HOME/git/config` serão lidos. Pode ser definido como `/dev/null` para ignorar a leitura dos arquivos de configuração do respectivo nível.

`GIT_CONFIG_NOSYSTEM`::
	Independente se você ignore as configurações de leitura do arquivo `$(prefix)/etc/gitconfig` do sistema. Essa variável de ambiente boleana pode ser usada junto com `$HOME` e o `$XDG_CONFIG_HOME` para criar um ambiente previsível para um script exigente, ou você pode configurá-la como `true` temporariamente evitando o uso de um arquivo `/etc/gitconfig` com problemas, enquanto aguarda alguém com permissões suficientes para corrigi-lo.

`GIT_FLUSH`::
// NEEDSWORK: make it into a usual Boolean environment variable
	Caso esta variável de ambiente estiver definida como "1", então os comandos
	como 'git blame' (no modo incremental), 'git rev-list', 'git log',
	'git check-attr' e 'git check-ignore' serão
	impor uma descarga do fluxo gerado depois que cada registro tenham sido
	esvaziado. Se essa
	variável for definida como '0', a saída destes comandos será feita
	utilizando toda a E/S na memória intermédia (buffer).   Se essa variável de ambiente não
	seja definida, o Git escolherá a descarga em uma memória intermédia ou orientada no
	esvaziamento dos registros, para ver se o stdout parece ter sido redirecionado para um arquivo ou não.

`GIT_TRACE`::
	Ativa o rastreio geral das mensagens, por exemplo expansão do pseudônimo, execução interna dos comandos e a execução externa dos comandos.
+
Caso esta variável esteja definida como `1`, `2` ou `true` (a comparação não diferencia as maiúsculas das minúsculas), as mensagens de rastreio serão impressas no stderr.
+
Caso a variável seja configurada com um valor inteiro maior que 2 e menor que 10 (estritamente), o Git interpretará este valor como um descritor de arquivo aberto e tentará gravar as mensagens de monitoramento neste descritor do arquivo.
+
Como alternativa, caso a variável estiver definida como um caminho absoluto (começando com um caractere '/'), o Git interpretará isso como um caminho do arquivo e tentará anexar as mensagens de rastreio nelas.
+
Desativar a variável ou defini-la como vazia '0' ou 'false' (não faz distinção entre maiúsculas e minúsculas) desativa as mensagens de monitoramento.

`GIT_TRACE_FSMONITOR`::
	Ativa as mensagens de rastreamento para a extensão do monitor do sistema de arquivos. Consulte `GIT_TRACE` para conhecer opções de saída de rastreio disponíveis.

`GIT_TRACE_PACK_ACCESS`::
	Permite rastrear as mensagens para todos os acessos para qualquer pacote. Para cada acesso, é registrado o nome do arquivo do pacote e um 'offset'. Pode ser útil para solucionar alguns problemas de desempenho relacionados ao pacote. Consulte `GIT_TRACE` para conhecer opções de saída de rastreio disponíveis.

`GIT_TRACE_PACKET`::
	Ativa o rastreio das mensagens para todos os pacotes que entram ou saem de um determinado programa. Isso pode ajudar na depuração da negociação dos objetos ou de outros problemas de protocolo. O rastreamento é desativado em um pacote que comece com "PACK" (porém consulte `GIT_TRACE_PACKFILE` abaixo). Consulte `GIT_TRACE` para conhecer opções de saída de rastreio disponíveis.

`GIT_TRACE_PACKFILE`::
	Permite o monitoramento dos arquivos dos pacotes enviados ou recebidos através de um determinado programa. Diferente de outras saídas monitoradas, esse monitoramento é literalmente: sem cabeçalhos e sem a citação dos dados binários. Você quase que certamente vai querer direcionar para um arquivo (`GIT_TRACE_PACKFILE=/tmp/my.pack` por exemplo) em vez de exibi-lo no terminal ou misturá-lo com uma outra saída monitorada.
+
Observe que atualmente isso é implementado apenas para o lado do cliente dos clones e das buscas.

`GIT_TRACE_PERFORMANCE`::
	Ativa as mensagens de rastreamento relacionadas ao desempenho, por exemplo, o tempo total da execução de cada comando Git. Consulte `GIT_TRACE` para conhecer opções de saída de rastreio disponíveis.

`GIT_TRACE_REFS`::
	Ativa as mensagens de rastreamento para a operação no banco de dados do ref. Consulte `GIT_TRACE` para conhecer opções de saída de rastreio disponíveis.

`GIT_TRACE_SETUP`::
	Permite que as mensagens de rastreamento imprimam o .git, a árvore de trabalho e o diretório de trabalho atual após o Git concluir a sua fase de configuração. Consulte `GIT_TRACE` para conhecer opções de saída de rastreio disponíveis.

`GIT_TRACE_SHALLOW`::
	Ativa o rastreio das mensagens que podem ajudar na depuração da busca/clonagem dos repositórios rasos. Consulte `GIT_TRACE` para conhecer opções de saída de rastreio disponíveis.

`GIT_TRACE_CURL`::
	Permite um rastreamento curl completo de todos os dados que foram recebidos e enviados, incluindo as informações descritivas, do protocolo de transporte git. É semelhante a fazer curl `--trace-ascii` na linha de comando. Consulte `GIT_TRACE` para conhecer as opções disponíveis geradas pelo rastreio.

`GIT_TRACE_CURL_NO_DATA`::
	Quando um rastreamento curl está ativado (consulte `GIT_TRACE_CURL` acima), não despeje os dados (ou seja, apenas despeje as linhas de informações e os cabeçalhos).

`GIT_TRACE2`::
	Permite mensagens de rastreamento com mais detalhes través da biblioteca "trace2". A saída do `GIT_TRACE2` é um formato simples de texto para facilitar a leitura das pessoas.
+
Caso esta variável esteja definida como `1`, `2` ou `true` (a comparação não diferencia as maiúsculas das minúsculas), as mensagens de rastreio serão impressas no stderr.
+
Caso a variável seja configurada com um valor inteiro maior que 2 e menor que 10 (estritamente), o Git interpretará este valor como um descritor de arquivo aberto e tentará gravar as mensagens de monitoramento neste descritor do arquivo.
+
Alternativamente, caso a variável esteja definida como um caminho absoluto (começando com um caractere '/'), Git interpretará isso como um caminho de arquivo e tentará anexar as mensagens de rastreamento a ela. Caso o caminho já exista e for um diretório, as mensagens de rastreamento serão gravadas em arquivos (uma por processo) nesse diretório, nomeada de acordo com o último componente do SID e um contador opcional (para evitar colisões de nome de arquivo).
+
Além disso, caso a variável esteja definida como `af_unix:[<socket_type>:]<caminho-absoluto>`, o Git tentará abrir o caminho como um soquete de domínio Unix. O tipo de soquete pode ser `stream` ou `dgram`.
+
Desativar a variável ou defini-la como vazia '0' ou 'false' (não faz distinção entre maiúsculas e minúsculas) desativa as mensagens de monitoramento.
+
Para mais detalhes, consulte link:technical/api-trace2.html[Trace2 documentation].


`GIT_TRACE2_EVENT`::
	Esta configuração registra um formato com base no JSON que é adequado para a interpretação da máquina. Consulte `GIT_TRACE2` para conhecer as opções disponíveis para o monitoramento e o link:technical/api-trace2.html [documentação do Trace2] para obter todos os detalhes.

`GIT_TRACE2_PERF`::
	Além das mensagens texto disponíveis em `GIT_TRACE2`, esta configuração escreve o formato da base da coluna para compreender as regiões aninhadas. Consulte `GIT_TRACE2` para conhecer as opções disponíveis para o monitoramento e o link:technical/api-trace2.html [documentação do Trace2] para obter todos os detalhes.

`GIT_TRACE_REDACT`::
	É predefinido que quando o monitoramento seja ativado, o Git redita os valores dos cookies, o cabeçalho "Autorização:" o cabeçalho e o URI do arquivo do pacote "Autorização do proxy:". Defina esta variável de ambiente boleana como `false` para evitar esta redação.

`GIT_LITERAL_PATHSPECS`::
	Ao definir essa variável de ambiente boleana como `true` fará com que o Git trate todos os pathspecs de forma literal, e não como padrões glob. Como, por exemplo, a execução do `GIT_LITERAL_PATHSPECS=1 git log -- '*.c'` procurará pelos commits que tocam no caminho `*.c` e não nos caminhos que coincidem com o agrupamento `*.c`. Você pode querer isso caso esteja alimentando caminhos literais para o Git (por exemplo, os caminhos informados anteriormente a você pelo `git ls-tree`, `--raw`, saída do diff, etc).

`GIT_GLOB_PATHSPECS`::
	Ao definir essa variável de ambiente boleana como `true` fará com que o Git trate todos os pathspecs como padrões "glob" (também informados como "glob" mágico).

`GIT_NOGLOB_PATHSPECS`::
	Ao definir essa variável de ambiente boleana como `true` fará com que o Git trate todos os pathspecs como literal (também informados como mágica "literal").

`GIT_ICASE_PATHSPECS`::
	Ao definir essa variável de ambiente boleana como `true` fará com que o Git trate todos os pathspecs como indiferente para maiúsculas e minúsculas.

`GIT_REFLOG_ACTION`::
	Quando uma "ref" é atualizada, são criadas as entradas do reflog para acompanhar a razão da "ref" ter sido atualizada (que geralmente é o nome do comando de alto nível que atualizou a "ref"), além dos valores antigos e novos da "ref". Um comando Porcelana com script pode usar a função auxiliar 'set_reflog_action' no comando `git sh setup` para definir o seu nome para essa variável quando é invocado como o comando de alto nível pelo usuário final, que será registrado no corpo do reflog.

`GIT_REF_PARANOIA`::
	Caso essa variável de ambiente boleana seja definida como `false`, ignore os refs quebrados ou mal nomeados ao iterar sobre as listas dos refs. Normalmente o Git tentará incluir qualquer um desses refs, o que pode causar a falha de algumas operações. Isto normalmente é preferível, já que as operações potencialmente destrutivas (como linkgit:git-prune[1]) são melhores abortando em vez de ignorar os refs quebrados (e assim considerando o histórico que eles apontam como não valendo a pena salvar). O valor predefinido é `true` (ou seja, ser paranoico ao detectar e abortar todas as operações). Normalmente não é preciso definir isso como `false`, mas pode ser útil ao tentar salvar os dados de um repositório corrompido.

`GIT_ALLOW_PROTOCOL`::
	Caso seja definido como uma lista de protocolos separados por dois pontos, comporte-se como se a opção de configuração `protocol.allow` esteja definida como `never`, e cada um dos protocolos listados possua `protocol.<nome>.allow` definido como `always` (substituindo qualquer configuração já existente). Consulte a descrição do `protocol.allow` no linkgit:git-config[1] para obter mais detalhes.

`GIT_PROTOCOL_FROM_USER`::
	Defina esta variável de ambiente boleana como `false` para evitar que os protocolos utilizados por `fetch/push/clone` sejam configurados por `user`. É útil para restringir a inicialização recursiva do submódulo de um repositório não confiável ou para programas que alimentam as URLS potencialmente não confiáveis aos comandos git. Para mais detalhes consulte linkgit:git-config[1].

`GIT_PROTOCOL`::
	Apenas para utilização interna. Used in handshaking the wire protocol. Contains a colon ':' separated list of keys with optional values 'key[=value]'. Presence of unknown keys and values must be ignored.
+
Observe que os servidores podem precisar ser configurados para permitir que esta variável passe por alguns transportes. Ele será propagado automaticamente ao acessar os repositórios locais (ou seja, `file://` ou um caminho do sistema de arquivos), bem como sobre o protocolo `git://`. Para 'git-over-http', ele deve funcionar automaticamente na maioria das configurações, porém consulte linkgit:git-http-backend[1]. Para 'git-over-ssh', o servidor ssh pode precisar ser configurado para permitir que os clientes passem esta variável (por exemplo, usando `AcceptEnv GIT_PROTOCOL` com o OpenSSH).
+
Esta configuração é opcional. Caso a variável não seja propagada, os clientes voltarão ao protocolo "v0" original (mas podem perder algumas melhorias de desempenho ou de recursos). Atualmente esta variável afeta apenas os clones e as buscas (fetch); ainda não é usado para envios "push" (mas pode ser no futuro).

`GIT_OPTIONAL_LOCKS`::
	Caso essa variável de ambiente boleana seja definida como `false`, o Git concluirá qualquer operação solicitada sem executar outra operação opcional onde se exija um bloqueio. Como um efeito colateral isso impedirá que o comando `git status` atualize o índice por exemplo. É útil para os processos que estão em execução no segundo plano que não queiram causar contenção do bloqueio com as outras operações no repositório. A predefinição retorna para `true`.

`GIT_REDIRECT_STDIN`::
`GIT_REDIRECT_STDOUT`::
`GIT_REDIRECT_STDERR`::
	Apenas no Windows: permite redirecionar os identificadores predefinidos de 'input/output/error' para os caminhos definidos através das variáveis do ambiente. Em particular isso é útil nos aplicativos "multi-threaded" onde a maneira canônica de encaminhar os identificadores predefinidos através do `CreateProcess()` não seja uma opção pois exigiria que os identificadores fossem marcados como herdáveis (e consequentemente *todo* processo gerado os herdaria, possivelmente fazendo o bloqueio das operações do Git). A intenção primária de utilização é utilizar os pipes informados para comunicação (`\\.\pipe\my-git-stdin-123` por exemplo).
+
Dois valores especiais são compatíveis: `off` simplesmente fechará o identificador predefinido correspondente e caso `GIT_REDIRECT_STDERR` seja `2> & 1`, a predefinição do erro será redirecionado para o mesmo identificador na saída padrão.

`GIT_PRINT_SHA1_ELLIPSIS` (descontinuado)::
	Caso seja definido como `yes`, imprima uma elipse seguido de um valor (abreviado) SHA-1. Isso afeta as indicações dos HEADs desanexados (linkgit:git-checkout[1]) e a saída diff bruta (linkgit:git-diff[1]). A impressão de uma elipse nos casos mencionados não é mais considerada adequada e é provável que a compatibilidade seja removida em um futuro próximo (junto com a variável).

Discussão[[Discussão]]
----------------------

Mais detalhes estão disponíveis no link:user-manual.html#git-concepts[capítulo dos conceitos do Git no manual do usuário] e linkgit:gitcore-tutorial[7].

Um projeto Git normalmente consiste em um diretório de trabalho com um subdiretório ".git" no ponto mais alto. O diretório .git contém, entre outras coisas, um banco de dados dos objetos compactados representando o histórico completo do projeto, um arquivo para o "índice" que vincula este histórico ao conteúdo atual da árvore de trabalho e informa os ponteiros para este histórico, como as tags e os cabeçalhos do ramo.

O banco de dados do objeto contém os objetos dos tipos da árvore principal: bolhas, que contêm os dados do arquivo; árvores, que apontam para as bolhas e as outras árvores para criar as hierarquias do diretório; e os commits, cada qual faz referência a uma única árvore e algum número do commit do pai.

O commit, equivalente ao que os outros sistemas chamam do "conjunto de alterações" ou "versão", representa uma etapa no histórico do projeto e cada pai representa uma etapa anterior. Os commits com mais de um pai representam as mesclagens das linhas independentes do desenvolvimento.

Todos os objetos são nomeados pelo hash SHA-1 do seu conteúdo, normalmente gravados como uma sequência com 40 dígitos hexadecimais. Tais nomes são globalmente únicos. Todo o histórico que antecede a um commit pode ser comprovado assinando apenas este commit. Um quarto tipo de objeto, a tag, é fornecida para esta finalidade.

Quando criados pela primeira vez, os objetos são armazenados em arquivos individuais, porém, visando uma maior eficiência, podem ser compactados posteriormente em "pacotes de arquivos".

Os Ponteiros informados chamados refs marcam os pontos interessantes na história. Uma "ref" pode conter o nome SHA-1 de um objeto ou o nome de outra referência. As referências com nomes que comecem com `ref/head/` contêm o nome SHA-1 do commit (ou "head") mais recente de um ramo em desenvolvimento. Os nomes SHA-1 das tags de interesse são armazenados em `ref/tags/`. Uma referência especial chamada `HEAD` contém o nome da ramificação com a averiguação do momento.

O arquivo do índice é inicializado com uma lista de todos os caminhos e para cada caminho, um objeto bolha e um conjunto de atributos. O objeto bolha representa o conteúdo do arquivo no cabeçalho do ramo atual. Os atributos (hora da última alteração, tamanho, etc.) são obtidos do arquivo correspondente na árvore de trabalho. As alterações subsequentes na árvore de trabalho podem ser encontradas comparando estes atributos. O índice pode ser atualizado com um novo conteúdo e os novos commits podem ser criadas a partir do conteúdo armazenado no índice.

O índice também é capaz de armazenar as várias entradas (chamadas de "estágios") para um determinado nome do caminho. Esses estágios são utilizados para manter as várias versões não mescladas de um arquivo quando uma mesclagem está em andamento.

DOCUMENTAÇÃO ADICIONAL
----------------------

Consulte as referências na seção "descrição" para começar a utilizar o Git. O seguinte tem provavelmente bem mais detalhes do que o necessário para um usuário iniciante.

O link:user-manual.html#git-concepts[capítulo de conceitos do Git do manual do usuário] e o linkgit:gitcore-tutorial[7] fornecem introduções à arquitetura subjacente do Git.

Para obter uma visão geral das recomendações do fluxo de trabalho, consulte linkgit:gitworkflows[7].

Para mais alguns exemplos úteis, consulte também o documento link:howto-index.html[howto].

As entranhas estão documentadas no link:technical/api-index.html[Documentação da API do Git].

Os usuários que estiverem migrando do CVS também podem querer ler linkgit:gitcvs-migration[7].


Autores
-------
O Git foi iniciado por Linus Torvalds e atualmente é mantido por Junio C Hamano. Várias contribuições vieram da lista de discussão do Git <git@vger.kernel.org>. O http://www.openhub.net/p/git/contributors/summary fornece uma lista mais completa de todos os colaboradores.

Caso tenha um clone do 'git.git', a saída do linkgit:git-shortlog[1] e do linkgit:git-blame[1] pode exibir os autores para as partes específicas do projeto.

Reportando um Erro
------------------

Relate os erros na lista de discussão do Git <git@vger.kernel.org> onde o desenvolvimento e as principais manutenções são realizadas. Você não precisa se inscrever na lista para enviar uma mensagem para lá. Para os relatórios dos erros anteriores e outras discussões, consulte o arquivo da lista de discussão em https://lore.kernel.org/git.

Os problemas relevantes para a segurança devem ser divulgadas em particular na mailing list do Git Security <git-security@googlegroups.com>.

VEJA TAMBÉM
-----------
linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:giteveryday[7], linkgit:gitcvs-migration[7], linkgit:gitglossary[7], linkgit:gitcore-tutorial[7], linkgit:gitcli[7], link:user-manual.html[O Manual do Usuário do Git], linkgit:gitworkflows[7]

GIT
---
Parte do conjunto linkgit:git[1]
