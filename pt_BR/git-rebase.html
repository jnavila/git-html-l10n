<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="generator" content="Asciidoctor 2.0.10"/>
<title>git-rebase(1)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"/>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="manpage">
<div id="header">
<h1>git-rebase(1) Manual Page</h1>
<h2 id="_nome">NOME</h2>
<div class="sectionbody">
<p>git-rebase - Reaplique os commits em cima do topo de outra base</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_resumo">RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git rebase</em> [-i | --interactive] [&lt;opções&gt;] [--exec &lt;cmd&gt;]
        [--onto &lt;nova-base&gt; | --keep-base] [&lt;upstream&gt; [&lt;ramo&gt;]]
<em>git rebase</em> [-i | --interactive] [&lt;opções&gt;] [--exec &lt;cmd&gt;] [--onto &lt;nova-base&gt;]
        --root [&lt;ramo&gt;]
<em>git rebase</em> (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição">DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Caso o &lt;ramo&gt; seja utilizado, o comando <em>git rebase</em> executará um <code>git
switch &lt;ramo&gt;</code> automaticamente antes de fazer qualquer outra coisa.  Caso
contrário, ele permanecerá no ramo atual.</p>
</div>
<div class="paragraph">
<p>Caso o <code>&lt;upstream&gt;</code> não seja definido, as opções "upstream" configuradas em
<code>branch.&lt;nome&gt;.remote</code> e no <code>branch.&lt;nome&gt;.merge</code> serão utilizadas (para
mais detalhes consulte <a href="git-config.html">git-config(1)</a>), assim como será assumida a
opção <code>--fork-point</code>.  Caso você não esteja atualmente em nenhuma
ramificação ou se a ramificação atual não tiver um "upstream" configurado, o
"rebase" será cancelado.</p>
</div>
<div class="paragraph">
<p>Todas as alterações feitas através de commits no ramo atual, mas que não
estão na &lt;upstream&gt;, são salvas em uma área temporária.  Este é o mesmo
conjunto dos commits que seriam exibidos por <code>git log &lt;upstream&gt;..HEAD</code>; ou
pelo comando <code>git log 'fork_point'..HEAD</code>, caso <code>--fork-point</code> esteja ativo
(veja a descrição em <code>--fork-point</code> abaixo); ou através do <code>git log HEAD</code>,
caso a opção <code>--root</code> for seja utilizada.</p>
</div>
<div class="paragraph">
<p>A ramificação atual é redefinida para &lt;upstream&gt; ou &lt;newbase&gt; caso a opção
<code>--onto</code> seja utilizada.  Isso tem exatamente o mesmo efeito que <code>git reset
--hard &lt;upstream&gt;</code> (ou &lt;newbase&gt;).  O <code>ORIG_HEAD</code> está definido para apontar
no cume do ramo antes da redefinição.</p>
</div>
<div class="paragraph">
<p>Os commits que foram salvos anteriormente na área temporária são reaplicadas
no ramo atual, uma por uma e em ordem. Observe que quaisquer commits no
<code>HEAD</code> que introduzam as mesmas alterações textuais que um commit no
<code>HEAD</code>.. <code>&lt;upstream&gt;</code> são omitidas (ou seja, um patch já aceito na inicial
com uma mensagem de commit ou carimbo de data e hora diferente, serão
ignorados).</p>
</div>
<div class="paragraph">
<p>É possível que uma falha da mesclagem impeça que este processo seja
completamente automático.  Você terá que resolver qualquer falha da
mesclagem e executar o comando <code>git rebase --continue</code>.  Outra opção é
ignorar o commit que causou a falha da mesclagem com o comando <code>git rebase
--skip</code>.  Para verificar o &lt;ramo&gt; original e remover os arquivos de trabalho
<em>.git/rebase-apply</em>, utilize o comando <code>git rebase --abort</code>.</p>
</div>
<div class="paragraph">
<p>Suponha que o seguinte histórico exista e que o ramo atual seja "topic":</p>
</div>
<div class="listingblock">
<div class="content">
<pre>          A---B---C topic
         /
    D---E---F---G master</pre>
</div>
</div>
<div class="paragraph">
<p>A partir deste ponto, o resultado de um dos seguintes comandos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase master
git rebase master topic</pre>
</div>
</div>
<div class="paragraph">
<p>seria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                  A'--B'--C' topic
                 /
    D---E---F---G master</pre>
</div>
</div>
<div class="paragraph">
<p><strong>OBSERVAÇÃO:</strong> Este último formulário é apenas uma abreviação de <code>git checkout topic</code>
seguido por <code>git rebase master</code>. Quando a reconstrução (rebase) sair do <code>topic</code> será
mantido o ramo que foi averiguado.</p>
</div>
<div class="paragraph">
<p>Caso a ramificação upstream já contiver uma alteração que você fez (porque
você enviou um patch que foi aplicado na upstream por exemplo), então este
commit será ignorado. Por exemplo, executando o comando <code>git rebase master</code>
no histórico a seguir (onde <code>A'</code> e <code>A</code> introduzem o mesmo conjunto de
alterações, mas possuem informações diferentes de quem fez o commit):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>          A---B---C topic
         /
    D---E---A'---F master</pre>
</div>
</div>
<div class="paragraph">
<p>vai resultar em:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                   B'---C' topic
                  /
    D---E---A'---F master</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui está como você transplantaria um ramo do tópico com base em um ramo
para outro, para fingir que você bifurcou o ramo do tópico deste último
ramo, utilizando <code>rebase --onto</code>.</p>
</div>
<div class="paragraph">
<p>Primeiro, vamos supor que o seu <em>tópico</em> seja baseado no ramo <em>next</em>.  Por
exemplo, um recurso desenvolvido em <em>topic</em> depende de algumas
funcionalidades encontradas em <em>next</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic</pre>
</div>
</div>
<div class="paragraph">
<p>Queremos criar um <em>tópico</em> bifurcado no ramo <em>master</em>; porque a
funcionalidade da qual o <em>tópico</em> depende foi mesclado na ramificação
<em>master</em> mais estável. Queremos que a nossa árvore fique assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next</pre>
</div>
</div>
<div class="paragraph">
<p>Podemos conseguir isso utilizando o seguinte comando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto master next topic</pre>
</div>
</div>
<div class="paragraph">
<p>Um outro exemplo da opção <code>--onto</code> é reconstruir a fundação da parte de uma
ramificação.  Se tivermos a seguinte situação:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master</pre>
</div>
</div>
<div class="paragraph">
<p>então o comando</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto master topicA topicB</pre>
</div>
</div>
<div class="paragraph">
<p>resultaria em:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master</pre>
</div>
</div>
<div class="paragraph">
<p>É útil quando o <em>topicB</em> não depender do <em>topicA</em>.</p>
</div>
<div class="paragraph">
<p>Um intervalo dos commits também pode ser removido com a reconstrução
<em>rebase</em>.  Se tivermos a seguinte situação:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    E---F---G---H---I---J  topicA</pre>
</div>
</div>
<div class="paragraph">
<p>então o comando</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto topicA~5 topicA~3 topicA</pre>
</div>
</div>
<div class="paragraph">
<p>resultaria na remoção dos commits <em>F</em> e <em>G</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    E---H'---I'---J'  topicA</pre>
</div>
</div>
<div class="paragraph">
<p>É útil caso <em>F</em> e <em>G</em> estejam de alguma forma com defeitos ou não deveriam
fazer parte do <em>topicA</em>.  Observe que o argumento para <em>--onto</em> e o
parâmetro <em>&lt;upstream&gt;</em> podem ser qualquer <em>commit-ish</em> válido.</p>
</div>
<div class="paragraph">
<p>Em caso de conflito, o <em>git rebase</em> irá parar no primeiro commit
problemático e deixar os marcadores de conflito na árvore.  Você pode
utilizar o <em>git diff</em> para localizar os marcadores (&lt;&lt;&lt;&lt;&lt;&lt;) e fazer edições
para resolver o conflito.  Para cada arquivo que você edita, é necessário
informar ao Git que o conflito foi resolvido, normalmente isso seria feito
com</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git add &lt;nome-do-arquivo&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Depois de resolver o conflito manualmente e atualizar o índice com a
resolução desejada, você pode continuar o processo de reconstrução com o
comando</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --continue</pre>
</div>
</div>
<div class="paragraph">
<p>Como alternativa, você pode desfazer o <em>git rebase</em> com</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --abort</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração">CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in git-rebase.txt - include::config/rebase.txt[]
Unresolved directive in git-rebase.txt - include::config/sequencer.txt[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções">OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">--onto &lt;nova-base&gt;</dt>
<dd>
<p>Ponto de partida onde criar os novos commits. Caso a opção <em>--onto</em> não seja
utilizada, o ponto inicial é &lt;upstream&gt;.  Pode ser qualquer commit válido e
não apenas um nome de um ramo já existente.</p>
<div class="paragraph">
<p>Como um caso especial, você pode utilizar "A...B" como um atalho para a
base de mesclagem <em>A</em> e <em>B</em> caso haja exatamente uma base para
mesclagem. Você pode deixar de fora no máximo um de <em>A</em> e <em>B</em>; nesse caso, a
predefinição retorna para <code>HEAD</code>.</p>
</div>
</dd>
<dt class="hdlist1">--keep-base</dt>
<dd>
<p>Defina o ponto de partida para criar os novos commits para a mesclagem base
do &lt;upstream&gt; &lt;ramo&gt;. Executando o comando <em>git rebase --keep-base
&lt;upstream&gt; &lt;ramo&gt;</em> é o mesmo que executar o comando <em>git rebase --onto
&lt;upstream&gt;&#8230;&#8203; &lt;upstream&gt;</em>.</p>
<div class="paragraph">
<p>Esta opção é útil no caso onde se está desenvolvendo um recurso em cima de
um ramo <em>upstream</em>. Enquanto o recurso está sendo trabalhado, o ramo
<em>upstream</em> pode avançar e talvez não seja a melhor ideia continuar
reconstruindo no topo do <em>upstream</em>, porém manter a base do commit como
está.</p>
</div>
<div class="paragraph">
<p>Embora esta opção e o <code>--fork-point</code> encontrem a base da mesclagem entre
&lt;upstream&gt; e &lt;ramo&gt;, esta opção utiliza a base da mesclagem como o <em>ponto
inicial</em> onde os novos commits serão criados, enquanto <code>--fork-point</code>
utiliza a mesclagem da base para determinar o <em>conjunto dos commits</em> que
serão reconstruídos.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">&lt;upstream&gt;</dt>
<dd>
<p>Ramo upstream para fazer a comparação.  Pode ser qualquer commit válido, não
apenas um nome de uma ramo já existente. A predefinição retorna para
"upstream" configurada para o ramo atual.</p>
</dd>
<dt class="hdlist1">&lt;ramo&gt;</dt>
<dd>
<p>Ramo de trabalho; A predefinição retorna para <code>HEAD</code>.</p>
</dd>
<dt class="hdlist1">--continue</dt>
<dd>
<p>Reinicie o processo de reformulação após resolver um conflito de mesclagem.</p>
</dd>
<dt class="hdlist1">--abort</dt>
<dd>
<p>Interrompa a operação de reconstrução da fundação e redefina o <code>HEAD</code> para o
ramo original. Caso &lt;ramo&gt; seja informado quando a operação de reconstrução
da fundação seja iniciada, o <code>HEAD</code> será redefinido para &lt;ramo&gt;. Caso
contrário, o HEAD será redefinido para onde estava quando a operação de
reconstrução foi iniciada.</p>
</dd>
<dt class="hdlist1">--quit</dt>
<dd>
<p>Interrompa a operação de reconstrução, porém o <code>HEAD</code> não será redefinido
para o ramo original. Como resultado, o índice e a árvore de trabalho também
permanecem inalterados. Caso uma entrada temporária "stash" seja criada
utilizando <code>--autostash</code>, ela será salva na lista "stash".</p>
</dd>
<dt class="hdlist1">--apply</dt>
<dd>
<p>Utilize estratégias para aplicar a reestruturação da base "rebase"
(invocando <code>git-am</code> internamente).  Esta opção poderá se tornar não
operacional no futuro uma vez que o processo interno da mesclagem processe
tudo o que a opção <em>--apply</em> fizer.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--empty={drop,keep,ask}</dt>
<dd>
<p>Como lidar com commits que não estão vazias para iniciar e não são escolhas
seletivas limpas de nenhum commit upstream, mas que ficam vazias após a
reconstrução (porque elas já contêm um subconjunto de alterações na
upstream).  Com drop (a predefinição), os commits que ficam vazias são
descartadas.  Com keep, estes commits são mantidos.  Com o comando <em>ask</em>
(implícito através da opção <code>--interactive</code>), uma reconstrução <em>rebase</em> será
interrompida quando um commit vazia for aplicado, permitindo que você
escolha se elimina, edita mais arquivos ou apenas faça o commit das
alterações vazias.  Outras opções, como <code>--exec</code>, utilizarão a predefinição
<em>drop</em>, a menos que a opção <code>-i/--interactive</code> seja informado de forma
explicita.</p>
<div class="paragraph">
<p>Observe que, os commits que começam vazios são mantidos (a menos que a opção
<code>--no-keep-empty</code> seja utilizado) e os commits que são escolhas limpas
(conforme determinado pelo comando <code>git log --cherry-mark ...</code>) são
detectados e descartados como uma etapa preliminar (a menos que a opção
`--reapply-cherry-picks seja utilizado).</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--no-keep-empty</dt>
<dt class="hdlist1">--keep-empty</dt>
<dd>
<p>Não mantenha os commits que começam vazios antes da reconstrução (ou seja,
que não alteram em nada a origem) no resultado.  A predefinição é manter os
commits que começam vazios, pois a criação destes commits requer o
encaminhamento da opção <code>--allow-empty override</code> para o comando <code>git
commit</code>, significa que um usuário está criando intencionalmente tal commit e
portanto, deseja mantê-lo.</p>
<div class="paragraph">
<p>A utilização desta opção é bem rara, já que você pode se livrar dos commits
que iniciam vazios simplesmente executando uma reconstrução interativa e
removendo as linhas correspondentes ao commit que você não quer.  Está opção
existe como um atalho por mera conveniência, para casos onde as ferramentas
externas gerem muitos commits vazios e você que todos eles sejam removidos.</p>
</div>
<div class="paragraph">
<p>Para os commits que não começam vazios, mas ficam vazios após a reconstrução
(<em>rebase</em>), consulte a opção <code>--empty</code>.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--reapply-cherry-picks</dt>
<dt class="hdlist1">--no-reapply-cherry-picks</dt>
<dd>
<p>Reaplique todas as escolhas seletivas que estejam limpas de qualquer commit
"upstream" em vez inviabilizá-los por completo. (Então, caso estes commits
se tornem vazios depois da reconstrução, por conter um subconjunto de
alterações da "upstream", o comportamento em direção à eles é controlado
através da opção <code>--empty</code>.)</p>
<div class="paragraph">
<p>É predefinido que (ou se `--no-reapply-cherry-picks 'for fornecido), estes
commits serão automaticamente eliminados.  Como isso requer a leitura de
todos os commits upstream, isso pode custar caro nos repositórios com uma
grande quantidade de commits na upstream que precisam ser lidos.</p>
</div>
<div class="paragraph">
<p>A opção <code>--reapply-cherry-picks</code> permite que a reconstrução anteceda a
leitura de todos os commits "upstream", melhorando muito o desempenho.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--allow-empty-message</dt>
<dd>
<p>No-op.  A reconstrução dos commits com uma mensagem vazia costumava falhar,
esta opção substitui este comportamento, permitindo que os commits com
mensagens vazias sejam refeitas.  Agora os commits com uma mensagem vazia
não causam mais a interrupção do "rebasing".</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--skip</dt>
<dd>
<p>Reinicie o processo de reconstrução da fundação ignorando o patch atual.</p>
</dd>
<dt class="hdlist1">--edit-todo</dt>
<dd>
<p>Edite a lista de tarefas durante uma nova reconstrução interativa.</p>
</dd>
<dt class="hdlist1">--show-current-patch</dt>
<dd>
<p>Exiba o patch atual em uma nova recuperação interativa ou quando a nova
recuperação for interrompida por causa de conflitos. É o equivalente ao <code>git
show REBASE_HEAD</code>.</p>
</dd>
<dt class="hdlist1">-m</dt>
<dt class="hdlist1">--merge</dt>
<dd>
<p>Utilize estratégias de mesclagem para fazer o <code>rebase</code>.  Quando a estratégia
de mesclagem recursiva (predefinida) for utilizada, permite que o <code>rebase</code>
esteja ciente das renomeações no lado upstream.  Esta é a predefinição.</p>
<div class="paragraph">
<p>Observe que uma mesclagem de reconstrução (rebase) funciona repetindo cada
commit da ramificação de trabalho na parte do topo &lt;upstream&gt;.  Por esse
motivo, quando ocorre um conflito na mesclagem, o lado relatado como <em>nosso</em>
é a série até agora reformulada, começando com &lt;upstream&gt; e <em>deles</em> é o ramo
de trabalho.  Em outras palavras, os lados são trocados.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">-s &lt;estratégia&gt;</dt>
<dt class="hdlist1">--strategy=&lt;estratégia&gt;</dt>
<dd>
<p>Use a estratégia de mesclagem informada.  Caso não haja a opção `-s <em>, o git
merge-recursive</em> será utilizado em seu lugar.  implica no uso da opção
<em>--merge</em>.</p>
<div class="paragraph">
<p>Como o <em>git rebase</em> repete cada commit do ramo de trabalho no cume do ramo
&lt;upstream&gt; utilizando a estratégia informada, o uso da estratégia <em>our</em>
simplesmente esvazia todos os patches do &lt;ramo&gt;, que faz pouco sentido.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">-X &lt;opção-da-estratégia&gt;</dt>
<dt class="hdlist1">--strategy-option=&lt;opção-da-estratégia&gt;</dt>
<dd>
<p>Encaminhe a &lt;opção-de-estratégia&gt; para a estratégia da mesclagem.  implica
no uso da opção <code>--merge</code> e, se nenhuma estratégia foi definida, <code>-s
recursive</code>.  Observe a reversão do <em>ours</em> (nossos) e <em>theirs</em> (deles),
conforme observado acima para a opção <code>-m</code>.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--rerere-autoupdate</dt>
<dt class="hdlist1">--no-rerere-autoupdate</dt>
<dd>
<p>Permita que o mecanismo "rerere" atualize o índice com o resultado da
resolução automática de conflitos, caso seja possível.</p>
</dd>
<dt class="hdlist1">-S[&lt;keyid&gt;]</dt>
<dt class="hdlist1">--gpg-sign[=&lt;keyid&gt;]</dt>
<dt class="hdlist1">--no-gpg-sign</dt>
<dd>
<p>Commits assinados com o GPG O argumento <code>keyid</code> é opcional e a predefinição
retorna para a identidade de quem fez o commit; caso seja utilizado, deve
estar anexado a opção e sem espaço. A opção <code>--no-gpg-sign</code> é útil para
revogar a variável de configuração <code>commit.gpgSign</code> e a anterior
<code>--gpg-sign</code>.</p>
</dd>
<dt class="hdlist1">-q</dt>
<dt class="hdlist1">--quiet</dt>
<dd>
<p>Fique em silêncio Implies --no-stat.</p>
</dd>
<dt class="hdlist1">-v</dt>
<dt class="hdlist1">--verbose</dt>
<dd>
<p>Seja loquaz. Implica no uso de <code>--stat</code>.</p>
</dd>
<dt class="hdlist1">--stat</dt>
<dd>
<p>Exiba uma descrição do que mudou na upstream desde a última reconstrução
(rebase). O diffstat também é controlado pela opção de configuração
<code>rebase.stat</code>.</p>
</dd>
<dt class="hdlist1">-n</dt>
<dt class="hdlist1">--no-stat</dt>
<dd>
<p>Não mostre um "diffstat" como parte do processo de reconstrução da fundação
(rebase).</p>
</dd>
<dt class="hdlist1">--no-verify</dt>
<dd>
<p>Este comando ignora o gancho "pre-rebase".  Consulte também
<a href="githooks.html">githooks(5)</a>.</p>
</dd>
<dt class="hdlist1">--verify</dt>
<dd>
<p>É predefinido que seja permitido que o gancho "pre-rebase" seja executado.
Esta opção pode ser usada para substituir o comando ` --no-verify`.
Consulte também <a href="githooks.html">githooks(5)</a>.</p>
</dd>
<dt class="hdlist1">-C&lt;n&gt;</dt>
<dd>
<p>Assegure que pelo menos <code>&lt;n&gt;</code> linhas ao redor do contexto coincidente antes
e depois de cada alteração.  Quando há menos linhas de contexto ao redor,
todas elas devem coincidir.  É predefinido que nenhum contexto seja
ignorado.  Implica no uso da opção --apply.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--no-ff</dt>
<dt class="hdlist1">--force-rebase</dt>
<dt class="hdlist1">-f</dt>
<dd>
<p>Reproduza individualmente todos os commits reconstruídos em vez de avançar
rapidamente sobre os que estejam inalterados.  Isso garante que todo o
histórico do ramo reconstruído seja composto por novos commits.</p>
<div class="paragraph">
<p>Pode ser útil depois de reverter uma mesclagem do ramo "topic", pois esta
opção recria o ramo "topic" com os novos commits, para que possa ser
recuperado com êxito sem precisar "reverter a reversão" (para mais detalhes,
consulte o link: howto/revert-a-fafe-merge.html [Como reverter uma falha da
mesclagem]).</p>
</div>
</dd>
<dt class="hdlist1">--fork-point</dt>
<dt class="hdlist1">--no-fork-point</dt>
<dd>
<p>Utilize reflog para encontrar um ancestral comum melhor entre a &lt;upstream&gt; e
o &lt;ramo&gt; ao calcular quais os commits foram introduzidos pelo &lt;ramo&gt;.</p>
<div class="paragraph">
<p>Quando "--fork-point" está ativo o <em>fork_point</em> será utilizado em vez do
<code>&lt;upstream&gt;</code> calcular o conjunto dos commits para fazer o "rebase" onde
<em>fork_point</em> é o resultado do comando <code>git merge-base --fork-point
&lt;upstream&gt; &lt;ramo&gt;</code> (consulte <a href="git-merge-base.html">git-merge-base(1)</a>).  Caso o
<em>fork_point</em> termine vazio, o <code>&lt;upstream&gt;</code> será utilizado como substituto.</p>
</div>
<div class="paragraph">
<p>Caso a &lt;upstream&gt; seja utilizada na linha de comando, a predefinição será
<code>--no-fork-point</code>, caso contrário, a predefinição será <code>--fork-point</code>.</p>
</div>
<div class="paragraph">
<p>Caso o seu ramo teve como base no &lt;upstream&gt;, porém &lt;upstream&gt; foi
retrocedido e o seu ramo contém commits que foram eliminados, esta opção
pode ser utilizada com a opção <code>--keep-base</code> para eliminar estes commits do
seu ramo.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--ignore-whitespace</dt>
<dd>
<p>Ignore whitespace differences when trying to reconcile
differences. Currently, each backend implements an approximation of this
behavior:</p>
<div class="paragraph">
<p>apply backend: When applying a patch, ignore changes in whitespace in
context lines. Unfortunately, this means that if the "old" lines being
replaced by the patch differ only in whitespace from the existing file, you
will get a merge conflict instead of a successful patch application.</p>
</div>
<div class="paragraph">
<p>merge backend: Treat lines with only whitespace changes as unchanged when
merging. Unfortunately, this means that any patch hunks that were intended
to modify whitespace and nothing else will be dropped, even if the other
side had no changes that conflicted.</p>
</div>
</dd>
<dt class="hdlist1">--whitespace=&lt;opção&gt;</dt>
<dd>
<p>Esta opção é repassada para o comando <em>git apply</em> que aplica o patch
(consulte  <a href="git-apply.html">git-apply(1)</a>).  Implica no uso da opção --apply.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--committer-date-is-author-date</dt>
<dd>
<p>Em vez de usar a hora atual como a data de quem fez o commit, utilize a data
do autor que fez o rebase do commit como a data do commit. Esta opção
implica no uso de <code>--force-rebase</code>.</p>
</dd>
<dt class="hdlist1">--ignore-date</dt>
<dt class="hdlist1">--reset-author-date</dt>
<dd>
<p>Instead of using the author date of the original commit, use the current
time as the	author date of the rebased commit.  This option implies
<code>--force-rebase</code>.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--signoff</dt>
<dd>
<p>Adicione uma resposta Assinado-por: a todos os commits que tiveram a sua
fundação reconstruída. Observe que caso a opção <code>--interactive</code> seja
utilizada, apenas os commit marcados para serem selecionados, editados ou
reformulados terão um caracteres de resposta adicionado.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">-i</dt>
<dt class="hdlist1">--interactive</dt>
<dd>
<p>Faça uma lista dos commits que estão prestes a serem reconstruídos.  Deixe
que o usuário edite esta lista antes da reconstrução.  Este modo também pode
ser utilizado para dividir os commits (consulte <em>DIVIDINDO OS COMMITS</em>
abaixo).</p>
<div class="paragraph">
<p>O formato da lista dos commits pode ser alterado definindo a opção de
configuração <code>rebase.instructionFormat</code>.  Um formato de instrução
personalizado terá automaticamente o hash longo do commit anexado ao
formato.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">-r</dt>
<dt class="hdlist1">--rebase-merges[=(rebase-cousins|no-rebase-cousins)]</dt>
<dd>
<p>É predefinido que uma reconstrução simplesmente remova os commits mesclados
da lista de tarefas e as coloca em uma única ramificação linear.  Com a
opção <code>--rebase-merges</code>, a reconstrução tentará preservar a estrutura da
ramificação dentro dos commits que serão reexaminadas, recriando a mesclagem
dos commits. Quaisquer conflitos na mesclagem que forem resolvidos ou nas
alterações manuais destes commits mesclados terão que ser
resolvidos/reaplicados manualmente.</p>
<div class="paragraph">
<p>É predefinido que ou quando <code>no-rebase-cousins</code> seja utilizado, os commits
que não possuam <code>&lt;upstream&gt;</code> como ancestral direto, manterão o seu ponto do
ramo original, ou seja, os commits que seriam excluídos pela opção
<a href="git-log.html">git-log(1)</a> <code>--ancestry-path</code>, por predefinição manterá a sua
ancestralidade original. Caso o modo <code>rebase-cousins</code> esteja ativo, estes
commits serão reconstruídos para a <code>&lt;upstream&gt;</code> (ou <code>&lt;onto&gt;</code>, caso seja
utilizado).</p>
</div>
<div class="paragraph">
<p>O modo <code>--rebase-merges</code> é semelhante (em espírito) a opção descontinuada
<code>--preserve-merges</code> porém trabalha com reconstrução interativa (rebases),
onde os commits possam ser reordenados, inseridos ou eliminados a vontade.</p>
</div>
<div class="paragraph">
<p>Atualmente, só é possível recriar a mesclagem dos commits utilizando a
estratégia de mesclagem <code>recursive</code> (recursiva); Diferentes estratégias de
mesclagem podem ser utilizada apenas através dos comandos explícitos como
<code>exec git merge -s &lt;strategy&gt; [...]</code>.</p>
</div>
<div class="paragraph">
<p>Consulte também <em>RECONSTRUINDO AS MESCLAGENS</em> e <em>OPÇÕES INCOMPATÍVEIS</em>
abaixo.</p>
</div>
</dd>
<dt class="hdlist1">-p</dt>
<dt class="hdlist1">--preserve-merges</dt>
<dd>
<p>[DESCONTINUADO: utilize <code>--rebase-merges</code>] Recrie os commits mesclados em
vez de achatar o histórico, reproduzindo os commits introduzidos por uma
mesclagem do commit. As resoluções dos conflitos da mesclagem ou das emendas
manuais para mesclar os commits não são preservadas.</p>
<div class="paragraph">
<p>Utiliza o mecanismo <code>--interactive</code> internamente, porém ao combiná-lo com a
opção <code>--interactive</code> de forma explícita, em geral não é uma boa ideia a
menos que saiba o que está fazendo (consulte <em>BUGS</em> abaixo).</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">-x &lt;cmd&gt;</dt>
<dt class="hdlist1">--exec &lt;cmd&gt;</dt>
<dd>
<p>Anexe "exec &lt;cmd&gt;" após cada linha, criando um commit no final do
histórico. O <code>&lt;cmd&gt;</code> será interpretado como um ou mais comandos do
shell. Qualquer comando que falhar interromperá a reconstrução da fundação,
com o código de encerramento igual a 1.</p>
<div class="paragraph">
<p>É possível executar vários comandos utilizando uma instância da opção
<code>--exec</code> com vários comandos:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i --exec "cmd1 &amp;&amp; cmd2 &amp;&amp; ..."</pre>
</div>
</div>
<div class="paragraph">
<p>ou utilizando mais de um <code>--exec</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i --exec "cmd1" --exec "cmd2" --exec ...</pre>
</div>
</div>
<div class="paragraph">
<p>Caso a opção <code>--autosquash</code> seja utilizado, as linhas "exec" não serão
anexadas aos commits intermediários e aparecerão apenas no final de cada
série de compressão/correção.</p>
</div>
<div class="paragraph">
<p>Utiliza o mecanismo <code>--interactive</code> internamente, porém pode ser executado
sem a opção <code>--interactive</code> de forma explicita.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--root</dt>
<dd>
<p>Reconstrói todos os commits acessíveis a partir do &lt;ramo&gt;, em vez de
limitá-los com a &lt;upstream&gt;.  Permite a reestruturação dos commit da raiz em
um ramo.  Quando utilizado com a opção <code>--onto</code>, será ignorado as alterações
já contidas em &lt;newbase&gt; (em vez de &lt;upstream&gt;) enquanto que sem a opção
<code>--onto</code> a operação ocorrerá em todas as alterações.  Quando utilizado junto
com ambas as opções <code>--onto</code> e <code>--preserve-merges</code>, <em>todos</em> os commits das
raízes serão reescritos para ter o &lt;newbase&gt; como a sua origem.</p>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--autosquash</dt>
<dt class="hdlist1">--no-autosquash</dt>
<dd>
<p>Quando a mensagem do registro log do commit começar com "squash! &#8230;&#8203;" (ou
"fixup! &#8230;&#8203;"),e já existe um commit na lista de tarefas que coincidem com o
mesmo <code>...</code>, altera a lista de tarefas automaticamente do <em>rebase -i</em> para
que o commit marcado para ser comprimido venha logo após o commit que será
modificado e altere a ação do commit movido de <code>pick</code> para <code>squash</code> (ou
<code>fixup</code>).  Um commit coincide com <code>...</code> caso haja a coincidência do assunto
do commit ou se o <code>...</code> se referir ao hash do commit. Como alternativa, as
coincidências que forem parciais ao assunto do commit, também funcionam.  A
maneira recomendada para se criar os commits para correção/compressão é
utilizando as opções <code>--fixup</code>/<code>--squash</code> do comando <a href="git-commit.html">git-commit(1)</a>.</p>
<div class="paragraph">
<p>Caso a opção <code>--autosquash</code> esteja predefinitivamente ativada utilizando a
variável de configuração <code>rebase.autoSquash</code>, esta opção poderá ser
utilizada para substituir e desativar esta configuração.</p>
</div>
<div class="paragraph">
<p>Consulte também a seção "OPÇÕES INCOMPATÍVEIS" logo abaixo.</p>
</div>
</dd>
<dt class="hdlist1">--autostash</dt>
<dt class="hdlist1">--no-autostash</dt>
<dd>
<p>Crie automaticamente uma entrada "stash" temporária antes do início da
operação e as aplique ao finalizar.  Isso significa que é possível executar
uma reconstrução (rebase) em uma árvore de trabalho suja.  No entanto, use
com cuidado: a aplicação "stash" final após uma nova reconstrução
bem-sucedida pode acabar em conflitos não triviais.</p>
</dd>
<dt class="hdlist1">--reschedule-failed-exec</dt>
<dt class="hdlist1">--no-reschedule-failed-exec</dt>
<dd>
<p>Reagende automaticamente os comandos <code>exec</code> que falharam. Isso só faz
sentido no modo interativo (ou quando uma opção <code>--exec</code> for utilizada).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções_incompatíveis">OPÇÕES INCOMPATÍVEIS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As seguintes opções:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--apply</p>
</li>
<li>
<p>--whitespace</p>
</li>
<li>
<p>-C</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>são incompatíveis com as seguintes opções:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--merge</p>
</li>
<li>
<p>--strategy</p>
</li>
<li>
<p>--strategy-option</p>
</li>
<li>
<p>--allow-empty-message</p>
</li>
<li>
<p>--[no-]autosquash</p>
</li>
<li>
<p>--rebase-merges</p>
</li>
<li>
<p>--preserve-merges</p>
</li>
<li>
<p>--interactive</p>
</li>
<li>
<p>--exec</p>
</li>
<li>
<p>--no-keep-empty</p>
</li>
<li>
<p>--empty=</p>
</li>
<li>
<p>--reapply-cherry-picks</p>
</li>
<li>
<p>--edit-todo</p>
</li>
<li>
<p>--root quando utilizado em conjunto com --onto</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Além disso, os seguintes pares de opções são incompatíveis:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--preserve-merges e --interactive</p>
</li>
<li>
<p>--preserve-merges e --signoff</p>
</li>
<li>
<p>--preserve-merges e --rebase-merges</p>
</li>
<li>
<p>--preserve-merges e --empty=</p>
</li>
<li>
<p>--preserve-merges e --ignore-whitespace</p>
</li>
<li>
<p>--preserve-merges e --committer-date-is-author-date</p>
</li>
<li>
<p>--preserve-merges e --ignore-date</p>
</li>
<li>
<p>--keep-base e --onto</p>
</li>
<li>
<p>--keep-base e --root</p>
</li>
<li>
<p>--fork-point e --root</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>DIFERENÇAS COMPORTAMENTAIS</p>
</div>
<div class="listingblock">
<div class="content">
<pre>O git rebase possui duas estruturas primárias: `apply` e `merge`.  (A aplicação
da estrutura era conhecido como 'am', porém o nome causava
confusão já que parecia um verbo em vez de um substantivo.  Além disso, a estrutura
`merge` era informada como 'interactive backend', porém agora
também é usado para casos não interativos.  Ambos foram renomeados com base na
funcionalidade de baixo nível que sustentava cada um.) Há algumas
diferenças sutis em como estes dois processos internos se comportam:

Commits vazios
~~~~~~~~~~~~~

A estrutura aplicada infelizmente descarta os commits vazios de forma intencional, ou seja.
Os commits que começaram vazios, contudo na prática, é algo raro.  Também
descarta os commits que se tornam vazios e não há uma opção para controlar
este comportamento.

É predefinido que a estrutura da mesclagem mantenha os commits
intencionalmente vazios (com `-i` são marcados como vazio no editor da lista de tarefas,
ou podem ser descartados automaticamente com a opção `--no-keep-empty`).

Semelhante à estrutura aplicada, é predefinido que
a estrutura da mesclagem derrube os commits que se tornaram vazios,
a menos que as opções `-i` ou `--interactive` sejam definidas (nesse caso, ele
para e pergunta ao usuário o que fazer).  A estrutura da mesclagem
também possui uma opção --empty={drop,keep,ask} para alterar o comportamento
da manipulação dos commits que ficam vazios.

Detecção da renomeação do diretório
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Devido à falta de informações precisas sobre as árvores (que surge de
construções dos ancestrais falsos com informações limitadas disponíveis nos
patches), a detecção da renomeação do diretório é desativado na estrutura da aplicação.
A desativação da detecção da renomeação do diretório, significa que se um lado do histórico
renomear um diretório e o outro adicionar novos arquivos no diretório antigo, então
os novos arquivos serão deixados para trás no diretório antigo sem qualquer aviso,
durante a reconstrução onde você possa talvez querer mover estes arquivos,
para o novo diretório.

A detecção da renomeação do diretório funciona com a estrutura da mesclagem,
neste caso, fornecendo informações para você.

Contexto
~~~~~~~~

A aplicação da estrutura funciona ao criar uma sequencia de patches (chamando
o `format-patch` internalmente), então se aplicam os patches em sequência
(invocando o `am` internamente).  Os patches são compostos de vários pedaços,
cada um com linhas numeradas, o contexto da região, e as alterações atuais.  As
linhas numeradas devem ser tomadas com alguma imprecisão, já que antes
o outro lado provavelmente terá inserido ou terá excluído as linhas no arquivo.  O
contexto da região destina-se no auxílio para encontrar como ajustar as linhas numeradas
na ordem para aplicar as alterações nas linhas corretas.  No entanto, caso
ao redor das várias áreas do código tenham as mesmas linhas de contexto, um
código errado pode ser selecionado.  Existem casos no mundo real onde isso
fez com que os commits fossem reaplicados de forma incorreta e nenhum conflito foi relatado.
Definindo o `diff.context` para um valor maior, isso pode impedir que
estes tipos de problemas ocorram, porém aumenta a chance de conflitos espúrios (uma vez que
exigirá mais linhas que coincidam com o contexto para serem aplicados).

A estrutura da mesclagem trabalha com a cópia completa
de casa arquivo relevante, isolando-os destes tipos de problemas.

Rotulagem dos marcadores de conflitos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Quando há conteúdos conflitantes, o mecanismo da mesclagem tenta
anotar os marcadores de conflito de cada lado com os commits
de onde o conteúdo veio.  Como a estrutura descarta o original, as
informações sobre os commits reconstruídos e seus pais (em vez disso,
gera novos commits falsos com base nas informações limitadas no
patches que foram gerados), estes commits não podem ser identificados;
em vez disso tem que retornar para um resumo do commit.  Além disso, quando `merge.conflictStyle` é
definido para 'diff3', a estrutura aplicada utilizará uma
"mesclagem reconstruída da base" para rotular o conteúdo da base mesclada
e portanto, não fornecer qualquer informações sobre o commit da base mesclada.

A estrutura da mesclagem funciona com commits completos nos dois
lados da história e portanto, não tem tais limitações.

Ganchos
~~~~~~~

A estrutura da aplicação não chama tradicionalmente o gancho pós-commit,
enquanto a estrutura da mesclagem chama.  Ambos chamaram o gancho pós-averiguação,
embora a estrutura da mesclagem reduza a sua saída.  Além disso, ambas
as estruturas chamam apenas o gancho pós-averiguação com o ponto de partida
para fazer o commit da reconstrução da fundação (rebase), nem o commit intermediário,
nem o commit final.  Em cada caso, o chamado desses ganchos foi por acidente de
implementação em vez de design (os dois processos internos eram originalmente
implementados como scripts shell e passaram a chamar outros comandos
como o 'git checkout' ou o 'git commit' que seriam chamados de ganchos).  Ambos
os processos internos devem ter o mesmo comportamento, embora não seja inteiramente
claro qual (caso existam), está correto.  Provavelmente faremos a reconstrução (rebase) parar
chamando um destes ganchos no futuro.

Interrupção
~~~~~~~~~~~

A aplicação da estrutura possui problemas de segurança relacionada
com interrupção de tempo; caso o usuário pressione Ctrl+C no momento errado
ao tentar interromper o processo 'rebase' (reconstrução), o processo então pode entrar
em uma condição ele não pode ser parado posteriormente com um comando `git rebase --abort`.  A estrutura da mesclagem não
parece sofrer da mesma deficiência.  (Consulte
https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/
para obter mais detalhes.)

Reformulando o Commit
~~~~~~~~~~~~~~~~~~~~~

Quando ocorre um conflito durante o processo 'rebase', o processo
para e pergunta ao usuário para resolver o problema.  Como o usuário pode precisar fazer muitas alterações enquanto
resolve os conflitos, depois que os conflitos forem resolvidos e o
usuário tenha executado o comando `git rebase --continue`, o 'rebase'
deverá abrir o editor e perguntar ao usuário para atualizar a mensagem do commit.  A estrutura da mesclagem faz isso, enquanto
a estrutura aplica cegamente a mensagem do commit original.

Diferenças diversas
~~~~~~~~~~~~~~~~~~~

Existem mais algumas diferenças comportamentais que a maioria das
pessoas considerariam fazer de forma inconsequente, porém são mencionadas
por questões de integridade:

* Reflog: As duas estruturas que utilizarão palavras diferentes durante a descrição
  das alterações feitas no reflog, embora ambos façam a utilização da
  palavra "rebase"

* Mensagens de progresso, informacionais e de erro: As duas estruturas
  fornecem um progresso ligeiramente diferente das mensagens informantes.
  Além disso, a estrutura aplicada grava uma mensagens de erro (como "Os seus arquivos
  serão substituídos...") para o stdout, enquanto a mesclagem da estrutura escrevem
  eles no stderr.

* Diretórios de estado: As duas estruturas mantêm a sua condição em diferentes
  diretórios dentro do `.git/`

ESTRATÉGIAS DE MESCLAGEM
------------------------

O mecanismo da mesclagem (comandos `git merge` e `git pull`) permite que as
estruturas das 'estratégias de mesclagem' sejam escolhidas com a opção
`-s`.  Algumas estratégias também podem ter suas próprias opções, que podem
ser passadas usando `-X&lt;opção&gt;` como argumentos para o comando `git merge`
e/ou `git pull`.

resolve::
        Isso só pode resultar em dois cabeçalhos (ou seja, a ramificação atual e uma
        outra ramificada da que você obteve) utilizando um algoritmo de mesclagem de
        três vias.  Ele tenta detectar cuidadosamente as ambiguidades cruzadas da
        mesclagem e geralmente é considerado seguro e rápido.

recursive::
        Isso pode resolver apenas duas cabeças usando o algoritmo da mesclagem de 3
        vias.  Quando há mais de um ancestral comum que pode ser usado para a
        mesclagem de 3 vias, ele cria uma árvore mesclada dos ancestrais comuns e o
        usa como a árvore de referência para a mesclagem de 3 vias.  Foi informado
        que isso resulta em menos conflitos durante mesclagem sem causar distorções
        pelos testes feitos nas mesclagens reais dos commits, retiradas do histórico
        de desenvolvimento do Linux kernel 2.6.  Além disso, isso pode detectar e
        manipular as mesclagens envolvendo renomeações, porém atualmente não pode
        fazer uso das cópias detectadas.  Essa é a estratégia de mesclagem
        predefinida ao extrair ou mesclar um ramo.
+
A estratégia 'recursiva' pode ter as seguintes opções:

ours;;
        Esta opção impõem que os pedaços conflitantes que sejam resolvidos de forma
        automática e de maneira limpa, favorecendo a 'nossa' versão.  As alterações
        vindos de outra árvore que não conflitam com o nosso lado são refletidas no
        resultado da mesclagem.  Para um arquivo binário, todo o conteúdo é retirado
        do nosso lado.
+
Isso não deve ser confundido com a estratégia da 'nossa' de mesclagem, que
sequer olha para o que a outra árvore contém.  Descarta tudo o que a outra
árvore fez, declarando que o 'nosso' histórico contém tudo o que aconteceu
nela.

theirs;;
        Este é o oposto do 'nosso'; observe que, diferentemente do 'nosso', não
        existe uma estratégia de mesclagem 'deles' para confundir esta opção de
        mesclagem.

patience;;
        Com esta opção, 'merge-recursive' gasta um pouco de tempo extra para evitar
        as distorções que às vezes ocorrem devido as coincidência das linhas sem
        importância (por exemplo, chaves das funções distintas).  Use isso quando os
        ramos que serão mesclados divergirem bastante.  Consulte também
        linkgit:git-diff[1] `--patience`.

diff-algorithm=[patience|minimal|histogram|myers];;
        Informa ao 'merge-recursive' para usar um algoritmo diff diferente, que pode
        ajudar a evitar as distorções que ocorrem devido as linhas coincidentes sem
        importância (como chaves das funções distintas).  Consulte também
        linkgit:git-diff[1] `--diff-algorithm`.

ignore-space-change;;
ignore-all-space;;
ignore-space-at-eol;;
ignore-cr-at-eol;;
        Trata as linhas com o tipo indicado da mudança do espaço como inalterado por
        uma mesclagem de três vias.  As alterações de espaço combinadas com outras
        alterações em uma linha não são ignoradas.  Consulte também
        linkgit:git-diff[1] `-b`, `-w`, `--ignore-space-at-eol`, e
        `--ignore-cr-at-eol`.
+
* Caso a versão 'their' (dele) introduzir apenas as alterações de espaço em
  uma linha, a 'our' (nossa) versão será utilizada;
* Caso a 'our' (nossa) versão introduzir alterações nos espaços, porém a
  versão 'their' (dele) incluir uma alteração substancial, a versão 'their'
  (dele) será utilizada;
* Caso contrário, a mesclagem continuará de forma usual.

renormalize;;
        Executa uma averiguação e um check-in virtual de três estágios em um arquivo
        ao resolver uma mesclagem de três vias.  Esta opção deve ser utilizada ao
        mesclar os ramos com diferentes filtros que estejam limpos ou as regras
        normais para a quebra de linha.  Para obter mais detalhes, consulte
        "Mesclando ramificações com diferentes atributos de check-in/check-out" em
        linkgit:gitattributes[5].

no-renormalize;;
        Desativa a opção `renormalize`.  Substitui a variável de configuração
        `merge.renormalize`.

no-renames;;
        Desativa a detecção de renomeação. Isso substitui a variável de configuração
        `merge.renames`.  Consulte tambémlinkgit:git-diff[1] `--no-renames`.

find-renames[=&lt;n&gt;];;
        Liga a detecção de renomeação, configurando opcionalmente o limite de
        similaridade.  Esta é a predefinição. Isso substitui a configuração da
        variável 'merge.renames'.  Consulte também linkgit:git-diff[1]
        `--find-renames`.

rename-threshold=&lt;n&gt;;;
        É um sinônimo obsoleto para `find-renames=&lt;n&gt;`.

subtree[=&lt;caminho&gt;];;
        Essa opção é uma forma mais avançada da estratégia da 'subárvore', onde a
        estratégia adivinha como as duas árvores devem ser deslocadas para
        coincidirem uma com a outra durante a mesclagem.  Em vez disso, o caminho
        definido é prefixado (ou removido desde o início) para criar a forma das
        duas árvores que serão coincididas.

octopus::
        Isso resolve os casos com mais de dois cabeçalhos, porém se recusa a fazer
        uma mesclagem complexa que precise de uma resolução manual.  Destina-se
        primeiramente para ser usado para agrupar junto o tópico dos cabeçalhos.
        Esra é a estratégia de mesclagem predefinida durante a extração ou a
        mesclagem com mais de um ramo.

ours::
        Isso resolve qualquer quantidade dos cabeçalhos, porém a árvore resultante
        da mesclagem é sempre a do cabeçalho atual do ramo, ignorando efetivamente
        todas as alterações de todas os outros ramos.  Ele deve ser usado para
        substituir o histórico antigo de desenvolvimento das ramificações laterais.
        Observe que isso é diferente da opção `-Xours` da estratégia de mesclagem
        'recursiva'.

subtree::
        Esta é uma estratégia recursiva modificada. Ao mesclar as árvores 'A' e 'B',
        caso 'B' corresponda a uma subárvore de 'A', o 'B' será ajustado primeiro
        para coincidir à estrutura da árvore 'A', em vez de ler as árvores no mesmo
        nível. Esse ajuste também é feito na árvore ancestral comum.

Com as estratégias que usma a mesclagem de 3 vias (incluindo a predefinição,
'recursive'), caso uma alteração seja feita em ambas as ramificações, porém
depois revertida em uma das ramificações, essa alteração estará presente no
resultado mesclado; algumas pessoas acham este comportamento confuso.  Isso
ocorre porque apenas os cabeçalhos e a base da mesclagem são consideradas ao
fazer uma mesclagem, e não os commits individuais.  Portanto, o algoritmo da
mesclagem considera a alteração revertida como nenhuma alteração e substitui
a versão alterada.

OBSERVAÇÕES
-----

Você deve compreender as implicações da utilização do comando 'git rebase'
em um repositório que você compartilha.  Consulte também SE RECUPERANDO DA
RECONSTRUÇÃO DA FUNDAÇÃO INICIAL (UPSTREM REBASE) abaixo.

Quando o comando 'git rebase' é executado, ele primeiro executa um gancho
"pre-rebase", caso exista.  Você pode usar este gancho para fazer as
verificações de sanidade e rejeitar a nova reconstrução, caso não seja
apropriado.  Consulte o modelo do script do gancho 'pre-rebase' para ter um
exemplo.

Após a conclusão, o &lt;ramo&gt; será o ramo atual.

MODO INTERATIVO
---------------

Reconstruir de forma interativa significa ter a chance de editar os commits
que são reconstruídos.  É possível reordenar os commits e removê-los
(eliminando os patches ruins ou indesejados).

O modo interativo é destinado para este tipo de fluxo de trabalho:

1. tenho uma ideia maravilhosa
2. hackear o código
3. preparar uma série para envio
4. enviar

onde o ponto 2. consiste em várias instâncias do

a) uso regular

 1. termine algo digno de um commit
 2. commit

b) correção independente

 1. perceber que algo não funciona
 2. conserte isso
 3. faça o commit

Às vezes, a coisa fixada em b.2. não pode ser alterado para o commit nem tão
perfeito que ele corrige, porque este commit está enterrado profundamente em
uma série de correções.  É exatamente para isso que a reconstrução
interativa serve: use-o após muitos "a" e "b", reorganizando e editando os
commits e comprimindo vários commits em um.

Inicie-o com o último commit que você quer manter como está:

        git rebase -i &lt;após-este-commit&gt;

Um editor será acionado com todos os commits no seu ramo atual (ignorando a
mesclagem dos commits), que vêm após o commit informado.  Você pode
reordenar os commits nesta lista para o conteúdo do seu coração e pode
removê-los.  A lista é mais ou menos assim:

-------------------------------------------
pick deadbee Uma linha deste commit
pick fa1afe1 Uma linha do próximo commit
...
-------------------------------------------

As descrições on-line são puramente para o seu prazer; o comando 'git
rebase' não examinará eles, porém os nomes dos commits ("deadbee" e
"fa1afe1" neste exemplo), portanto, não exclua ou edite os nomes.

Ao substituir o comando "pick" pelo comando "edit", é possível dizer ao
comando 'git rebase' para parar após aplicar este commit, para que seja
possível editar os arquivos e/ou a mensagem do commit, alterar o commit e
continuar com a reconstrução.

Para interromper um "rebase" (exatamente como um comando "edit" faria, mas
sem fazer uma escolha seletiva de nenhum commit primeiro), use o comando
"break".

Caso apenas queira editar a mensagem do commit para um commit, substitua o
comando `pick` pelo comando `reword`.

Para eliminar um commit, substitua o comando "pick" por "drop" ou apenas
exclua a linha coincidente.

Caso queira dobrar dois ou mais commits em um, substitua o comando "pick" da
segunda e os commits subsequentes por "squash" ou "fixup".  Caso os commits
tenham autores diferentes, o commit dobrado será atribuído ao autor do
primeiro commit.  A mensagem do commit sugerido para o commit que foi
dobrado é a concatenação das mensagens dos commits do primeiro commit e
daquelas feitas com o comando "squash", porém omite as mensagens dos commits
feitas com o comando "fixup".

O comando 'git rebase' será interrompido quando o "pick" for substituído por
"edit" ou quando um comando falhar devido aos erros da mesclagem. Quando
você terminar de editar e/ou resolver os conflitos, será possível continuar
utilizando `git rebase --continue`.

Como por exemplo, caso você queira reordenar os últimos 5 commits de maneira
onde o que era `HEAD~4` se torne o novo `HEAD`. Para conseguir isso, você
chamaria o comando 'git rebase' assim:

----------------------
$ git rebase -i HEAD~5
----------------------

E mova o primeiro patch para o ramo da lista.

Convém recriar a mesclagem dos commits, por exemplo, caso tenha um histórico
como este:

------------------
           X
            \
         A---M---B
        /
---o---O---P---Q
------------------

Suponha que queira reconstruir o lado do ramo ao lado começando em "A" para
"Q". Verifique se o `HEAD` atual é "B" e chame

-----------------------------
$ git rebase -i -r --onto Q O
-----------------------------

Reordenando e editando os commits geralmente cria etapas intermediárias não
testadas.  Convém verificar se a edição do seu histórico não quebrou nada
durante a execução de um teste ou, pelo menos, recompilando em pontos
intermediários do histórico utilizando o comando "exec" (atalho "x").  Você
pode fazer isso criando uma lista de tarefas como esta:

-------------------------------------------
pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
...
-------------------------------------------

A reconstrução interativa será interrompida quando um comando falhar (ou
seja, encerra com uma condição diferente de 0) oferecendo uma oportunidade
para a correção do problema. Você pode continuar com o comando `git rebase
--continue`.

O comando "exec" inicia o comando em um shell (aquele definido em `$SHELL`,
ou o shell predefinido caso `$SHELL` não esteja definido), para que você
possa utilizar os recursos do shell (como "cd", "&gt;", ";" ...). O comando é
executado a partir da raiz da árvore de trabalho.

----------------------------------
$ git rebase -i --exec "make test"
----------------------------------

Este comando permite verificar se os commits intermediários são
compiláveis.  A lista de tarefas fica assim:

--------------------
pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test
--------------------

DIVIDINDO OS COMMITS
---------------------

No modo interativo, é possível marcar os commits com a ação "editar".  No
entanto, isso não significa necessariamente que o comando 'git rebase'
espere que o resultado dessa edição seja exatamente um commit.  Na verdade,
é possível desfazer o commit ou adicionar outros.  Isso pode ser utilizado
para dividir um commit em dois:

- Inicie uma reconstrução interativa com `git rebase -i &lt;commit&gt;^`, onde
  &lt;commit&gt; é o que você quer dividir.  De fato, qualquer intervalo do commit
  serve, desde que contenha aquele commit.

- Marque o commit que deseja dividir com a ação "edit".

- Quando se trata de editar este commit, execute o comando `git reset HEAD^`.
  O efeito é que o `HEAD` é retrocedido por um e o índice segue o conjunto.
  No entanto, a árvore de trabalho permanece a mesma.

- Agora adicione as alterações ao índice que você queira ter no primeiro
  commit.  Você pode utilizar o comando `git add` (possivelmente de forma
  interativa) ou o comando 'git gui' (ou ambos) para fazer isso.

- Faça o commit do índice agora atual com qualquer mensagem do commit que seja
  apropriada.

- Repita as duas últimas etapas até que a sua árvore de trabalho esteja limpa.

- Continue a reconstrução com `git rebase --continue`.

Caso não tenha certeza absoluta que as revisões intermediárias são
consistentes (elas compilam, passam no conjunto de testes, etc.), você deve
usar o `git stash` para armazenar o commit das alterações que ainda não
foram feitas após cada commit, teste e corrija o commit caso correções sejam
necessárias.


SE RECUPERANDO DA RECONSTRUÇÃO DA FUNDAÇÃO INICIAL (UPSTREM REBASE)
-------------------------------------------------------------------

Fazer a reconstrução da fundação (ou qualquer outra forma de reescrita) de
um ramo onde outras pessoas tem a base de trabalho é uma péssima ideia:
qualquer um que baixe dela é forçado a corrigir manualmente o seu
histórico.  Esta seção explica como fazer a correção do ponto de vista de
quem baixou.  A solução real, no entanto em primeiro lugar, seria evitar
fazer a reconstrução da fundação de quem subiu (upstream).

Para ilustrar, suponha que esteja em uma situação onde alguém desenvolva um
ramo de um 'subsystem' e esteja trabalhando em um 'topic' que depende desse
'subsistema'.  Você pode acabar com um histórico como este:

------------
    o---o---o---o---o---o---o---o  master
         \
          o---o---o---o---o  subsystem
                           \
                            *---*---*  topic
------------

Caso a reconstrução da fundação do 'subsystem' seja realizada contra o
'master', o seguinte acontece:

------------
    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                           \
                            *---*---*  topic
------------

Caso agora continue o desenvolvimento normalmente e eventualmente mescle o
'topic' para 'subsystem', os commits do 'subsystem' permanecerão duplicados
para sempre:

------------
    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                           \                         /
                            *---*---*-..........-*--*  topic
------------

Geralmente, essas duplicatas são desaprovadas porque desordenam a história,
dificultando o acompanhamento.  Para organizar as coisas, é necessário
transplantar os commits no 'topic' para o novo cume do 'subsystem', ou seja,
reconstruir (rebase) o 'topic'.  Isso se torna um efeito cascata: qualquer
um que baixe do 'topic' é forçado a reconstruir (rebase) também e por aí
vai!

Existem dois tipos de correções, discutidos nas seguintes subseções:

Caso fácil: as alterações são literalmente as mesmas.::

        Isso acontece caso a reconstrução do 'subsystem' foi uma reconstrução
        simples e não houve conflitos.

Caso difícil: as alterações não são as mesmas.::

        Isso acontece caso a reconstrução da fundação (rebase) do 'subsistema' tiver
        conflitos ou utilizar o `--interactive` para omitir, editar, esmagar ou
        consertar consertos; ou se a inicial utilizou um dos comandos `commit
        --amend`, `reset` ou um histórico completo da reescrita como
        https://github.com/newren/git-filter-repo[`filter-repo`].


O caso fácil
~~~~~~~~~~~~

Funciona apenas se as alterações (IDs do patch com base no conteúdo do diff)
no 'subsystem' que forem literalmente as mesmas antes e depois da
reconstrução do 'subsystem'.

Nesse caso, a correção é fácil porque o comando 'git rebase' sabe ignorar as
alterações que já estão presentes no novo 'upstream' (a menos que
`--reapply-cherry-picks` seja utilizada). Então, se você diz (supondo que
você esteja no 'topic')
------------
    $ git rebase subsystem
------------
você vai acabar com o histórico fixo
------------
    o---o---o---o---o---o---o---o  master
                                 \
                                  o'--o'--o'--o'--o'  subsystem
                                                   \
                                                    *---*---*  topic
------------


O caso difícil
~~~~~~~~~~~~~~

As coisas ficam mais complicadas caso as alterações do "subsistema" não
coincidam de forma exata aquelas antes da reconstrução.

NOTE: Embora uma "recuperação fácil dos casos" às vezes pareça ser bem-sucedida
      mesmo no caso difícil, pode haver consequências não intencionais.  Para
      Por exemplo, um commit que foi removido através do comando `git rebase
      --interactive` será **ressuscitado**!

A ideia é dizer manualmente ao comando 'git rebase' "onde o 'subsistema'
antigo terminou e o seu 'tópico' começou", ou seja, qual era a base da
mesclagem antiga entre eles.  Você precisará encontrar uma maneira de nomear
o último commit do antigo 'subsistema', por exemplo:

* Com o 'subsistema' reflog: depois de 'git fetch', o antigo cume do
  'subsistema' fica em `subsystem@{1}`.  As capturas subsequentes aumentarão
  este número.  (Consulte linkgit:git-reflog[1].)

* Em relação ao cume do 'topic': sabendo que o seu 'topic' tem três commits, o
  cume antigo do 'subsystem' deve ser `topic~3`.

Você pode então transplantar o antigo `subsystem..topic` para o novo cume
dizendo (para o caso do reflog e supondo que você já esteja no 'topic'):
------------
    $ git rebase --onto subsystem subsystem@{1}
------------

O efeito cascata de uma recuperação "difícil" (hard case) é especialmente
ruim: 'todos' baixaram do 'topic' e agora terão que executar também uma
reconstrução "difícil"!

RECONSTRUINDO AS MESCLAGENS
---------------------------

O comando de reconstrução interativa foi originalmente projetado para lidar
com séries de patches individuais. Como tal, faz sentido excluir a mesclagem
dos commits da lista de tarefas, pois o desenvolvedor pode ter mesclado o
`master` atual enquanto trabalhava no ramo, apenas para redefinir todos os
commits para `master` eventualmente (ignorando a mesclagem dos commits).

No entanto, existem razões legítimas pelas quais um desenvolvedor pode
querer recriar as mesclagens dos commits: para manter a estrutura do ramo
(ou a "topologia do commit") ao trabalhar em diversos ramos
inter-relacionadas.

No exemplo a seguir, o desenvolvedor trabalha em um tópico no ramo que
refatora a maneira como os botões são definidos, em outro tópico do ramo que
utilize esta refatoração para implementar um botão "Relatar um bug". A saída
do `git log --graph --format=%s -5` pode ficar assim:

------------
*   Mescla o ramo 'report-a-bug'
|\
| * Adiciona o botão de feedback
* | Mescla o ramo 'refactor-button'
|\ \
| |/
| * Utiliza a classe do Botão para todos os botões
| * Extrai o botão genérico do DownloadButton
------------

O desenvolvedor pode querer redefinir estes commits para um novo `master`
enquanto mantém a topologia da ramificação. Quando se espera que o primeiro
tópico do ramo que seja integrado ao` master` muito antes do segundo por
exemplo. Para resolver os conflitos da mesclagem com as alterações para a
classe `DownloadButton` que a transformou em `master` por exemplo.

Esta reconstrução pode ser realizada utilizando a opção `--rebase-merges`.
Ele irá gerar uma lista de tarefas, assim:

------------
rotular para

# Branch: refactor-button
reset onto
pick 123456 Extrai o botão genérico do DownloadButton
pick 654321 Utiliza a classe do Botão para todos os botões
label refactor-button

# Branch: report-a-bug
reset refactor-button # Utiliza a classe do Botão para todos os botões
pick abcdef Adiciona o botão de feedback
label report-a-bug

reset onto
merge -C a1b2c3 refactor-button # Mescla o 'refactor-button'
merge -C 6f5e4d report-a-bug # Mescla o 'report-a-bug'
------------

Ao contrário de uma reconstrução interativa regular, existem os comandos
`label`, `reset` e `merge` além dos comandos `pick`.

O comando `label` associa um rótulo ao `HEAD` atual quando este comando for
executado. Estes rótulos são criados como refs locais da árvore de trabalho
(`refs/rewritten/&lt;label&gt;`) que serão excluídos quando a reconstrução
terminar. Dessa forma, as operações da reconstrução em várias árvores de
trabalho vinculadas ao mesmo repositório não interferem entre si. Caso o
comando `label` falhe, este é imediatamente reagendado, com uma mensagem
útil sobre como proceder.

O comando `reset` redefine o `HEAD`, o índice e a árvore de trabalho para a
revisão específica. É semelhante a um comando `exec git reset --hard
&lt;label&gt;`, porém se recusa a sobrescrever os arquivos que não sejam
monitorados. Se o comando `reset` falhar, ele será imediatamente reagendado,
com uma mensagem útil sobre como editar a lista de tarefas (normalmente
acontece quando um comando `reset` foi inserido manualmente na lista de
tarefas e contém um erro de digitação).

O comando `merge` mesclará revisões especificadas no que seja `HEAD` naquele
momento. Com `-C &lt;original-commit&gt;`, a mensagem do commit de um determinada
mesclagem será usada. Quando o `C` é alterado para minúsculo `-c`, a
mensagem será aberta em um editor após uma mesclagem bem-sucedida, para que
o usuário possa edita-lá.

Caso um comando `merge` falhar por qualquer motivo que não seja um conflito
da mesclagem (ou seja, quando a operação da mesclagem sequer iniciou), ele
será reagendado imediatamente.

Neste momento, o comando `merge` *sempre* utilizará a estratégia da
mesclagem `recursiva` para as mesclagens regulares, e `octopus` para
mesclagens "polvo", sem nenhuma maneira de escolher uma diferente. Para
contornar isso, um comando `exec` pode ser utilizado para chamar o comando
`git merge` de forma explicita, utilizando o fato onde os rótulos são as
'refs' locais da área de trabalho (o ref `refs/rewritten/onto`
corresponderia ao rótulo `onto` , por exemplo).

Observação: o primeiro comando (`label onto`) rotula a revisão onde os
commits são refeitos; O nome `onto` é apenas uma convenção, como um aceno
para a opção `--onto`.

Também é possível introduzir commits para mesclagem completamente novos,
adicionando um comando no formato `merge &lt;merge-head&gt;`. Este formulário gera
uma mensagem de commit provisória e sempre abre um editor para permitir que
o usuário a edite. Pode ser útil quando por exemplo, um ramo de um tópico
acaba resolvendo mais de um problema e quer ser dividido em dois ou mais
ramos de tópico. Considere esta lista de tarefas:

------------
pick 192837 Alterna do GNU Makefiles para o CMake
pick 5a6c7e Documente a alteração para o CMake
pick 918273 Corrija a detecção do OpenSSL no CMake
pick afbecd http: adicione a compatibilidade com o TLS v1.3
pick fdbaec Corrija a detecção da cURL no CMake no Windows
------------

O único commit nesta lista que não está relacionado ao CMake pode muito bem
ter sido motivado ao trabalhar na correção de todos os erros introduzidos
durante a mudança para o CMake, porém ele lida com um interesse
diferente. Para dividir esse ramo em dois tópicos, a lista de tarefas pode
ser editada desta maneira:

------------
rotular para

escolha afbecd http: adicione a compatibilidade para o TLS v1.3
label tlsv1.3

redefinir para
pick 192837 Alterna do GNU Makefiles para o CMake
pick 918273 Corrija a detecção do OpenSSL no CMake
pick fdbaec Corrija a detecção da cURL no CMake no Windows
pick 5a6c7e Documente a alteração para o CMake
label cmake

reset onto
merge tlsv1.3
merge cmake
------------

BUGS
----
A lista de tarefas apresentada pela opção descontinuada `--preserve-merges
--interactive` não representa a topologia do grafo da revisão (em vez disso
use a opção `--rebase-merges`).  A edição dos commits e a reformulação das
suas mensagens devem funcionar bem, porém as tentativas de reordenar os
commits tendem a produzir resultados contra-intuitivos.  Em vez disso, use a
opção `--rebase-merges` em tais cenários.

Por exemplo, uma tentativa para reorganizar
------------
1 --- 2 --- 3 --- 4 --- 5
------------
para
------------
1 --- 2 --- 4 --- 3 --- 5
------------
movendo a linha "pick 4" resultará no seguinte histórico:
------------
        3
       /
1 --- 2 --- 4 --- 5
------------

GIT
---
Parte do conjunto linkgit:git[1]</pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-10-20 22:50:36 +0200
</div>
</div>
</body>
</html>