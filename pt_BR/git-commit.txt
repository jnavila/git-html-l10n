git-commit(1)
=============

NOME
----
git-commit - Grava mudanças feitas no repositório

SINOPSE
-------
[verse]
'git commit' [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]
	   [--dry-run] [(-c | -C | --fixup | --squash) <commit>]
	   [-F <file> | -m <msg>] [--reset-author] [--allow-empty]
	   [--allow-empty-message] [--no-verify] [-e] [--author=<author>]
	   [--date=<date>] [--cleanup=<mode>] [--[no-]status]
	   [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]
	   [-S[<keyid>]] [--] [<pathspec>...]

DESCRIÇÃO
---------
Cria um novo commit contendo os conteúdos atuais do índice e a mensagem
informada no registro log descrevendo as mudanças. Um novo commit é um
herdeiro direto do HEAD que em geral é o topo do ramo atual e o ramo é
atualizado para apontar para ele (a menos que nenhum ramo seja associado com
a árvore de trabalho onde no caso o HEAD esteja "desassociado" como descrito
em linkgit:git-checkout[1]).

O conteúdo a ser feito o commit pode ser definido de diferente maneiras:

1. ao usar linkgit:git-add[1] para ir incrementando mudanças com "add" para o
   índice antes de usar o comando (Nota: devem ser "adicionados" até mesmo os
   arquivos modificados);

2. ao usar linkgit:git-rm[1] para remover os arquivos da árvore de trabalho em
   do índice, novamente, antes de usar o comando 'commit';

3. ao listar os arquivos como argumentos para o comando 'commit' (sem usar as
   opções --interactive ou --patch), nesse caso, o commit ignorará as
   alterações organizadas no índice e em vez disso registrará o conteúdo atual
   dos arquivos listados (que já devem ser conhecidos pelo Git );

4. ao usar a opção -a com o comando 'commit' para "adicionar" automaticamente
   as alterações de todos os arquivos conhecidos (ou seja, todos os arquivos
   que já estão listados no índice) e "rm" para remover os arquivos
   automaticamente da árvore de trabalho e assim executar o commit de fato;

5. ao usar as opções --interactive ou --patch com o comando 'commit' para
   decidir um a um quais arquivos ou blocos devem fazer parte do commit além do
   conteúdo já existente do índice antes de finalizar a operação. Consulte a
   seção ``Interactive Mode'' do linkgit:git-add[1] para aprender como esses
   modos funcionam.

A opção `--dry-run` pode ser usada para obter um resumo do que está incluído
em qualquer uma das opções acima para o próximo commit, fornecendo o mesmo
conjunto de parâmetros (opções e caminhos).

Caso faça um commit e imediatamente encontre um erro logo em seguida, é
possível recuperá-lo com o comando 'git reset'.


OPÇÕES
------
-a::
--all::
	Diz ao comando para preparar automaticamente os arquivos que foram
	modificados e excluídos, porém os novos arquivos que você não informou ao
	Git não são afetados.

-p::
--patch::
	Utilize a interface de seleção do patch interativo para escolher quais
	modificações (commit) serão aplicados. Para mais detalhes consulte
	linkgit:git-add[1].

-C <commit>::
--reuse-message=<commit>::
	Pega um objeto commit existente e o reutiliza na mensagem do registro log
	assim com as informações de autoria (incluindo o registro de data e hora)
	ao criar um commit.

-c <commit>::
--reedit-message=<commit>::
	Como `-C`, porém com `-c` o editor é chamado para que o usuário possa editar
	ainda mais a mensagem do commit.

--fixup=<commit>::
	Constrói uma mensagem de commit para usar com `rebase --autosquash`.  A
	linha de assunto da mensagem de commit é retirada do commit determinado com
	um prefixo "fixup! ".  Para mais detalhes consulte linkgit:git-rebase[1].

--squash=<commit>::
	Constrói uma mensagem de commit para usar com `rebase --autosquash`.  A
	linha de assunto da mensagem de commit é retirada do commit determinado com
	um prefixo "squash! ".  Pode ser usado com uma mensagem de commit adicional
	usando as opções (`-m`/`-c`/`-C`/`-F`). Para mais detalhes consulte
	linkgit:git-rebase[1].

--reset-author::
	Quando usado com opções de emendas -C/-c/-- ou quando fizer um commit após
	uma seleção conflitante, declare que a autoria do resultado agora pertence
	ao autor do commit. Isso também renova o registro de data e hora do autor.

--short::
	Ao fazer um "dry-run", dê a saída um formato curto. Para mais detalhes
	consulte linkgit:git-status[1] Implica em `--dry-run`.

--branch::
	Exibe o ramo e a informação de rastreio quando estiver em formato curto.

--porcelain::
	Ao fazer um "dry-run", dê a saída um formato "porcelain-ready". Para mais
	detalhes consulte linkgit:git-status[1] Implica em `--dry-run`.

--long::
	Ao fazer um "dry-run", dê a saída um formato longo.  Implica em `--dry-run`.

-z::
--null::
	Ao exibir a condição da saída `short` ou `porcelain`, imprima o nome do
	arquivo literalmente e termine as entradas com NUL, em vez de LF.  Caso
	nenhum formato seja dado, implica no uso da opção `--porcelain` como formato
	de saída.  Sem a opção `-z`, os nomes dos arquivos com caracteres "incomuns"
	serão citados conforme explicado nas variáveis de configuração
	`core.quotePath` (consulte linkgit:git-config[1]).

-F <arquivo>::
--file=<arquivo>::
	Pega a mensagem de commit vindo de um determinado arquivo.  Use '-' para ler
	a mensagem da entrada predefinida.

--author=<autor>::
	Sobrescrever o commit do autor. Determina o autor de forma explicita usando
	o formato padrão `A U Thor <author@example.com>`. Caso contrário assume-se
	<author> como padrão e será utilizado na pesquisa de um commit existente
	feito por este autor (ouseja, rev-list --all -i --author=<author>); o commit
	do autor é então copiado do primeiro commit que for encontrado.

--date=<data>::
	Substitua a data do autor que foi usada no commit.

-m <msg>::
--message=<msg>::
	Usa a <msg> como a mensagem de commit.  Caso múltiplas opções `-m` sejam
	usadas, o seu conteúdo será disposto em parágrafos separados.
+
A opção `-m` é usado em conjunto exclusivamente com `-c`, `-C` e `-F`.

-t <arquivo>::
--template=<arquivo>::
	Ao editar a mensagem do commit, inicie o editor com o conteúdo do arquivo
	informado.  A variável de configuração `commit.template` é frequentemente
	usada para fornecer esta opção de forma implícita ao comando.  Esse
	mecanismo pode ser usado por projetos que desejam orientar os participantes
	com algumas dicas sobre o que escrever na mensagem e em qual ordem.  Aborte
	o commit caso o usuário saia do editor sem editar a mensagem.  Não qualquer
	efeito quando uma mensagem é dada por outros meios, por exemplo, com as
	opções `-m` ou `-F`.

-s::
--signoff::
	Adicionar uma linha assinado pela pessoa que fez o commit no final do
	registro log do commit assinado.  O significado de uma aprovação depende do
	projeto, porém normalmente certifica que a pessoa que fez o commit tem o
	direito de enviar este trabalho sob a mesma licença e concorda com um
	Certificado de Origem do Desenvolvedor (consulte
	http://developercertificate.org/ para obter mais informações).

-n::
--no-verify::
	Esta opção ignora os ganchos dos commits anteriores e os ganchos das
	mensagens de commit.  Consulte também linkgit:githooks[5].

--allow-empty::
	Geralmente, gravar um commit que tem exatamente a mesma árvore como se fosse
	a sua matriz é um erro, o comando impede que você faça um commit dessa
	natureza.  Essa opção ignora a segurança e deve ser usada principalmente por
	scripts de interface SCM externos.

--allow-empty-message::
       Como a opção `--allow-empty`, este comando é principalmente para uso por
       scripts de interface SCM externos. Permite criar uma confirmação com uma
       mensagem de confirmação vazia sem usar os comandos de "encanamento" como
       linkgit:git-commit-tree[1].

--cleanup=<modo>::
	Esta opção determina como a mensagem que foi fornecida para o commit deve
	ser limpa antes de fazer o commit.  O '<modo>' pode ser `strip`,
	`whitespace`, `verbatim`, `scissors` ou `default`.
+
--
strip (tirar/remover)::
	Retira as linhas vazias no inicio e no final, e os rastros dos espaços em
	branco finais, os comentários e reduza as linhas vazias consecutivamente.
whitespace (espaço em branco)::
	O mesmo que `strip`, exceto que o `#comentário` não é removido.
verbatim (íntegra)::
	Não altera a mensagem de forma alguma.
scissors (tesouras)::
	O mesmo que `whitespace` (espaço em branco), exceto que tudo incluindo  a
	linha encontrada abaixo seja truncada caso a mensagem precise ser editada.
	"`#`" pode ser personalizada com `core.commentChar`.

		# ------------------------ >8 ------------------------

default::
	O mesmo que `strip` caso a mensagem esteja para ser editada.  Caso
	contrário, `whitespace` (espaço em branco).
--
+
A predefinição pode ser alterada através da variável de configuração
`commit.cleanup` (consulte linkgit:git-config[1]).

-e::
--edit::
	A mensagem obtida do arquivo com a opção `-F`, da linha de comando com a
	opção `-m` e do objeto commit com `C` é normalmente usada como a mensagem de
	registro log do commit não modificado. Esta opção permite editar ainda mais
	a mensagem retirada destas fontes.

--no-edit::
	Use a mensagem do commit selecionado sem rodar um editor.  Por exemplo, `git
	commit --amend --no-edit` altera um commit sem alterar o conteúdo da
	mensagem do mesmo.

--amend::
	Substitua o topo da ramificação atual criando um novo commit. A árvore
	gravada é preparada como de costume (incluindo a aplicação das opções `-i` e
	`-o`; e `pathspec` explicitamente), a mensagem do commit original é
	utilizada como um ponto de partida, em vez de uma mensagem vazia. Quando
	nenhuma outra mensagem é utilizada na linha de comando através de opções
	como `-m`, `-F`, `-c`, etc. O novo commit possuíra as mesmas matrizes e seu
	respectivo autor como o atual (a opção `--reset-author` pode ser usada para
	mudar isso).
+
--
É grosseiramente um equivalente para:
------
	$ git reset --soft HEAD^
	$ ... faça outra coisa para encontrar a árvore certa ...
	$ git commit -c ORIG_HEAD

------
mas pode ser usado para corrigir a mesclagem de um commit.
--
+
Você deve entender as implicações de sobrescrever o histórico caso corrija
um commit que já tenha sido publicado.  (Consulte a seção "RECUPERANDO DO
UPSTREAM REBASE" no linkgit:git-rebase[1].)

--no-post-rewrite::
	Ignore o gancho de reescrita de postagem.

-i::
--include::
	Antes de fazer um commit dos conteúdos preparados até o momento, prepare
	também o conteúdo dos caminhos usados na linha de comando.  Isso geralmente
	não é o que você quer, a menos que esteja concluindo um mesclagem
	conflitante.

-o::
--only::
	Faça um commit utilizando o conteúdo atualizado da árvore de trabalho dos
	caminhos informados na linha de comando, desconsiderando qualquer outro
	conteúdo que tenha sido preparado para os outros caminhos. Essa é a maneira
	predefinida de operação do comando `git commit` caso algum outro caminho
	tenha sido informado na linha de comando; nesse caso, essa opção poderá ser
	omitida.  Caso esta opção seja usada junto com `--amend`, nenhum outro
	caminho precisará ser informado, o que pode ser usado para alterar o último
	commit sem confirmar as alterações que já foram preparadas. Se usado junto
	com a opção`--allow empty` também não são necessários e uma confirmação
	vazia será criada.

--pathspec-from-file=<file>::
	Pathspec é passado em `<file>` em vez de argumentos da linha de
	comando. Caso `<file>` seja exatamente `-` então a entrada padrão é
	usada. Os elementos pathspec são separados por LF ou CR/LF. Os elementos
	pathspec podem ser citados conforme explicado na configuração da variável
	'core.quotePath' (consulte linkgit:git-config[1]). Consulte também
	`-pathspec-file-nul` e global `-literal-pathspecs`.

--pathspec-file-nul::
	Só faz algum sentido se for usado junto com `--pathspec-from-file`. Os
	elementos "pathspec" são separados com caracteres NUL e todos os outros
	caracteres são considerados de forma literal (incluindo novas linhas e
	citações).

-u[<modo>]::
--untracked-files[=<modo>]::
	Exibe arquivos sem rastreamento.
+
--
O parâmetro `<modo>` é opcional, a predefinição é `all` (todos), sendo usado
para determinar a manipulação dos arquivos que não foram rastreados; quando
a opção `-u` não é usada a predefinição é `normal`, ou seja, exibe os
arquivos e diretórios que não foram rastreados.

As opções disponíveis são:

	- 'no'     - Não exibe qualquer arquivo que não tenham sido rastreados
	- 'normal' - Exibe todos os arquivo e diretórios que não foram rastreados
	- 'all'    - Exibe todos os arquivos individualmente nos diretórios não rastreados.

A predefinição pode ser alterada usando a variável de configuração
`status.showUntrackedFiles` documentada em linkgit:git-config[1].
--

-v::
--verbose::
	Exibe as diferenças unificadas entre o commit no `HEAD` e o que seria feito
	o commit na parte inferior do modelo da mensagem do commit para ajudar o
	usuário a descrever o commit lembrando quais as alterações que o commit
	possui.  Note que esta saída "diff" não tem suas linhas prefixadas com
	'#'. Este "diff" não fará parte da mensagem do commit. Consulte a
	configuração da variável `commit.verbose` em linkgit:git-config[1].
+
Caso seja utilizado duas vezes exibirá além do diferencial unificado entre o
que seriam feitos os commits e os arquivos da árvore de trabalho, ou seja,
as alterações não-estáticas nos arquivos rastreados.

-q::
--quiet::
	Suprimir a mensagem de resumo do commit.

--dry-run::
	Não crie um commit porém exiba uma lista de caminhos onde os commits devem
	ser feitos, os caminhos com as alterações locais onde os commits serão
	deixados de lado e os caminhos que não serão rastreados.

--status::
	Inclua a saída do linkgit:git-status[1] na mensagem do commit ao usar um
	editor para preparar a mensagem do commit.  A predefinição é "ligado", porém
	pode ser utilizado para substituir a variável de configuração
	`commit.status`.

--no-status::
	Não inclua a saída do linkgit:git-status[1] no modelo da mensagem do commit
	ao utilizar um editor para preparar a mensagem predefinida do commit.

-S[<keyid>]::
--gpg-sign[=<keyid>]::
--no-gpg-sign::
	GPG-sign commits. The `keyid` argument is optional and defaults to the
	committer identity; if specified, it must be stuck to the option without a
	space. `--no-gpg-sign` is useful to countermand both `commit.gpgSign`
	configuration variable, and earlier `--gpg-sign`.

\--::
	Não interprete mais argumentos como opções.

<pathspec>...::
	Quando o `pathspec` é usado na linha de comando, faça o commit do conteúdo
	dos arquivos que correspondem ao `pathspec` sem registrar as alterações já
	adicionadas ao índice. O conteúdo desses arquivos também é preparado para o
	próximo commit, além do que já foi preparado anteriormente.
+
Para mais detalhes sobre a sintaxe <pathspec>, veja a entrada 'pathspec' em
linkgit:gitglossary[7].

EXEMPLOS
--------
Ao gravar o seu próprio trabalho, o conteúdo dos arquivos modificados na sua
árvore de trabalho é temporariamente armazenado em uma área intermediária
chamada "índice" com `git add`.  Um arquivo pode ser revertido para o último
commit com `git restore --staged <arquivo>` apenas no índice mas não na
árvore de trabalho, que reverte efetivamente o `git add` e impede que as
alterações nesse arquivo façam parte do próximo commit.  Após criar a
condição a ser feito o commit incrementalmente com esses comandos, o `git
commit` (sem nenhum parâmetro `pathname`) é usado para registrar o que foi
preparado até o momento.  Essa é a forma mais básica do comando.  Um
exemplo:

------------
$ edit hello.c
$ git rm goodbye.c
$ git add hello.c
$ git commit
------------

Em vez de disponibilizar arquivos após cada alteração individual, você pode
dizer ao `git commit` para observar as alterações nos arquivos cujo conteúdo
é rastreado na sua árvore de trabalho e faz os comandos correspondentes` git
add` e `git rm` para você.  Ou seja, este exemplo faz o mesmo que o exemplo
anterior, se não houver outra alteração na sua árvore de trabalho:

------------
$ edit hello.c
$ rm goodbye.c
$ git commit -a
------------

O comando `git commit -a` primeiro olha para a sua árvore de trabalho, nota
que você modificou o hello.c e removeu o goodbye.c e executa os comandos
necessários `git add` e `git rm` para você.

Após preparar as mudanças em muitos arquivos, você pode alterar a ordem em
que as alterações são registradas ao encaminhar `pathnames` para `git
commit`.  Quando `pathnames` são usados, o comando faz um commit que
registra apenas as alterações feitas nos caminhos informados:

------------
$ edit hello.c hello.h
$ git add hello.c hello.h
$ edit Makefile
$ git commit Makefile
------------

Isso faz um commit que registra a modificação no arquivo `Makefile`.  As
mudanças preparadas para `hello.c` e `hello.h` não são incluídas no commit
resultante.  No entanto as suas mudanças não se perdem, elas ainda são
preparadas e meramente retidas.  Após a sequência acima, se fizer:

------------
$ git commit
------------

este segundo commit registraria as alterações em `hello.c` e `hello.h`
conforme o esperado.

Depois que uma mesclagem (iniciada pelo comando `git merge` ou `git pull`) é
interrompida por causa de conflitos, os caminhos mesclados de maneira limpa
já são preparados para serem confirmados para você, e os caminhos em
conflito são deixados em um estado inalterado.  Você precisaria primeiro
verificar quais são os caminhos que estão em conflito com o comando `git
status` e depois de corrigi-los manualmente em sua árvore de trabalho, você
prepararia o resultado como de costume com o comando `git add`:

------------
$ git status | grep unmerged
unmerged: hello.c
$ edit hello.c
$ git add hello.c
------------

Após resolver os conflitos e organizar o resultado, o `git ls-files -u`
deixaria de mencionar o caminho conflitado.  Quando terminar, execute `git
commit` para finalmente registrar a mesclagem:

------------
$ git commit
------------

Como no caso de registrar as suas próprias alterações, você pode usar a
opção `-a` para salvar a digitação.  Uma diferença é que durante uma
resolução de mesclagem, você não pode usar `git commit` com `pathnames` para
alterar a ordem em que as alterações dos commits são realizados porque a
mesclagem deve ser registrada como um commit.  De fato, o comando se recusa
a executar quando recebem nomes de caminho (consulte a opção `i`).

INFORMAÇÃO DO COMMIT
--------------------

A informação do autor e de quem fez o commit são extraídas das seguintes
variáveis do ambiente, se definido:

	GIT_AUTHOR_NAME
	GIT_AUTHOR_EMAIL
	GIT_AUTHOR_DATE
	GIT_COMMITTER_NAME
	GIT_COMMITTER_EMAIL
	GIT_COMMITTER_DATE

(nb "<", ">" e "\n"s serão removidos)

É de praxe usar um nome pessoa como os nomes dos autores e de quem fez os
commits (isto é, um nome pela qual outros humanos usam para se referir a
você), no entanto o Git não impõem ou requer qualquer forma em
particular. Um unicode arbitrário pode ser utilizado e é sujeito às
restrições listadas acima. Este nome não tem nenhum efeito na autenticação;
para isso consulte a variável `credential.username` em
linkgit:git-config[1].

Caso (algumas dessas) variáveis de ambiente não sejam definidas, as
informações são obtidas dos itens de configuração `user.name` e `user.email`
ou caso não haja, na variável de ambiente `EMAIL` ou se também não existir
ou tenha sido definida, o nome de usuário do sistema e nome do host
(hostname) usado pelo email enviado (extraído de `/etc/mailname` e
retornando ao nome completo do host quando esse arquivo não existir).

O `author.name` e `committer.name` e suas respectivas opções de email
correspondentes substituem o `user.name` e `user.email` caso sejam
configurados e são substituídos pelas variáveis do ambiente.

O uso típico é definir apenas as variáveis `user.name` e `user.email`; as
outras opções são fornecidas para casos de uso mais complexos.

:git-commit: 1
include::date-formats.txt[]

DISCUSSÃO
---------

Embora não seja obrigatório, é uma boa ideia iniciar a mensagem do commit
com uma única linha curta (com menos de 50 caracteres) resumindo a
alteração, seguida por uma linha em branco e em seguida, uma descrição mais
completa.  O texto até a primeira linha em branco em uma mensagem de
confirmação é tratado como o título de confirmação e esse título é usado
através de todo o Git.  Por exemplo, o linkgit:git-format-patch[1]
transforma um commit em um email e usa o título na linha de assunto e o
restante do commit no corpo da mensagem.

include::i18n.txt[]

VARIÁVEIS DE AMBIENTE E CONFIGURAÇÃO
------------------------------------
O editor usado para editar a mensagem de registro log será escolhido a
partir da variável de ambiente `GIT_EDITOR`, a variável de configuração
core.editor, a variável de ambiente `VISUAL` ou a variável de ambiente
`EDITOR` (nesta ordem).  Para mais detalhes consulte linkgit:git-var[1].

GANCHOS
-------
Este comando pode executar os ganchos `commit-msg`, `prepare-commit-msg`,
`pre-commit`, `post-commit` e `post-rewrite`.  Para mais informações
consulte linkgit:githooks[5].

ARQUIVOS
--------

`$GIT_DIR/COMMIT_EDITMSG`::
	Este arquivo contém a mensagem do commit de um commit em andamento.  Caso o
	`git commit` encerre devido a um erro antes da criação do commit, qualquer
	mensagem do commit que tenha sido usada pelo usuário (por exemplo, em uma
	sessão do editor) estará disponível neste arquivo, mas será substituída pela
	próxima invocação do comando `git commit`.

VEJA TAMBÉM
-----------
linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mv[1],
linkgit:git-merge[1], linkgit:git-commit-tree[1]

GIT
---
Parte do linkgit:git[1] suite
