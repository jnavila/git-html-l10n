git-check-ref-format(1)
=======================

НАЗВА
-----
git-check-ref-format - Забезпечує правильне формування назви посилання

СИНОПСИС
--------
[verse]
'git check-ref-format' [--normalize]
       [--[no-]allow-onelevel] [--refspec-pattern]
       <refname>
'git check-ref-format' --branch <branchname-shorthand>

ОПИС
----
Перевіряє, чи є задане «refname» прийнятним, і завершує роботу з ненульовим статусом, якщо це не так.

Посилання використовується в Git для позначення гілок та тегів. Заголовок гілки зберігається в ієрархії `refs/heads`, тоді як тег зберігається в ієрархії `refs/tags` простору імен посилань (зазвичай у каталогах `$GIT_DIR/refs/heads` та `$GIT_DIR/refs/tags` або як записи у файлі `$GIT_DIR/packed-refs`, якщо посилання упаковані за допомогою `git gc`).

Git накладає такі правила на іменування посилань:

. Вони можуть містити скісну риску `/` для ієрархічного (каталогічного) групування, але жоден компонент, розділений сксельною рискою, не може починатися з крапки `.` або закінчуватися послідовністю `.lock`.

. Вони повинні містити принаймні один символ `/`. Це забезпечує наявність категорії, такої як `heads/`, `tags/` тощо, але фактичні назви не обмежені. Якщо використовується опція `--allow-onelevel`, це правило не діє.

. Вони не можуть містити дві послідовні крапки `..` ніде.

. Вони не можуть містити керівні символи ASCII (тобто байти, значення яких менші за \040 або \177 `DEL`), пробіл, тильду `~`, каретку `^` або двокрапку `:` будь-де.

. Вони не можуть містити знак питання `?`, зірочку `*` або відкриту дужку `[` будь-де. Дивіться опцію `--refspec-pattern` нижче для винятку з цього правила.

. Вони не можуть починатися або закінчуватися склесом `/` або містити кілька послідовних склесів (див. опцію `--normalize` нижче як виняток із цього правила).

. Вони не можуть закінчуватися крапкою `.`.

. Вони не можуть містити послідовність `@{`.

. Вони не можуть бути одним символом `@`.

. Вони не можуть містити символ `\`.

Ці правила спрощують для інструментів на основі скриптів оболонки розбір імен посилань, розширення шляхів оболонкою, коли ім'я посилання використовується без лапок (помилково), а також уникають неоднозначностей у певних виразах імен посилань (див. linkgit:gitrevisions[7]):

. Подвійна крапка `..` часто використовується як у `ref1..ref2`, а в деяких контекстах це позначення означає `^ref1 ref2` (тобто не в `ref1`, а в `ref2`).

. Тильда `~` та каретка `^` використовуються для введення постфіксної операції 'n-й батько' та 'очищення цибулі'.

. Двокрапка `:` використовується, як у `srcref:dstref`, для позначення «використовувати значення srcref\ та зберігати його в dstref» в операціях fetch та push. Її також можна використовувати для вибору певного об'єкта, наприклад, у 'git cat-file': "git cat-file blob v1.3.3:refs.c".

. at-open-brace `@{` використовується як нотація для доступу до запису reflog.

З опцією `--branch` команда приймає ім'я та перевіряє, чи можна його використовувати як коректне ім'я гілки (наприклад, під час створення нової гілки). Але будьте обережні, використовуючи попередній синтаксис перевірки, який може посилатися на відокремлений стан HEAD. Правило, яке реалізує `git check-ref-format --branch $name`, може бути суворішим, ніж те, що говорить `git check-ref-format refs/heads/$name` (наприклад, тире може з'явитися на початку компонента ref, але воно явно заборонено на початку назви гілки). Під час запуску з опцією `--branch` у репозиторії вхідні дані спочатку розширюються для ``попереднього синтаксису перевірки'' `@{-n}`. Наприклад, `@{-1}` - це спосіб посилатися на останній елемент, який був витягнутий за допомогою операції "git switch" або "git checkout". Цей параметр повинен використовуватися porcelains для прийняття цього синтаксису будь-де, де очікується ім'я гілки, щоб вони могли діяти так, ніби ви ввели ім'я гілки. Як виняток, зауважте, що «попередня операція отримання» може призвести до появи назви об'єкта коміту, коли N-та остання отримана річ не була гілкою.

ОПЦІЇ
-----
--[no-]allow-onelevel::
	Контролює, чи приймаються однорівневі посилання (тобто посилання, що не містять кількох компонентів, розділених `/`). Значення за замовчуванням — `--no-allow-onelevel`.

--refspec-pattern::
	Інтерпретувати <refname> як шаблон назви посилання для специфікації посилань (як використовується з віддаленими репозиторіями). Якщо ця опція увімкнена, <refname> може містити одну `*` у специфікації посилань (наприклад, `foo/bar*/baz` або `foo/bar*baz/`, але не `foo/bar*/baz*`).

--normalize::
	Нормалізуйте «refname», видаливши будь-які початкові символи скісну риску (`/`) та згорнувши послідовності суміжних скісну риск між компонентами імені в одну скісну риску. Якщо нормалізоване refname є коректним, виведіть його на стандартний вивід та вийдіть зі статусом 0, інакше вийдіть зі статусом, не рівним нулю. (`--print` — це застарілий спосіб написання `--normalize`.)


ПРИКЛАДИ
--------

* Виведіть назву попереднього вилученого елемента:
+
------------
$ git check-ref-format --branch @{-1}
------------

* Визначте ім'я посилання, яке буде використовуватися для нової гілки:
+
------------
$ ref=$(git check-ref-format --normalize "refs/heads/$newbranch")||
{ echo "we do not like '$newbranch' as a branch name." >&2 ; exit 1 ; }
------------

GIT
---
Частина набору linkgit:git[1]
