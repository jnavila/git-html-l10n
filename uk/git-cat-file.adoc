git-cat-file(1)
===============

НАЗВА
-----
git-cat-file - Надайте вміст або деталі об'єктів репозиторію

СИНОПСИС
--------
[verse]
'git cat-file' <type> <object>
'git cat-file' (-e | -p | -t | -s) <object>
'git cat-file' (--textconv | --filters)
	     [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]
'git cat-file' (--batch | --batch-check | --batch-command) [--batch-all-objects]
	     [--buffer] [--follow-symlinks] [--unordered]
	     [--textconv | --filters] [-Z]

ОПИС
----
Виведіть вміст або інші властивості, такі як розмір, тип або дельта-інформацію для одного або кількох об'єктів.

Ця команда може працювати у двох режимах, залежно від того, чи вказано опцію з родини `--batch`.

У непакетному режимі команда надає інформацію про об'єкт, ім'я якого вказано в командному рядку.

У пакетному режимі аргументи зчитуються зі стандартного вводу.

ОПЦІЇ
-----
<object>::
	Назва об'єкта для відображення. Повніший список способів написання назв об'єктів див. у розділі «ВКАЗАННЯ РЕВІЗІЙ» у linkgit:gitrevisions[7].

-t::
	Замість вмісту, відображати тип об'єкта, ідентифікований як `<object>`.

-s::
	Замість вмісту, показувати розмір об'єкта, ідентифікованого за допомогою `<object>`. Якщо використовується з опцією `--use-mailmap`, показуватиметься розмір оновленого об'єкта після заміни ідентифікаторів за допомогою механізму mailmap.

-e::
	Вихід з нульовим статусом, якщо `<object>` існує та є коректним об'єктом. Якщо `<object>` має некоректний формат, вихід з ненульовим статусом та виведенням помилки на stderr.

-p::
	Гарно вивести вміст `<object>` на основі його типу.

<type>::
	Зазвичай це відповідає реальному типу `<object>`, але також дозволено запитувати тип, який можна тривіально розіменувати з заданого `<object>`. Прикладом є запит на "дерево" з `<object>` як об'єктом коміту, який його містить, або запит на "блоб" з `<object>` як об'єктом тегу, який вказує на нього.

--[no-]mailmap::
--[no-]use-mailmap::
       Використовуйте файл mailmap для зіставлення імен авторів, комітерів та тегерів, а також адрес електронної пошти з канонічними справжніми іменами та адресами електронної пошти. Див. linkgit:git-shortlog[1].

--textconv::
	Показує вміст, перетворений фільтром textconv. У цьому випадку `<object>` має мати формат `<tree-ish>:<path>` або `:<path>`, щоб застосувати фільтр до вмісту, записаного в індексі за адресою `<path>`.

--filters::
	Показує вміст, конвертований фільтрами, налаштованими в поточному робочому дереві для заданого `<шлях>` (тобто фільтри розмазування, конвертація кінця рядка тощо). У цьому випадку `<об'єкт>` має мати формат `<деревоподібно>:<шлях>` або `:<шлях>`.

--filter=<filter-spec>::
--no-filter::
	Пропустити об'єкти зі списку друкованих об'єктів. Це можна використовувати лише в поєднанні з одним із пакетних режимів. Виключені об'єкти, які були явно запитувані через будь-який із пакетних режимів, що зчитують об'єкти через стандартний ввід (`--batch`, `--batch-check`), будуть позначені як "відфільтровані". Виключені об'єкти в режимі `--batch-all-objects` взагалі не будуть друковані. '<фільтр-специфікація>' може бути одним із наступних:
+
Форма '--filter=blob:none' пропускає всі блоби.
+
Форма '--filter=blob:limit=<n>[kmg]' пропускає блоби розміром щонайменше n байтів або одиниць. n може дорівнювати нулю. Суфікси k, m та g можна використовувати для найменування одиниць у KiB, MiB або GiB. Наприклад, 'blob:limit=1k' те саме, що й 'blob:limit=1024'.
+
Форма '--filter=object:type=(tag|commit|tree|blob)' пропускає всі об'єкти, які не належать до запитуваного типу.

--path=<path>::
	Для використання з `--textconv` або `--filters`, щоб дозволити окремо вказувати назву об'єкта та шлях, наприклад, коли важко визначити ревізію, з якої походить блоб.

--batch::
--batch=<format>::
	Вивести інформацію про об'єкт та вміст для кожного об'єкта, що надається на stdin. Не можна поєднувати з будь-якими іншими опціями чи аргументами, окрім `--textconv`, `--filters` або `--use-mailmap`.
+
--
	* При використанні з `--textconv` або `--filters`, у рядках введення необхідно вказувати шлях, розділений пробілами. Див. розділ `ПАКЕТНИЙ ВИВІД` нижче для отримання детальної інформації.

	* При використанні з `--use-mailmap` для об'єктів commit та tag, частина contents виводу показує ідентифікаційні дані, замінені за допомогою механізму mailmap, тоді як частина information виводу показує розмір об'єкта так, ніби він фактично записав замінені ідентифікаційні дані.
--

--batch-check::
--batch-check=<format>::
	Вивести інформацію про кожен об'єкт, наданий на stdin. Не можна поєднувати з будь-якими іншими опціями чи аргументами, окрім `--textconv`, `--filters` або `--use-mailmap`.
+
--
	* При використанні з `--textconv` або `--filters`, рядки введення повинні
	 вкажіть шлях, розділений пробілами.
	 Див. розділ `ПАКЕТНИЙ ВИВІД` нижче для отримання детальної інформації.

	* При використанні з `--use-mailmap` для об'єктів commit та tag, виведена інформація про об'єкт показує розмір об'єкта так, ніби записані в ньому ідентифікаційні дані були замінені механізмом mailmap.
--

--batch-command::
--batch-command=<формат>::
	Введіть командний режим, який зчитує команди та аргументи зі стандартного введення. Можна поєднувати лише з `--buffer`, `--textconv`, `--use-mailmap` або `--filters`.
+
--
	* При використанні з `--textconv` або `--filters`, у рядках введення необхідно вказувати шлях, розділений пробілами. Див. розділ `ПАКЕТНИЙ ВИВІД` нижче для отримання детальної інформації.

	* При використанні з `--use-mailmap` для об'єктів commit та tag, команда `contents` показує ідентифікаційні дані, замінені за допомогою механізму mailmap, тоді як команда `info` показує розмір об'єкта так, ніби він фактично записав замінені ідентифікаційні дані.
--
+
`--batch-command` розпізнає такі команди:
+
--
зміст <object>::
	Вивести вміст об'єкта для посилання на об'єкт `<object>`. Це відповідає виводу `--batch`.

інформація <object>::
	Вивести інформацію про об'єкт для посилання на об'єкт `<object>`. Це відповідає виводу `--batch-check`.

flush::
	Використовується з `--buffer` для виконання всіх попередніх команд, виданих з початку або з моменту останнього виконання flush. Коли використовується `--buffer`, вивід не надходитиме, доки не буде видано `flush`. Коли `--buffer` не використовується, команди щоразу скидаються без виконання `flush`.
--
+

--batch-all-objects::
	Замість читання списку об'єктів на stdin, виконайте запитувану пакетну операцію з усіма об'єктами в репозиторії та будь-яких альтернативних сховищах об'єктів (не лише з доступними об'єктами). Потрібно вказати `--batch` або `--batch-check`. За замовчуванням об'єкти відвідуються в порядку сортування за їхніми хешами; див. також `--unordered` нижче. Об'єкти представлені як є, без дотримання механізму "заміни" linkgit:git-replace[1].

--buffer::
	Зазвичай пакетний вивід очищується після виведення кожного об'єкта, щоб процес міг інтерактивно читати та записувати з `cat-file`. З цією опцією вивід використовує звичайну буферизацію stdio; це набагато ефективніше при виклику `--batch-check` або `--batch-command` для великої кількості об'єктів.

--unordered::
	Коли використовується `--batch-all-objects`, відвідуйте об'єкти в порядку, який може бути ефективнішим для доступу до вмісту об'єктів, ніж порядок хешування. Точні деталі порядку не вказані, але якщо вам не потрібен певний порядок, це, як правило, має призвести до швидшого виводу, особливо з `--batch`. Зверніть увагу, що `cat-file` все одно відображатиме кожен об'єкт лише один раз, навіть якщо він зберігається в репозиторії кілька разів.

--follow-symlinks::
	За допомогою `--batch` або `--batch-check`, слідкуйте за символічними посиланнями всередині репозиторію під час запиту об'єктів з розширеними SHA-1 виразами виду деревоподібний:шлях-у-дереві. Замість того, щоб надавати вивід про саме посилання, надайте вивід про об'єкт, на який воно пов'язане. Якщо символічне посилання вказує за межі деревоподібного об'єкта (наприклад, посилання на `/foo` або посилання кореневого рівня на `../foo`), буде виведена частина посилання, яка знаходиться за межами дерева.
+
Ця опція (наразі) не працює належним чином, коли вказано об'єкт в індексі (наприклад, `:link` замість `HEAD:link`), а не в дереві.
+
Цей параметр (наразі) не може бути використаний, якщо не використовується `--batch` або `--batch-check`.
+
Наприклад, розглянемо репозиторій git, що містить:
+
--
	f: a file containing "hello\n"
	link: a symlink to f
	dir/link: a symlink to ../f
	plink: a symlink to ../f
	alink: a symlink to /etc/passwd
--
+
Для звичайного файлу `f`, `echo HEAD:f | git cat-file --batch` виведе
+
--
	ce013625030ba8dba906f756967f9e9ca394464a blob 6
--
+
А `echo HEAD:link | git cat-file --batch --follow-symlinks` виведе те саме, що й `HEAD:dir/link`, оскільки обидва вказують на `HEAD:f`.
+
Без `--follow-symlinks`, вони виводитимуть дані про саме символічне посилання. У випадку `HEAD:link`, ви побачите
+
--
	4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1
--
+
Як `plink`, так і `alink` вказують за межі дерева, тому вони відповідно виведуть:
+
--
	symlink 4
	../f

	symlink 11
	/etc/passwd
--

-Z::
	Має сенс лише з `--batch`, `--batch-check` або `--batch-command`; вхідні та вихідні дані розділені NUL-значеннями, а не символами нового рядка.

-z::
	Має сенс лише з `--batch`, `--batch-check` або `--batch-command`; вхідні дані розділені NUL-значеннями, а не символами нового рядка. Цей параметр застарів на користь `-Z`, оскільки в іншому випадку вивід може бути неоднозначним.


ВИХІД
-----
Якщо вказано `-t`, один з `<тип>`.

Якщо вказано `-s`, розмір `<об'єкта>` у байтах.

Якщо вказано `-e`, вивід не виконується, окрім випадків, коли `<об'єкт>` має неправильний формат.

Якщо вказано `-p`, вміст `<object>` виводиться гарним чином.

Якщо вказано `<тип>`, буде повернуто необроблений (хоча й нестиснутий) вміст `<об'єкта>`.

ПАКЕТНИЙ ВИВІД
--------------

Якщо вказано `--batch` або `--batch-check`, `cat-file` зчитуватиме об'єкти зі stdin, по одному на рядок, та виводитиме інформацію про них у тому ж порядку, в якому вони були прочитані. За замовчуванням весь рядок вважається об'єктом, ніби він був переданий до linkgit:git-rev-parse[1].

Коли вказано `--batch-command`, `cat-file` зчитуватиме команди зі stdin, по одній на рядок, та виводитиме інформацію на основі введеної команди. З `--batch-command`, команда `info`, за якою йде об'єкт, виводитиме інформацію про об'єкт так само, як це зробив би `--batch-check`, а команда `contents`, за якою йде об'єкт, виводитиме вміст так само, як це зробив би `--batch`.

Ви можете вказати інформацію, яка відображається для кожного об'єкта, використовуючи власний `<format>`. `<format>` копіюється буквально до stdout для кожного об'єкта, з розгорнутими заповнювачами виду `%(atom)`, за якими йде символ нового рядка. Доступні атоми:

`objectname`::
	Повне шістнадцяткове представлення імені об'єкта.

`objecttype`::
	Тип об'єкта (те саме, що й у звітах `cat-file -t`).

`objectmode`::
	Якщо вказаний об'єкт має інформацію про режим (наприклад, дерево або елемент індексу), режим виражається як вісімкове ціле число. В іншому випадку, порожній рядок.

`objectsize`::
	Розмір об'єкта в байтах (те саме, що й повідомляє `cat-file -s`).

`objectsize:disk`::
	Розмір, у байтах, який об’єкт займає на диску. Див. примітку щодо розмірів на диску в розділі «ЗАСТЕРЕЖЕННЯ» нижче.

`deltabase`::
	Якщо об'єкт зберігається на диску як дельта, це розширюється до повного шістнадцяткового представлення назви базового об'єкта дельта. В іншому випадку розширюється до нульового OID (всі нулі). Див. `ЗАСТЕРЕЖЕННЯ` нижче.

`rest`::
	Якщо цей атом використовується у вихідному рядку, вхідні рядки розділяються на межі першого пробілу. Усі символи перед цим пробілом вважаються назвою об'єкта; символи після першого пробілу (тобто "решта" рядка) виводяться замість атома `%(rest)`.

Якщо формат не вказано, формат за замовчуванням — `%(назва об'єкта) %(тип об'єкта) %(розмір об'єкта)`.

Якщо вказано `--batch` або якщо `--batch-command` використовується з командою `contents`, після інформації про об'єкт йде вміст об'єкта (що складається з `%(objectsize)` байтів), а потім символ нового рядка.

Наприклад, `--batch` без власного формату призведе до:

-----------
<oid> SP <type> SP <size> LF
<contents> LF
-----------

Тоді як `--batch-check='%(name_object) %(objecttype)'` видасть:

------------
<oid> SP <type> LF
------------

Якщо на stdin вказано ім'я, яке не може бути перетворене на об'єкт у репозиторії, тоді `cat-file` проігнорує будь-який користувацький формат та виведе:

------------
<object> SP missing LF
------------

Якщо на stdin вказано ім'я, яке фільтрується за допомогою `--filter=`, то `cat-file` проігнорує будь-який користувацький формат та виведе:

------------
<object> SP excluded LF
------------

Якщо вказано ім'я, яке може посилатися на декілька об'єктів (неоднозначний короткий шаблон), тоді `cat-file` проігнорує будь-який користувацький формат та виведе:

------------
<object> SP ambiguous LF
------------

Якщо вказано ім'я, яке посилається на запис підмодуля в дереві, а цільовий об'єкт не існує в репозиторії, тоді `cat-file` проігнорує будь-який користувацький формат та виведе (з ідентифікатором об'єкта підмодуля):

------------
<oid> SP submodule LF
------------

Якщо використовується `--follow-symlinks`, і символічне посилання в репозиторії вказує за межі репозиторію, тоді `cat-file` ігноруватиме будь-який користувацький формат та виведе:

------------
symlink SP <size> LF
<symlink> LF
------------

Символічне посилання буде або абсолютним (починаючи з `/`), або відносним до кореня дерева. Наприклад, якщо dir/link вказує на `../../foo`, тоді `<симліка>` буде `../foo`. `<розмір>` – це розмір символічного посилання в байтах.

Якщо використовується `--follow-symlinks`, будуть відображатися такі повідомлення про помилки:

------------
<object> SP missing LF
------------
друкується, коли початкове запитуване символічне посилання не існує.

------------
dangling SP <size> LF
<object> LF
------------
друкується, коли початкове символічне посилання існує, але щось, на що воно (транзитивне) вказує, ні.

------------
loop SP <size> LF
<object> LF
------------
друкується для циклів символічних посилань (або будь-яких символічних посилань, для вирішення яких потрібно більше 40 розв'язань посилань).

------------
notdir SP <size> LF
<object> LF
------------
друкується, коли під час розв'язання символічних посилань файл використовується як ім'я каталогу.

Або ж, коли передається `-Z`, символи переведення рядка в будь-якому з наведених вище прикладів замінюються на NUL-термінатори. Це гарантує, що вивід буде придатним для розбору, якщо сам вивід містить символ переведення рядка, і тому рекомендується для цілей скриптів.

ЗАСТЕРЕЖЕННЯ
------------

Зверніть увагу, що розміри об'єктів на диску повідомляються точно, але слід бути обережним, роблячи висновки про те, які посилання або об'єкти відповідають за використання диска. Розмір упакованого недельта-об'єкта може бути набагато більшим за розмір об'єктів, які дельта-об'єкти відносно нього, але вибір того, який об'єкт є базовим, а який дельта-об'єктом, є довільним і може змінюватися під час перепаковки.

Також зауважте, що в базі даних об'єктів може бути кілька копій об'єкта; у цьому випадку не визначено, розмір або дельта-база якої копії буде відображатися.

GIT
---
Частина набору linkgit:git[1]
