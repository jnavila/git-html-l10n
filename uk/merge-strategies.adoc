СТРАТЕГІЇ ЗЛИТТЯ
----------------

Механізм злиття (команди `git merge` та `git pull`) дозволяє вибирати бекенд-«стратегії злиття» за допомогою опції `-s`. Деякі стратегії також можуть приймати власні опції, які можна передати, надаючи аргументи `-X<опція>` командам `git merge` та/або `git pull`.

`ort`::
	Це стратегія злиття за замовчуванням під час витягування або об'єднання однієї гілки. Ця стратегія може вирішити лише дві гілки за допомогою 3-стороннього алгоритму злиття. Коли є більше одного спільного предка, якого можна використовувати для 3-стороннього злиття, створюється об'єднане дерево спільних предків і використовується його як опорне дерево для 3-стороннього злиття. Повідомлялося, що це призводить до меншої кількості конфліктів злиття без виникнення помилок злиття, згідно з тестами, проведеними на фактичних коммітах злиття, взятих з історії розробки ядра Linux 2.6. Крім того, ця стратегія може виявляти та обробляти злиття, що включають перейменування. Вона не використовує виявлені копії. Назва цього алгоритму є абревіатурою ("Ostensibly Recursive's Twin") і походить від того факту, що він був написаний як заміна попереднього алгоритму за замовчуванням, `recursive`.
+
У випадку, коли шлях є підмодулем, якщо коміт підмодуля, використаний на одному боці злиття, є нащадком коміту підмодуля, використаного на іншому боці злиття, Git намагається перейти до нащадка. В іншому випадку Git розглядатиме цей випадок як конфлікт, пропонуючи як вирішення коміт підмодуля, який є нащадком конфліктуючих, якщо такий існує.
+
Стратегія `ort` може приймати такі варіанти:

`ours`;;
	Ця опція примусово автоматично вирішує конфліктуючі фрагменти, надаючи перевагу «нашій» версії. Зміни з іншого дерева, які не конфліктують з нашою стороною, відображаються в результаті злиття. Для бінарного файлу весь вміст береться з нашої сторони.
+
Це не слід плутати зі стратегією злиття `ours`, яка навіть не дивиться на те, що містить інше дерево. Вона відкидає все, що зробило інше дерево, оголошуючи, що історія `our` містить усе, що в ній сталося.

`theirs`;;
	Це протилежність до «ours»; зверніть увагу, що на відміну від «ours», немає стратегії злиття «hirs», з якою можна було б сплутати цей варіант злиття.

`ignore-space-change`;;
`ignore-all-space`;;
`ignore-space-at-eol`;;
`ignore-cr-at-eol`;;
	Обробляє рядки з вказаним типом зміни пробілів як незмінні для тристороннього об'єднання. Зміни пробілів, змішані з іншими змінами в рядку, не ігноруються. Див. також linkgit:git-diff[1] `-b`, `-w`, `--ignore-space-at-eol` та `--ignore-cr-at-eol`.
+
* Якщо «їхня» версія вносить лише зміни пробілами в рядок, використовується «наша» версія;
* Якщо «наша» версія містить зміни пробілів, але «їхня» версія містить суттєві зміни, використовується «їхня» версія;
* В іншому випадку об'єднання відбувається у звичайному порядку.

`renormalize`;;
	Це запускає віртуальне отримання та повернення всіх трьох етапів будь-якого файлу, який потребує тристороннього злиття. Цей параметр призначений для використання під час об'єднання гілок з різними фільтрами очищення або правилами нормалізації кінця рядка. Див. "Об'єднання гілок з різними атрибутами реєстрації/вивантаження" в linkgit:gitattributes[5] для отримання детальної інформації.

`no-renormalize`;;
	Вимикає опцію `renormalize`. Це замінює змінну конфігурації `merge.renormalize`.

`find-renames[=<n>]`;;
	Увімкнути виявлення перейменування, за потреби встановити поріг подібності. Це значення за замовчуванням. Це перевизначає змінну конфігурації `merge.renames`. Див. також linkgit:git-diff[1] `--find-renames`.

`rename-threshold=<n>`;;
	Застарілий синонім до `find-renames=<n>`.

`no-renames`;;
	Вимкніть виявлення перейменування. Це замінює змінну конфігурації `merge.renames`. Див. також linkgit:git-diff[1] `--no-renames`.

`histogram`;;
	Застарілий синонім до `diff-algorithm=histogram`.

`patience`;;
	Застарілий синонім до `diff-algorithm=patience`.

`diff-algorithm=(histogram|minimal|myers|patience)`;;
	Використовуйте інший алгоритм порівняння під час об'єднання, що може допомогти уникнути неправильних злиття, що виникають через неважливі збіги рядків (наприклад, фігурні дужки з різних функцій). Див. також linkgit:git-diff[1] `--diff-algorithm`. Зверніть увагу, що `ort` за замовчуванням має значення `diff-algorithm=histogram`, тоді як звичайні порівняння наразі за замовчуванням використовують налаштування конфігурації `diff.algorithm`.

`subtree[=<path>]`;;
	Цей варіант є більш просунутою формою стратегії «піддерева», де стратегія робить припущення щодо того, як два дерева мають бути зміщені, щоб збігатися під час об'єднання. Натомість, зазначений шлях додається до початку (або видаляється з самого початку), щоб форма двох дерев збігалася.

`recursive`::
	Тепер це синонім до `ort`. Це була альтернативна реалізація до версії 2.49.0, але була перенаправлена на `ort` у версії 2.50.0. Попередня рекурсивна стратегія була стратегією за замовчуванням для розв'язання двох голов з Git версії 0.99.9k до версії 2.33.0.

`resolve`::
	Це може вирішити лише дві гілки (тобто поточну гілку та іншу гілку, з якої ви витягли дані) за допомогою 3-стороннього алгоритму злиття. Він намагається ретельно виявити перехресні неоднозначності злиття. Він не обробляє перейменування.

`octopus`::
	Це вирішує випадки з більш ніж двома заголовками, але відмовляється від складного об'єднання, яке потребує ручного вирішення. В основному це призначено для об'єднання заголовків тематичних гілок. Це стратегія об'єднання за замовчуванням під час витягування або об'єднання кількох гілок.

`ours`::
	Це дозволяє вирішувати будь-яку кількість заголовків, але результуюче дерево злиття завжди буде таким, як поточна заголовка гілки, фактично ігноруючи всі зміни з усіх інших гілок. Це призначено для використання для заміни старої історії розробки бічних гілок. Зверніть увагу, що це відрізняється від опції `-Xours` для стратегії злиття `ort`.

`subtree`::
	Це модифікована стратегія `ort`. Під час об'єднання дерев A та B, якщо B відповідає піддереву A, B спочатку коригується відповідно до структури дерева A, замість того, щоб зчитувати дерева на одному рівні. Це коригування також виконується для дерева спільного предка.

Зі стратегіями, що використовують 3-стороннє злиття (включаючи `ort` за замовчуванням), якщо зміна внесена в обидві гілки, але пізніше скасована в одній з гілок, ця зміна буде присутня в результаті об'єднання; деякі люди вважають таку поведінку заплутаною. Це відбувається тому, що під час виконання злиття враховуються лише заголовки та база злиття, а не окремі коміти. Тому алгоритм злиття вважає скасовану зміну як таку, що взагалі не вносила змін, і замінює її зміненою версією.
