git-for-each-ref(1)
===================

НАЗВА
-----
git-for-each-ref - Вивести інформацію про кожне посилання

СИНОПСИС
--------
[synopsis]
git for-each-ref [--count=<count>] [--shell|--perl|--python|--tcl]
		   [(--sort=<key>)...] [--format=<format>]
		   [--include-root-refs] [--points-at=<object>]
		   [--merged[=<object>]] [--no-merged[=<object>]]
		   [--contains[=<object>]] [--no-contains[=<object>]]
		   [(--exclude=<pattern>)...] [--start-after=<marker>]
		   [ --stdin | (<pattern>...)]

ОПИС
----

Перебрати всі посилання, що відповідають _<шаблон>_, та показати їх відповідно до заданого _<формат>_, після сортування їх відповідно до заданого набору _<ключ>_. Якщо задано _<кількість>_, зупинитися після показу такої кількості посилань. Інтерпольовані значення в _<формат>_ можна за бажанням взяти у лапки як рядкові літерали на вказаній мові хоста, що дозволяє їх безпосередню оцінку цією мовою.

ОПЦІЇ
-----
include::for-each-ref-options.adoc[]

НАЗВИ ПОЛІВ
-----------

Різні значення зі структурованих полів у об'єктах, на які посилаються, можна використовувати для інтерполяції в результуючий вивід або як ключі сортування.

Для всіх об'єктів можна використовувати такі назви:

`refname`::
	Назва посилання (частина після `$GIT_DIR/`). Для неоднозначної короткої назви посилання додайте `:short`. Опція `core.warnAmbiguousRefs` використовується для вибору режиму суворого скорочення. Якщо додано `lstrip=<n>` (`rstrip=<n>`), видаляються компоненти шляху, розділені косою рискою, з початку (конця) назви посилання (наприклад, `%(refname:lstrip=2)` перетворює `refs/tags/foo` на `foo`, а `%(refname:rstrip=2)` перетворює `refs/tags/foo` на `refs`). Якщо _<n>_ – від’ємне число, видаляється стільки компонентів шляху, скільки потрібно, з зазначеного кінця, щоб залишилися компоненти шляху `-<n>` (наприклад, `%(refname:lstrip=-2)` перетворює `refs/tags/foo` на `tags/foo`, а `%(refname:rstrip=-1)` перетворює `refs/tags/foo` на `refs`). Коли посилання не має достатньо компонентів, результат стає порожнім рядком, якщо видаляється з додатним _<n>_, або він стає повним ім’ям посилання, якщо видаляється з від’ємним _<N>_. Жодне з цих дій не є помилкою.
+
`strip` можна використовувати як синонім `lstrip`.

`objecttype`::
	Тип об'єкта (`blob`, `tree`, `commit`, `tag`).

`objectsize`::
	Розмір об'єкта (те саме, що й у звітах 'git cat-file -s'). Додайте `:disk`, щоб отримати розмір у байтах, який об'єкт займає на диску. Дивіться примітку щодо розмірів на диску в розділі 'ЗАСТЕРЕЖЕННЯ' нижче.
`objectname`::
	Ім'я об'єкта (також відоме як SHA-1). Для неоднозначного скорочення назви об'єкта додайте `:short`. Для скорочення назви об'єкта з бажаною довжиною додайте `:short=<довжина>`, де мінімальна довжина дорівнює `MINIMUM_ABBREV`. Довжину можна перевищити, щоб забезпечити унікальність назв об'єктів.
`deltabase`::
	Це розширюється до назви об'єкта дельта-бази для заданого об'єкта, якщо вона збережена як дельта. В іншому випадку, воно розширюється до нульової назви об'єкта (всі нулі).

`upstream`::
	Назва локального посилання, яке можна вважати «вище за течією» відносно відображеного посилання. Враховує `:short`, `:lstrip` та `:rstrip` так само, як і `refname` вище. Додатково враховує `:track` для відображення "[ahead N, behind M]" та `:trackshort` для відображення скороченої версії: ">" (ahead), "<" (behind), "<>" (ahead та behind) або "=" (синхронізовано). `:track` також друкує "[gone]" щоразу, коли зустрічається невідоме посилання вище за течією. Додайте `:track,nobracket` для відображення інформації про відстеження без дужок (тобто "ahead N, behind M").
+
Для будь-якої гілки віддаленого відстеження `%(upstream)`, `%(upstream:remotename)` та `%(upstream:remoteref)` посилаються на назву віддаленого об'єкта та назву відстежуваного віддаленого посилання відповідно. Іншими словами, гілку віддаленого відстеження можна оновлювати явно та окремо за допомогою специфікації посилань `%(upstream:remoteref):%(upstream)` для вибору з `%(upstream:remotename)`.
+
Не має ефекту, якщо посилання не має пов'язаної з ним інформації про відстеження. Усі опції, окрім `nobracket`, є взаємовиключними, але якщо вони використовуються разом, вибирається остання опція.

`push`::
	Ім'я локального посилання, яке представляє розташування `@{push}` для відображеного посилання. Враховує опції `:short`, `:lstrip`, `:rstrip`, `:track`, `:trackshort`, `:remotename` та `:remoteref`, як і `upstream`. Створює порожній рядок, якщо посилання `@{push}` не налаштовано.

`HEAD`::
	`*` якщо `HEAD` відповідає поточному посиланню (витягнутій гілці), ' ' інакше.

`color`::
	Змінити колір виводу. Далі йде `:<назва кольору>`, де назви кольорів описані в розділі "Значення" в розділі "ФАЙЛ КОНФІГУРАЦІЇ" файлу linkgit:git-config[1]. Наприклад, `%(color:bold red)`.

`align`::
	Вирівнювання вмісту між `%(align:...)` та `%(end)` по лівому, середньому або правому краю. Після "`align:`" йдуть `width=<width>` та `position=<position>` у будь-якому порядку, розділені комою, де _<position>_ є або `left`, `right`, або `middle`, за замовчуванням `left`, а _<width>_ – це загальна довжина вмісту з вирівнюванням. Для стислості префікси "width=" та/або "position=" можна пропустити, а замість них використовувати лише _<width>_ та _<position>_. Наприклад, `%(align:<width>,<position>)`. Якщо довжина вмісту більша за ширину, вирівнювання не виконується. Якщо використовується з `--quote`, все між `%(align:...)` та `%(end)` береться в лапки, але якщо вкладено, то лапки виконується лише на найвищому рівні.

`if`::
	Використовується як `%(if)...%(then)...%(end)` або `%(if)...%(then)...%(else)...%(end)`. Якщо після `%(if)` є атом зі значенням або рядковим літералом, то друкується все після `%(then)`, інакше, якщо використовується атом `%(else)`, то друкується все після %(else). Ми ігноруємо пробіли під час обчислення рядка перед `%(then)`, це корисно, коли ми використовуємо атом `%(HEAD)`, який друкує "`*`" або " ", і ми хочемо застосувати умову 'if' лише до посилання `HEAD`. Додайте "`:equals=<string>`" або "`:notequals=<string>`", щоб порівняти значення між атомами `%(if:...)` та `%(then)` з заданим рядком.

`symref`::
	Посилання, на яке посилається задане символічне посилання. Якщо посилання не є символічним, нічого не друкується. Враховує опції `:short`, `:lstrip` та `:rstrip` так само, як і `refname` вище.

`signature`::
	GPG-підпис коміту.

`signature:grade`::
	Показати
`G`;; за хороший (дійсний) підпис
`B`;; за поганий підпис
`U`;; для хорошого підпису з невідомою достовірністю
`X`;;	за хороший підпис, термін дії якого минув
`Y`;; за хороший підпис, зроблений простроченим ключем
`R`;; за хороший підпис, зроблений анульованим ключем
`E`;; якщо підпис неможливо перевірити (наприклад, відсутній ключ)
`N`;; за відсутність підпису.

`signature:signer`::
	Підписувач GPG-підпису коміту.

`signature:key`::
	Ключ GPG-підпису коміту.

`signature:fingerprint`::
	Відбиток GPG-підпису коміта.

`signature:primarykeyfingerprint`::
	Відбиток первинного ключа GPG-підпису коміта.

`signature:trustlevel`::
	Рівень довіри GPG-сигнатури коміта. Можливі виходи: `ultimate`, `fully`, `marginal`, `never` та `undefined`.

`worktreepath`::
	Абсолютний шлях до робочого дерева, в якому витягнуто посилання, якщо воно витягнуто в будь-якому зв'язаному робочому дереві. В іншому випадку порожній рядок.

`ahead-behind:<commit-ish>`::
	Два цілі числа, розділені пробілом, що показують кількість комітів попереду та позаду відповідно, при порівнянні вихідного посилання з _<committish>_, зазначеним у форматі.

`is-base:<commit-ish>`::
	Щонайбільше в одному рядку з'явиться `(<commit-ish>)`, щоб вказати посилання, яке, найімовірніше, є тим посиланням, що використовувалося як відправна точка для гілки, що створила _<commit-ish>_. Цей вибір робиться за допомогою евристики: оберіть посилання, яке мінімізує кількість комітів в історії першого батьківського елемента _<commit-ish>_, а не в історії першого батьківського елемента посилання.
+
Наприклад, розглянемо наступний малюнок історій перших батьків для кількох посилань:
+
----
*--*--*--*--*--* refs/heads/A
\
 \
  *--*--*--* refs/heads/B
   \     \
    \     \
     *     * refs/heads/C
      \
       \
	*--* refs/heads/D
----
+
Тут, якщо `A`, `B` та `C` – це відфільтровані посилання, а рядок формату – `%(refname):%(is-base:D)`, то результат буде таким
+
----
refs/heads/A:
refs/heads/B:(D)
refs/heads/C:
----
+
Це пояснюється тим, що історія першого батьківського елемента `D` має свій найдавніший перетин з історіями першого батьківського елемента відфільтрованих посилань у спільного першого батьківського елемента-предка `B` та `C`, а зв'язки розриваються найдавнішим посиланням у відсортованому порядку.
+
Зверніть увагу, що цей токен не з'явиться, якщо історія першого батьківського елемента _<commit-ish>_ не перетинається з історіями першого батьківського елемента відфільтрованих посилань.

`describe[:<option>,...]`::
	Зрозуміле для людини ім'я, наприклад linkgit:git-describe[1]; порожній рядок для неописуваних комітів. Після рядка `describe` може бути двокрапка та один або кілька параметрів, розділених комами.
+
--
`tags=<bool-value>`;;
	Замість того, щоб розглядати лише анотовані теги, розгляньте також легкі теги; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
`abbrev=<number>`;;
	Використовуйте щонайменше _<кількість>_ шістнадцяткових цифр; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
`match=<pattern>`;;
	Розглядати лише теги, що відповідають префіксу `glob`(7) _<шаблон>_, за винятком префікса `refs/tags/`; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
`exclude=<pattern>`;;
	Не враховуйте теги, що відповідають префіксу `glob`(7) _<шаблон>_, за винятком префікса `refs/tags/`; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
--

Окрім вищезазначеного, для об'єктів commit та tag, назви полів заголовка (`tree`, `parent`, `object`, `type` та `tag`) можуть використовуватися для визначення значення в полі заголовка. Поля `tree` та `parent` також можуть використовуватися з модифікаторами `:short` та `:short=<length>`, як і `objectname`.

Для об'єктів commit та tag спеціальні поля `creatordate` та `creator` відповідатимуть відповідній даті або кортежу name-email-date з полів `committer` або `tagger` залежно від типу об'єкта. Вони призначені для роботи з поєднанням анотованих та легких тегів.

Для об'єктів тегів значення `fieldname` з префіксом у вигляді зірочки (`*`) розширюється до значення `fieldname` очищеного об'єкта, а не до значення самого об'єкта тегу.

Поля, значенням яких є кортеж name-email-date (`author`, `committer` та `tagger`), можна доповнити суфіксами `name`, `email` та `date` для вилучення іменованого компонента. Для полів електронної пошти (`authoremail`, `committeremail` та `taggeremail`) можна додати `:trim`, щоб отримати електронну пошту без кутових дужок, та `:localpart`, щоб отримати частину перед символом `@` з обрізаної електронної пошти. На додаток до цього, можна використовувати опцію `:mailmap` та відповідні `:mailmap,trim` та `:mailmap,localpart` (порядок не має значення), щоб отримати значення імені та електронної пошти відповідно до файлу .mailmap або відповідно до файлу, встановленого у змінній конфігурації mailmap.file або mailmap.blob (див. linkgit:gitmailmap[5]).

Необроблені дані в об'єкті є «сирими» (raw).

`raw:size`::
	Розмір необроблених даних об'єкта.

Зверніть увагу, що `--format=%(raw)` не можна використовувати з `--python`, `--shell`, `--tcl`, оскільки такі мови можуть не підтримувати довільні двійкові дані у своєму типі змінних рядків.

Повідомлення в коміті або об'єкті тегу — це `contents`, з якого `contents:<part>` можна використовувати для вилучення різних частин:

`contents:size`::
	Розмір повідомлення коміта або тегу в байтах.

`contents:subject`::
	Перший абзац повідомлення, який зазвичай складається з одного рядка, береться як «тема» коміта або повідомлення тегу. Замість `contents:subject`, для отримання тих самих результатів можна використовувати поле `subject`. `:sanitize` можна додати до `subject` для теми, що підходить для імені файлу.

`contents:body`::
	Решта коміту або повідомлення тегу, що йде після "subject".

`contents:signature`::
	Додатковий GPG-підпис тегу.

`contents:lines=<n>`::
	Перші _<n>_ рядки повідомлення.

Крім того, трейлери, інтерпретовані linkgit:git-interpret-trailers[1], отримуються як `trailers[:<опція>,...]` (або за допомогою історичного псевдоніма `contents:trailers[:<опція>,...]`). Для коректних значень _<опція>_ див. розділ `trailers` у linkgit:git-log[1].

Для цілей сортування поля з числовими значеннями сортуються в числовому порядку (`objectsize`, `authordate`, `committerdate`, `creatordate`, `taggerdate`). Усі інші поля використовуються для сортування в порядку їх байт-значення.

Також є опція сортування за версіями, це можна зробити за допомогою назви поля `version:refname` або його псевдоніма `v:refname`.

У будь-якому випадку, ім'я поля, яке посилається на поле, непридатне для об'єкта, на який посилається посилання, не викликає помилки. Натомість повертається порожній рядок.

Як окремий випадок для полів типу дати, ви можете вказати формат дати, додавши `:`, а потім назву формату дати (див. значення, які приймає опція `--date` для linkgit:git-rev-list[1]). Якщо це форматування надається в ключі `--sort`, посилання будуть відсортовані відповідно до байтового значення форматованого рядка, а не числового значення базової позначки часу.

Деякі атоми, такі як `%(align)` та `%(if)`, завжди потребують відповідного `%(end)`. Ми називаємо їх "відкриваючими атомами" та іноді позначаємо як `%($open)`.

Коли діє специфічне для скриптової мови цитування, все між початковим атомом верхнього рівня та відповідним йому %(end) оцінюється відповідно до семантики початкового атома, і в лапки береться лише його результат з верхнього рівня.


ПРИКЛАДИ
--------

Приклад безпосереднього створення форматованого тексту. Показати 3 останні позначені тегами коміти:

------------
#!/bin/sh

git for-each-ref --count=3 --sort='-*authordate' \
`--format='From: %(*authorname) %(*authoremail)
Subject: %(*subject)
Date: %(*authordate)
Ref: %(*refname)

%(*body)
' 'refs/tags'
------------


Простий приклад використання команди shell eval на виводі, демонструючи використання `--shell`. Перелічіть префікси всіх заголовків:

------------
#!/bin/sh

git for-each-ref --shell --format="ref=%(refname)" refs/heads | \
while read entry
do
	eval "$entry"
	echo `dirname $ref`
done
------------


Трохи детальніший звіт про теги, який демонструє, що формат може бути цілим скриптом:

------------
#!/bin/sh

fmt='
	r=%(refname)
	t=%(*objecttype)
	T=${r#refs/tags/}

	o=%(*objectname)
	n=%(*authorname)
	e=%(*authoremail)
	s=%(*subject)
	d=%(*authordate)
	b=%(*body)

	kind=Tag
	if test "z$t" = z
	then
		# could be a lightweight tag
		t=%(objecttype)
		kind="Lightweight tag"
		o=%(objectname)
		n=%(authorname)
		e=%(authoremail)
		s=%(subject)
		d=%(authordate)
		b=%(body)
	fi
	echo "$kind $T points at a $t object $o"
	if test "z$t" = zcommit
	then
		echo "The commit was authored by $n $e
at $d, and titled

    $s

Its message reads as:
"
		echo "$b" | sed -e "s/^/    /"
		echo
	fi
'

eval=`git for-each-ref --shell --format="$fmt" \
	--sort='*objecttype' \
	--sort=-taggerdate \
	refs/tags`
eval "$eval"
------------


Приклад використання `%(if)...%(then)...%(else)...%(end)`. Це позначає поточну гілку зірочкою.

------------
git for-each-ref --format="%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)" refs/heads/
------------


Приклад використання `%(if)...%(then)...%(end)`. Виводить ім'я автора, якщо воно є.

------------
git for-each-ref --format="%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)"
------------

ЗАСТЕРЕЖЕННЯ
------------

Зверніть увагу, що розміри об'єктів на диску повідомляються точно, але слід бути обережним, роблячи висновки про те, які посилання або об'єкти відповідають за використання диска. Розмір упакованого недельта-об'єкта може бути набагато більшим за розмір об'єктів, які дельта-об'єкти відносно нього, але вибір того, який об'єкт є базовим, а який дельта-об'єктом, є довільним і може змінюватися під час перепаковки.

Також зауважте, що в базі даних об'єктів може бути кілька копій об'єкта; у цьому випадку не визначено, розмір або дельта-база якої копії буде відображатися.

НОТАТКИ
-------

include::ref-reachability-filters.adoc[]

ДИВ. ТАКОЖ
----------
linkgit:git-show-ref[1]

GIT
---
Частина набору linkgit:git[1]
