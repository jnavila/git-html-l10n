git-for-each-ref(1)
===================

НАЗВА
-----
git-for-each-ref - Вивести інформацію про кожне посилання

СИНОПСИС
--------
[synopsis]
git for-each-ref [--count=<count>] [--shell|--perl|--python|--tcl]
		   [(--sort=<key>)...] [--format=<format>]
		   [--include-root-refs] [--points-at=<object>]
		   [--merged[=<object>]] [--no-merged[=<object>]]
		   [--contains[=<object>]] [--no-contains[=<object>]]
		   [(--exclude=<pattern>)...] [--start-after=<marker>]
		   [ --stdin | <pattern>... ]

ОПИС
----

Перебрати всі посилання, що відповідають `<шаблон>`, та показати їх відповідно до заданого `<формат>`, попередньо відсортувавши їх відповідно до заданого набору `<ключ>`. Якщо задано `<кількість>`, зупинити після показу такої кількості посилань. Інтерпольовані значення в `<формат>` можна за бажанням взяти у лапки як рядкові літерали вказаною мовою хоста, що дозволяє їх безпосередню оцінку цією мовою.

ОПЦІЇ
-----
<pattern>...::
	Якщо задано один або декілька шаблонів, відображаються лише посилання, які відповідають принаймні одному шаблону, або за допомогою fnmatch(3), або буквально, в останньому випадку — повне збігання або збіг від початку до косої риски.

--stdin::
	Якщо вказано параметр `--stdin`, то список шаблонів зчитується зі стандартного вводу, а не зі списку аргументів.

--count=<count>::
	За замовчуванням команда показує всі посилання, що відповідають `<шаблон>`. Цей параметр зупиняє її після показу певної кількості посилань.

--sort=<key>::
	Ім'я поля для сортування. Префікс `-` для сортування у порядку спадання значення. Якщо не вказано, використовується `refname`. Ви можете використовувати параметр --sort=<ключ> кілька разів, і в цьому випадку останній ключ стає первинним ключем.

--format=<format>::
	Рядок, який інтерполює `%(ім'я поля)` з посилання, що відображається, та об'єкта, на який воно вказує. Крім того, рядковий літерал `%%` відображатиметься як `%`, а `%xx`, де `xx` – шістнадцяткові цифри, відображатиметься як символ із шістнадцятковим кодом `xx`. Наприклад, `%00` інтерполює до `\0` (NUL), `%09` до `\t` (TAB), а `%0a` до `\n` (LF).
+
Якщо не вказано, `<format>` за замовчуванням має значення `%(name of object) SPC %(objecttype) TAB %(refname)`.

--color[=<when>]::
	Враховуйте будь-які кольори, зазначені в опції `--format`. Поле `<when>` має бути одним із значень `always`, `never` або `auto` (якщо `<when>` відсутнє, поводьтеся так, ніби було вказано `always`).

--shell::
--perl::
--python::
--tcl::
	Якщо задано, рядки, що замінюють заповнювачі `%(fieldname)`, цитуються як рядкові літерали, що підходять для вказаної мови хоста. Це призначено для створення скриптлета, який можна безпосередньо `eval`.

--points-at=<object>::
	Перераховувати лише посилання, які вказують на заданий об'єкт.

--merged[=<object>]::
	Перераховувати лише ті посилання, підказки яких доступні з вказаного коміту (HEAD, якщо не вказано).

--no-merged[=<object>]::
	Перераховувати лише посилання, поради яких недоступні з вказаного коміту (HEAD, якщо не вказано).

--contains[=<object>]::
	Перераховувати лише посилання, які містять вказаний коміт (HEAD, якщо не вказано).

--no-contains[=<object>]::
	Перераховувати лише посилання, які не містять зазначеного коміту (HEAD, якщо не вказано).

--ignore-case::
	Сортування та фільтрація посилань не враховують регістр.

--omit-empty::
	Не друкуйте новий рядок після відформатованих посилань, де формат розгортається до порожнього рядка.

--exclude=<pattern>::
	Якщо задано один або декілька шаблонів, відображаються лише ті посилання, які не відповідають жодному виключеному шаблону(ам). Зіставлення виконується за тими ж правилами, що й для `<шаблон>` вище.

--include-root-refs::
	Перелічіть кореневі посилання (HEAD та псевдопосилання) окремо від звичайних посилань.

--start-after=<marker>::
    Дозволяє розбивати вивід на сторінки, пропускаючи посилання до зазначеного маркера включно. Під час розбиття на сторінки слід зазначити, що посилання можна видаляти, змінювати або додавати між викликами. Вивід поверне лише ті посилання, які лексикографічно слідують за маркером. Вивід починається з першого посилання, яке йде після маркера в алфавітному порядку. Не можна використовувати з опціями `--sort=<ключ>` або `--stdin`, або з аргументом(ами) _<шаблон>_ для обмеження посилань.

НАЗВИ ПОЛІВ
-----------

Різні значення зі структурованих полів у об'єктах, на які посилаються, можна використовувати для інтерполяції в результуючий вивід або як ключі сортування.

Для всіх об'єктів можна використовувати такі назви:

посилання::
	Назва посилання (частина після $GIT_DIR/). Для неоднозначної короткої назви посилання додається `:short`. Опція core.warnAmbiguousRefs використовується для вибору режиму суворого скорочення. Якщо додається `lstrip=<N>` (`rstrip=<N>`), то компоненти шляху, розділені `<N>`, видаляються з початку (конця) назви посилання (наприклад, `%(refname:lstrip=2)` перетворює `refs/tags/foo` на `foo`, а `%(refname:rstrip=2)` перетворює `refs/tags/foo` на `refs`). Якщо `<N>` – від’ємне число, видаляється стільки компонентів шляху, скільки потрібно, з зазначеного кінця, щоб залишилося `-<N>` компонентів шляху (наприклад, `%(refname:lstrip=-2)` перетворює `refs/tags/foo` на `tags/foo`, а `%(refname:rstrip=-1)` перетворює `refs/tags/foo` на `refs`). Коли посилання не має достатньо компонентів, результат стає порожнім рядком, якщо видаляється з додатним <N>, або він стає повним посиланням, якщо видаляється з від’ємним <N>. Жодне з них не є помилкою.
+
`strip` можна використовувати як синонім `lstrip`.

тип об'єкта::
	Тип об'єкта (`blob`, `tree`, `commit`, `tag`).

розмір об'єкта::
	Розмір об'єкта (те саме, що й у звітах 'git cat-file -s'). Додайте `:disk`, щоб отримати розмір у байтах, який об'єкт займає на диску. Дивіться примітку щодо розмірів на диску в розділі `ЗАСТЕРЕЖЕННЯ` нижче.
назва об'єкта::
	Ім'я об'єкта (також відоме як SHA-1). Для неоднозначного скорочення назви об'єкта додайте `:short`. Для скорочення назви об'єкта з бажаною довжиною додайте `:short=<довжина>`, де мінімальна довжина дорівнює MINIMUM_ABBREV. Довжину можна перевищити, щоб забезпечити унікальність назв об'єктів.
дельтабаза::
	Це розширюється до назви об'єкта дельта-бази для заданого об'єкта, якщо вона збережена як дельта. В іншому випадку, воно розширюється до нульової назви об'єкта (всі нулі).

вище за течією::
	Назва локального посилання, яке можна вважати «вище за течією» відносно відображеного посилання. Враховує `:short`, `:lstrip` та `:rstrip` так само, як і `refname` вище. Додатково враховує `:track` для відображення "[ahead N, behind M]" та `:trackshort` для відображення скороченої версії: ">" (ahead), "<" (behind), "<>" (ahead та behind) або "=" (синхронізовано). `:track` також друкує "[gone]" щоразу, коли зустрічається невідоме посилання вище за течією. Додайте `:track,nobracket` для відображення інформації про відстеження без дужок (тобто "ahead N, behind M").
+
Для будь-якої гілки віддаленого відстеження `%(upstream)`, `%(upstream:remotename)` та `%(upstream:remoteref)` посилаються на назву віддаленого об'єкта та назву відстежуваного віддаленого посилання відповідно. Іншими словами, гілку віддаленого відстеження можна оновлювати явно та окремо за допомогою специфікації посилань `%(upstream:remoteref):%(upstream)` для вибору з `%(upstream:remotename)`.
+
Не має ефекту, якщо посилання не має пов'язаної з ним інформації про відстеження. Усі опції, окрім `nobracket`, є взаємовиключними, але якщо вони використовуються разом, вибирається остання опція.

push::
	Ім'я локального посилання, яке представляє розташування `@{push}` для відображеного посилання. Враховує опції `:short`, `:lstrip`, `:rstrip`, `:track`, `:trackshort`, `:remotename` та `:remoteref`, як і `upstream`. Створює порожній рядок, якщо посилання `@{push}` не налаштовано.

HEAD::
	'*', якщо HEAD збігається з поточним посиланням (витягнутою гілкою), ' ' інакше.

color::
	Змінити колір виводу. Далі йде `:<назва кольору>`, де назви кольорів описані в розділі "Значення" в розділі "ФАЙЛ КОНФІГУРАЦІЇ" файлу linkgit:git-config[1]. Наприклад, `%(color:bold red)`.

вирівняти::
	Вирівнювання вмісту між %(align:...) та %(end) по лівому, середньому або правому краю. Після "align:" йдуть `width=<width>` та `position=<position>` у будь-якому порядку, розділені комою, де `<position>` позначає ліворуч, праворуч або посередині, за замовчуванням ліворуч, а `<width>` — це загальна довжина вмісту з вирівнюванням. Для стислості префікси "width=" та/або "position=" можна пропустити, а замість них використовувати лише <width> та <position>. Наприклад, `%(align:<width>,<position>)`. Якщо довжина вмісту більша за ширину, вирівнювання не виконується. Якщо використовується з `--quote`, все між %(align:...) та %(end) береться в лапки, але якщо вкладено, то лапки виконується лише на найвищому рівні.

якщо::
	Використовується як %(if)...%(then)...%(end) або %(if)...%(then)...%(else)...%(end). Якщо після %(if) є атом зі значенням або рядковим літералом, то друкується все після %(then), інакше, якщо використовується атом %(else), то друкується все після %(else). Ми ігноруємо пробіли під час обчислення рядка перед %(then), це корисно, коли ми використовуємо атом %(HEAD), який друкує "*" або " ", і ми хочемо застосувати умову 'if' лише до посилання 'HEAD'. Додайте ":equals=<рядок>" або ":notequals=<рядок>", щоб порівняти значення між атомами %(if:...) та %(then) з заданим рядком.

symref::
	Посилання, на яке посилається задане символічне посилання. Якщо посилання не є символічним, нічого не друкується. Враховує опції `:short`, `:lstrip` та `:rstrip` так само, як і `refname` вище.

signature::
	GPG-підпис коміту.

signature:grade::
	Показати «G» для справного (дійсного) підпису, «B» для поганого підпису, «U» для справного підпису з невідомою дійсністю, «X» для справного підпису, термін дії якого минув, «Y» для справного підпису, створеного простроченим ключем, «R» для справного підпису, створеного відкликаним ключем, «E», якщо підпис неможливо перевірити (наприклад, відсутній ключ), та «N» для відсутності підпису.

signature:signer::
	Підписувач GPG-підпису коміту.

signature:key::
	Ключ GPG-підпису коміту.

signature:fingerprint::
	Відбиток GPG-підпису коміта.

signature:primarykeyfingerprint::
	Відбиток первинного ключа GPG-підпису коміта.

signature:trustlevel::
	Рівень довіри GPG-сигнатури коміта. Можливі виходи: `ultimate`, `fully`, `marginal`, `never` та `undefined`.

робочий шлях::
	Абсолютний шлях до робочого дерева, в якому витягнуто посилання, якщо воно витягнуто в будь-якому зв'язаному робочому дереві. В іншому випадку порожній рядок.

ahead-behind:<комітетський>::
	Два цілі числа, розділені пробілом, що показують кількість комітів попереду та позаду відповідно, при порівнянні вихідного посилання з `<committish>`, зазначеним у форматі.

is-base:<комітетський>::
	Щонайбільше в одному рядку з'явиться `(<committish>)`, щоб вказати посилання, яке, найімовірніше, є тим посиланням, що використовувалося як відправна точка для гілки, що створила `<committish>`. Цей вибір робиться за допомогою евристики: вибирається посилання, яке мінімізує кількість комітів в історії першого батьківського елемента `<committish>`, а не в історії першого батьківського елемента посилання.
+
Наприклад, розглянемо наступний малюнок історій перших батьків для кількох посилань:
+
----
*--*--*--*--*--* refs/heads/A
\
 \
  *--*--*--* refs/heads/B
   \     \
    \     \
     *     * refs/heads/C
      \
       \
	*--* refs/heads/D
----
+
Тут, якщо `A`, `B` та `C` – це відфільтровані посилання, а рядок формату – `%(refname):%(is-base:D)`, то результат буде таким
+
----
refs/heads/A:
refs/heads/B:(D)
refs/heads/C:
----
+
Це пояснюється тим, що історія першого батьківського елемента `D` має свій найдавніший перетин з історіями першого батьківського елемента відфільтрованих посилань у спільного першого батьківського елемента-предка `B` та `C`, а зв'язки розриваються найдавнішим посиланням у відсортованому порядку.
+
Зверніть увагу, що цей токен не з'явиться, якщо історія першого батьківського елемента `<committish>` не перетинається з історіями першого батьківського елемента відфільтрованих посилань.

describe[:опція]::
	Зрозуміле для людини ім'я, наприклад linkgit:git-describe[1]; порожній рядок для неописуваних комітів. Після рядка `describe` може бути двокрапка та один або кілька параметрів, розділених комами.
+
--
tags=<bool-value>;;
	Замість того, щоб розглядати лише анотовані теги, розгляньте також легкі теги; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
abbrev=<number>;;
	Використовуйте щонайменше <кількість> шістнадцяткових цифр; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
match=<pattern>;;
	Розглядати лише теги, що відповідають заданому шаблону `glob(7)`, виключаючи префікс "refs/tags/"; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
exclude=<pattern>;;
	Не враховувати теги, що відповідають заданому шаблону `glob(7)`, за винятком префікса "refs/tags/"; див. відповідний параметр у linkgit:git-describe[1] для отримання детальної інформації.
--

Окрім вищезазначеного, для об'єктів commit та tag, назви полів заголовка (`tree`, `parent`, `object`, `type` та `tag`) можуть використовуватися для визначення значення в полі заголовка. Поля `tree` та `parent` також можуть використовуватися з модифікаторами `:short` та `:short=<length>`, як і `objectname`.

Для об'єктів commit та tag спеціальні поля `creatordate` та `creator` відповідатимуть відповідній даті або кортежу name-email-date з полів `committer` або `tagger` залежно від типу об'єкта. Вони призначені для роботи з поєднанням анотованих та легких тегів.

Для об'єктів тегів значення `fieldname` з префіксом у вигляді зірочки (`*`) розширюється до значення `fieldname` очищеного об'єкта, а не до значення самого об'єкта тегу.

Поля, значенням яких є кортеж name-email-date (`author`, `committer` та `tagger`), можна доповнити суфіксами `name`, `email` та `date` для вилучення іменованого компонента. Для полів електронної пошти (`authoremail`, `committeremail` та `taggeremail`) можна додати `:trim`, щоб отримати електронну пошту без кутових дужок, та `:localpart`, щоб отримати частину перед символом `@` з обрізаної електронної пошти. На додаток до цього, можна використовувати опцію `:mailmap` та відповідні `:mailmap,trim` та `:mailmap,localpart` (порядок не має значення), щоб отримати значення імені та електронної пошти відповідно до файлу .mailmap або відповідно до файлу, встановленого у змінній конфігурації mailmap.file або mailmap.blob (див. linkgit:gitmailmap[5]).

Необроблені дані в об'єкті є «сирими» (raw).

raw:size::
	Розмір необроблених даних об'єкта.

Зверніть увагу, що `--format=%(raw)` не можна використовувати з `--python`, `--shell`, `--tcl`, оскільки такі мови можуть не підтримувати довільні двійкові дані у своєму типі змінних рядків.

Повідомлення в коміті або об'єкті тегу — це `contents`, з якого `contents:<part>` можна використовувати для вилучення різних частин:

contents:size::
	Розмір повідомлення коміта або тегу в байтах.

contents:subject::
	Перший абзац повідомлення, який зазвичай складається з одного рядка, береться як «тема» коміта або повідомлення тегу. Замість `contents:subject`, для отримання тих самих результатів можна використовувати поле `subject`. `:sanitize` можна додати до `subject` для теми, що підходить для імені файлу.

contents:body::
	Решта коміту або повідомлення тегу, що йде після "subject".

contents:signature::
	Додатковий GPG-підпис тегу.

contents:lines=N::
	Перші `N` рядків повідомлення.

Крім того, трейлери, інтерпретовані linkgit:git-interpret-trailers[1], отримуються як `trailers[:options]` (або за допомогою історичного псевдоніма `contents:trailers[:options]`). Для коректних значень [:option] див. розділ `trailers` у linkgit:git-log[1].

Для цілей сортування поля з числовими значеннями сортуються в числовому порядку (`objectsize`, `authordate`, `committerdate`, `creatordate`, `taggerdate`). Усі інші поля використовуються для сортування в порядку їх байт-значення.

Також є опція сортування за версіями, це можна зробити за допомогою назви поля `version:refname` або його псевдоніма `v:refname`.

У будь-якому випадку, ім'я поля, яке посилається на поле, непридатне для об'єкта, на який посилається посилання, не викликає помилки. Натомість повертається порожній рядок.

Як окремий випадок для полів типу дати, ви можете вказати формат дати, додавши `:`, а потім назву формату дати (див. значення, які приймає опція `--date` для linkgit:git-rev-list[1]). Якщо це форматування надається в ключі `--sort`, посилання будуть відсортовані відповідно до байтового значення форматованого рядка, а не числового значення базової позначки часу.

Деякі атоми, такі як %(align) та %(if), завжди потребують відповідного %(end). Ми називаємо їх «відкриваючими атомами» та іноді позначаємо їх як %($open).

Коли діє специфічне для скриптової мови цитування, все між початковим атомом верхнього рівня та відповідним йому %(end) оцінюється відповідно до семантики початкового атома, і в лапки береться лише його результат з верхнього рівня.


ПРИКЛАДИ
--------

Приклад безпосереднього створення форматованого тексту. Показати 3 останні позначені тегами коміти:

------------
#!/bin/sh

git for-each-ref --count=3 --sort='-*authordate' \
--format='From: %(*authorname) %(*authoremail)
Subject: %(*subject)
Date: %(*authordate)
Ref: %(*refname)

%(*body)
' 'refs/tags'
------------


Простий приклад використання команди shell eval на виводі, демонструючи використання --shell. Перелічіть префікси всіх заголовків:

------------
#!/bin/sh

git for-each-ref --shell --format="ref=%(refname)" refs/heads | \
while read entry
do
	eval "$entry"
	echo `dirname $ref`
done
------------


Трохи детальніший звіт про теги, який демонструє, що формат може бути цілим скриптом:

------------
#!/bin/sh

fmt='
	r=%(refname)
	t=%(*objecttype)
	T=${r#refs/tags/}

	o=%(*objectname)
	n=%(*authorname)
	e=%(*authoremail)
	s=%(*subject)
	d=%(*authordate)
	b=%(*body)

	kind=Tag
	if test "z$t" = z
	then
		# could be a lightweight tag
		t=%(objecttype)
		kind="Lightweight tag"
		o=%(objectname)
		n=%(authorname)
		e=%(authoremail)
		s=%(subject)
		d=%(authordate)
		b=%(body)
	fi
	echo "$kind $T points at a $t object $o"
	if test "z$t" = zcommit
	then
		echo "The commit was authored by $n $e
at $d, and titled

    $s

Its message reads as:
"
		echo "$b" | sed -e "s/^/    /"
		echo
	fi
'

eval=`git for-each-ref --shell --format="$fmt" \
	--sort='*objecttype' \
	--sort=-taggerdate \
	refs/tags`
eval "$eval"
------------


Приклад використання %(if)...%(then)...%(else)...%(end). Це позначає поточну гілку зірочкою.

------------
git for-each-ref --format="%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)" refs/heads/
------------


Приклад використання %(if)...%(then)...%(end). Виводить ім'я автора, якщо воно є.

------------
git for-each-ref --format="%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)"
------------

ЗАСТЕРЕЖЕННЯ
------------

Зверніть увагу, що розміри об'єктів на диску повідомляються точно, але слід бути обережним, роблячи висновки про те, які посилання або об'єкти відповідають за використання диска. Розмір упакованого недельта-об'єкта може бути набагато більшим за розмір об'єктів, які дельта-об'єкти відносно нього, але вибір того, який об'єкт є базовим, а який дельта-об'єктом, є довільним і може змінюватися під час перепаковки.

Також зауважте, що в базі даних об'єктів може бути кілька копій об'єкта; у цьому випадку не визначено, розмір або дельта-база якої копії буде відображатися.

НОТАТКИ
-------

include::ref-reachability-filters.adoc[]

ДИВ. ТАКОЖ
----------
linkgit:git-show-ref[1]

GIT
---
Частина набору linkgit:git[1]
