`--all`::
`--no-all`::
	Отримати всі віддалені пристрої, крім тих, для яких встановлено змінну конфігурації `remote.<назва>.skipFetchAll`. Це замінює змінну конфігурації `fetch.all`.

`-a`::
`--append`::
	Додати назви посилань та назви об'єктів отриманих посилань до існуючого вмісту `.git/FETCH_HEAD`. Без цієї опції старі дані в `.git/FETCH_HEAD` будуть перезаписані.

`--atomic`::
	Використовуйте атомарну транзакцію для оновлення локальних посилань. Або всі посилання оновлюються, або у разі помилки жодні посилання не оновлюються.

`--depth=<depth>`::
	Обмежити вибірку до вказаної кількості комітів з кінчика історії кожної віддаленої гілки. Якщо вибірка здійснюється до «неглибокого» репозиторію, створеного за допомогою `git clone` з опцією `--depth=<глибина>` (див. linkgit:git-clone[1]), поглибити або скоротити історію до вказаної кількості комітів. Теги для поглиблених комітів не витягуються.

`--deepen=<depth>`::
	Подібно до `--depth`, але вказує кількість комітів з поточної неглибокої межі, а не з кінця історії кожної віддаленої гілки.

`--shallow-since=<дата>`::
	Поглибити або скоротити історію поверхневого репозиторію, щоб включити всі доступні коміти після _<дата>_.

`--shallow-exclude=<посилання>`::
	Поглибити або скоротити історію поверхневого репозиторію, щоб виключити коміти, доступні з вказаної віддаленої гілки або тегу. Цей параметр можна вказати кілька разів.

`--unshallow`::
	Якщо вихідний репозиторій завершений, конвертуйте поверхневий репозиторій у повноцінний, усунувши всі обмеження, що накладаються поверхневими репозиторіями.
+
Якщо вихідний репозиторій неглибокий, витягніть якомога більше даних, щоб поточний репозиторій мав таку ж історію, як і вихідний репозиторій.

`--update-shallow`::
	За замовчуванням, під час отримання даних з поверхневого репозиторію, `git fetch` відхиляє посилання, які потребують оновлення `.git/shallow`. Ця опція оновлює `.git/shallow` та приймає такі посилання.

`--negotiation-tip=(<commit>|<glob>)`::
	За замовчуванням Git повідомлятиме серверу про коміти, доступні з усіх локальних посилань, щоб знайти спільні коміти та спробувати зменшити розмір отриманого пакет-файлу. Якщо вказано, Git повідомлятиме лише про коміти, доступні з заданих посилань. Це корисно для пришвидшення завантаження, коли користувач знає, яке локальне посилання, ймовірно, має спільні коміти з посиланням, що вибирається.
+
Цей параметр можна вказати більше одного разу; якщо так, Git повідомить про коміти, доступні з будь-якого з заданих комітів.
+
Аргументом цієї опції може бути глобус на іменах посилань, посилання або (можливо, скорочено) SHA-1 коміта. Вказівка глобуса еквівалентна багаторазовому вказуванню цієї опції, по одному для кожного відповідного імені посилання.
+
Дивіться також змінні конфігурації `fetch.negotiationAlgorithm` та `push.negotiate`, задокументовані в linkgit:git-config[1], та опцію `--negotiate-only` нижче.

`--negotiate-only`::
	Не отримувати нічого з сервера, а натомість виводити предків наданих аргументів `--negotiation-tip=`, які є спільними з сервером.
+
Це несумісно з `--recurse-submodules=(yes|on-demand)`. Внутрішньо це використовується для реалізації опції `push.negotiate`, див. linkgit:git-config[1].

`--dry-run`::
	Покажіть, що буде зроблено без внесення жодних змін.

`--porcelain`::
	Вивести вивід на стандартний вивід у зручному для розбору форматі для скриптів. Див. розділ ВИВІД у linkgit:git-fetch[1] для отримання детальної інформації.
+
Це несумісно з `--recurse-submodules=(yes|on-demand)` та має пріоритет над параметром конфігурації `fetch.output`.

ifndef::git-pull[]
`--write-fetch-head`::
`--no-write-fetch-head`::
	Записати список віддалених посилань, отриманих у файлі `FETCH_HEAD`, безпосередньо в `$GIT_DIR`. Це значення за замовчуванням. Передача `--no-write-fetch-head` з командного рядка вказує Git не записувати файл. З опцією `--dry-run` файл ніколи не записується.
endif::git-pull[]

`-f`::
`--force`::
ifdef::git-pull[]
Коли `git fetch` використовується з `<src>:<dst>` refspec, він може відмовитися оновлювати локальну гілку, як обговорювалося в частині _<refspec>_ документації linkgit:git-fetch[1].
endif::git-pull[]
ifndef::git-pull[]
Коли `git fetch` використовується з `<src>:<dst>` refspec, він може відмовитися оновлювати локальну гілку, як обговорювалося в частині _<refspec>_ нижче.
endif::git-pull[]
Цей параметр замінює цю перевірку.

`-k`::
`--keep`::
	Збережіть завантажений пакет.

ifndef::git-pull[]
`--multiple`::
	Дозволяє вказувати кілька аргументів _<репозиторій>_ та _<група>_. Не можна вказувати __<посилання>__s.

`--auto-maintenance`::
`--no-auto-maintenance`::
`--auto-gc`::
`--no-auto-gc`::
	Виконайте `git maintenance run --auto` в кінці, щоб виконати автоматичне обслуговування репозиторію, якщо це необхідно. Це ввімкнено за замовчуванням.

`--write-commit-graph`::
`--no-write-commit-graph`::
	Записати граф комітів після отримання. Це замінює налаштування конфігурації `fetch.writeCommitGraph`.
endif::git-pull[]

`--prefetch`::
	Змініть налаштовану специфікацію посилань, щоб розмістити всі посилання в просторі імен `refs/prefetch/`. Див. завдання `prefetch` у linkgit:git-maintenance[1].

`-p`::
`--prune`::
	Перед отриманням видаліть усі посилання на віддалене відстеження, яких більше немає на віддаленому сервері. Теги не підлягають обрізанню, якщо вони отримані лише через автоматичне слідування за тегами за замовчуванням або через опцію `--tags`. Однак, якщо теги отримані через явну специфікацію посилань (або в командному рядку, або в конфігурації віддаленого сервера, наприклад, якщо віддалений сервер було клоновано з опцією `--mirror`), то вони також підлягають обрізанню. Надання `--prune-tags` – це скорочення для надання специфікації посилань на теги.
ifndef::git-pull[]
+
Дивіться розділ ОБРІЗКА нижче для отримання додаткової інформації.

`-P`::
`--prune-tags`::
	Перед отриманням даних видаліть усі локальні теги, яких більше немає на віддаленому сервері, якщо увімкнено `--prune`. Цю опцію слід використовувати обережніше, на відміну від `--prune`, вона видалить усі створені локальні посилання (локальні теги). Ця опція є скороченням для надання явного значення тегу refspec разом з `--prune`, див. обговорення цього в документації.
+
Дивіться розділ ОБРІЗКА нижче для отримання додаткової інформації.

endif::git-pull[]

ifndef::git-pull[]
`-n`::
endif::git-pull[]
`--no-tags`::
	За замовчуванням теги, що вказують на об'єкти, завантажені з віддаленого репозиторію, отримуються та зберігаються локально. Ця опція вимикає автоматичне відстеження тегів. Поведінку за замовчуванням для віддаленого репозиторію можна вказати за допомогою параметра remote.`<name>.tagOpt.` Див. linkgit:git-config[1].

ifndef::git-pull[]
`--refetch`::
	Замість узгодження із сервером, щоб уникнути перенесення комітів та пов'язаних об'єктів, які вже присутні локально, ця опція отримує всі об'єкти так, як це зробив би новий клон. Використовуйте це, щоб повторно застосувати фільтр часткового клонування з конфігурації або за допомогою `--filter=`, коли визначення фільтра змінилося. Автоматичне обслуговування після отримання виконає консолідацію пакетів бази даних об'єктів, щоб видалити будь-які дублікати об'єктів.
endif::git-pull[]

`--refmap=<refspec>`::
	Під час отримання посилань, перелічених у командному рядку, використовуйте вказану специфікацію посилань (можна вказати більше одного разу) для зіставлення посилань з гілками віддаленого відстеження, замість значень змінних конфігурації `remote.<name>.fetch` для віддаленого репозиторію. Надання порожньої _<refspec>_ для опції `--refmap` призведе до того, що Git ігноруватиме налаштовані специфікації посилань та повністю покладатиметься на специфікації посилань, надані як аргументи командного рядка. Див. розділ "Налаштовані гілки віддаленого відстеження" для отримання детальної інформації.

`-t`::
`--tags`::
	Отримати всі теги з віддаленого сервера (тобто отримати віддалені теги `refs/tags/*` у локальні теги з такою ж назвою), на додаток до всього іншого, що було б отримано в іншому випадку. Використання лише цієї опції не призводить до обрізання тегів, навіть якщо використовується `--prune` (хоча теги можуть бути обрізані в будь-якому випадку, якщо вони також є місцем призначення явної специфікації посилань; див. `--prune`).

ifndef::git-pull[]
`--recurse-submodules[=(yes|on-demand|no)]`::
	Контролюйте, чи слід також отримувати нові коміти підмодулів і за яких умов. Під час рекурсії через підмодулі, `git fetch` завжди намагається отримати "змінені" підмодулі, тобто підмодуль, який містить коміти, на які посилається щойно отриманий коміт суперпроекту, але відсутні в локальному клоні підмодуля. Змінений підмодуль можна отримати, якщо він присутній локально, наприклад, у `$GIT_DIR/modules/` (див. linkgit:gitsubmodules[7]); якщо основний твір додає новий підмодуль, цей підмодуль не можна отримати, доки він не буде клонований, наприклад, за допомогою `git submodule update`.
+
Якщо встановлено значення `on-demand`, отримуються лише змінені підмодулі. Якщо встановлено значення `yes`, отримуються всі заповнені підмодулі, а також ті, що є як незаповненими, так і зміненими. Якщо встановлено значення `no`, підмодулі ніколи не отримуються.
+
Якщо не вказано значення, використовується значення `fetch.recurseSubmodules`, якщо воно встановлено (див. linkgit:git-config[1]), за замовчуванням використовується значення `on-demand`, якщо не встановлено. Коли цей параметр використовується без значення, за замовчуванням використовується значення `yes`.
endif::git-pull[]

`-j <n>`::
`--jobs=<n>`::
	Паралелізуйте всі форми отримання до _<n>_ завдань одночасно.
+
Якщо було вказано опцію `--multiple`, різні віддалені модулі будуть завантажуватися паралельно. Якщо вибирається кілька підмодулів, вони будуть завантажуватися паралельно. Щоб керувати ними незалежно, використовуйте налаштування конфігурації `fetch.parallel` та `submodule.fetchJobs` (див. linkgit:git-config[1]).
+
Зазвичай паралельні рекурсивні та багатовіддалені вибірки будуть швидшими. За замовчуванням вибірки виконуються послідовно, а не паралельно.

ifndef::git-pull[]
`--no-recurse-submodules`::
	Вимкнути рекурсивне отримання підмодулів (це має той самий ефект, що й використання опції `--recurse-submodules=no`).
endif::git-pull[]

`--set-upstream`::
	Якщо віддалений доступ успішно отримано, додайте посилання на вихідний код (відстеження), яке використовується командою linkgit:git-pull[1] без аргументів та іншими командами. Для отримання додаткової інформації див. `branch.<name>.merge` та `branch.<name>.remote` у linkgit:git-config[1].

ifndef::git-pull[]
`--submodule-prefix=<path>`::
	Додати _<шлях>_ до шляхів, що виводяться в інформативних повідомленнях, таких як "Отримання підмодуля foo". Ця опція використовується внутрішньо під час рекурсії по підмодулях.

`--recurse-submodules-default=(yes|on-demand)`::
	Цей параметр використовується внутрішньо для тимчасового надання невід'ємного значення за замовчуванням для параметра `--recurse-submodules`. Усі інші методи налаштування рекурсії підмодулів fetch (такі як налаштування в linkgit:gitmodules[5] та linkgit:git-config[1]) перевизначають цей параметр, як і безпосереднє визначення `--[no-]recurse-submodules`.

`-u`::
`--update-head-ok`::
	За замовчуванням `git fetch` відмовляється оновлювати заголовок, який відповідає поточній гілці. Цей прапорець вимикає перевірку. Це виключно для внутрішнього використання `git pull` для взаємодії з `git fetch`, і якщо ви не реалізуєте власний Porcelain, вам не слід його використовувати.
endif::git-pull[]

`--upload-pack <upload-pack>`::
	Якщо параметр задано, і репозиторій для отримання даних обробляється `git fetch-pack`, то команді передається `--exec=<upload-pack>`, щоб вказати шлях, відмінний від шляху за замовчуванням, для виконання команди на іншому кінці.

ifndef::git-pull[]
`-q`::
`--quiet`::
	Передайте `--quiet` до `git-fetch-pack` та заглушіть будь-які інші внутрішньо використовувані команди git. Прогрес не повідомляється у стандартний потік помилок.

`-v`::
`--verbose`::
	Будьте багатослівними.
endif::git-pull[]

`--progress`::
	За замовчуванням статус виконання повідомляється у стандартному потоці помилок, коли він підключений до терміналу, якщо не вказано `-q`. Цей прапорець примусово повідомляє про статус виконання, навіть якщо стандартний потік помилок не спрямований до терміналу.

`-o <option>`::
`--server-option=<опція>`::
	Передати заданий рядок на сервер під час зв'язку за протоколом версії 2. Заданий рядок не повинен містити символів _NUL_ або _LF_. Обробка сервером параметрів сервера, включаючи невідомі, залежить від сервера. Якщо задано кілька параметрів `--server-option=<опція>`, усі вони надсилаються іншій стороні в порядку, зазначеному в командному рядку. Якщо параметр `--server-option=<опція>` не задано в командному рядку, замість нього використовуються значення змінної конфігурації `remote.<назва>.serverOption`.

`--show-forced-updates`::
	За замовчуванням git перевіряє, чи гілка примусово оновлюється під час fetch. Це можна вимкнути за допомогою `fetch.showForcedUpdates`, але опція `--show-forced-updates` гарантує, що ця перевірка відбудеться. Див. linkgit:git-config[1].

`--no-show-forced-updates`::
	За замовчуванням git перевіряє, чи гілка примусово оновлюється під час fetch. Передайте `--no-show-forced-updates` або встановіть `fetch.showForcedUpdates` на false, щоб пропустити цю перевірку з міркувань продуктивності. Якщо використовувати під час `git-pull`, опція `--ff-only` все одно перевірятиме наявність примусових оновлень перед спробою швидкого оновлення. Див. linkgit:git-config[1].

`-4`::
`--ipv4`::
	Використовуйте лише адреси IPv4, ігноруючи адреси IPv6.

`-6`::
`--ipv6`::
	Використовуйте лише адреси IPv6, ігноруючи адреси IPv4.
