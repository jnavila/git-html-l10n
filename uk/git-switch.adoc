git-switch(1)
=============

НАЗВА
-----
git-switch - Перемикання гілок

СИНОПСИС
--------
[synopsis]
git switch [<options>] [--no-guess] <branch>
git switch [<options>] --detach [<start-point>]
git switch [<options>] (-c|-C) <new-branch> [<start-point>]
git switch [<options>] --orphan <new-branch>

ОПИС
----
Перехід до вказаної гілки. Робоче дерево та індекс оновлюються відповідно до гілки. Усі нові коміти будуть додані на кінчик цієї гілки.

За бажанням, нову гілку можна створити за допомогою `-c`, `-C`, автоматично з віддаленої гілки з такою ж назвою (див. `--guess`), або від'єднати робоче дерево від будь-якої гілки за допомогою `--detach`, разом з перемиканням.

Перемикання гілок не вимагає чистого індексу та робочого дерева (тобто немає відмінностей порівняно з `HEAD`). Однак операція переривається, якщо призводить до втрати локальних змін, якщо не вказано інше за допомогою `--discard-changes` або `--merge`.

ОПЦІЇ
-----
_<branch>_::
	Гілка для переходу.

_<нова гілка>_::
	Назва для нової гілки.

_<start-point>_::
	Початкова точка для нової гілки. Вказівка _<початкової-точки>_ дозволяє створити гілку на основі деякої іншої точки в історії, ніж та, на яку зараз вказує `HEAD`. (Або, у випадку `--detach`, дозволяє перевірити та від'єднати від деякої іншої точки.)
+
Ви можете використовувати синтаксис `@{-<N>}` для позначення _<N>_-ї останньої гілки/коміту, на яку було переключено за допомогою операції `git switch` або `git checkout`. Ви також можете вказати `-`, що є синонімом `@{-1}`. Це часто використовується для швидкого перемикання між двома гілками або для скасування помилкового перемикання гілок.
+
Як окремий випадок, ви можете використовувати `<rev-a>...<rev-b>` як скорочення для бази злиття _<rev-a>_ та _<rev-b>_, якщо існує лише одна база злиття. Ви можете пропустити щонайбільше одну з _<rev-a>_ та _<rev-b>_, і в цьому випадку за замовчуванням використовується `HEAD`.

`-c <new-branch>`::
`--create <new-branch>`::
	Створіть нову гілку з назвою _<нова-гілка>_, починаючи з _<початкова-точка>_, перш ніж перемикатися на гілку. Це транзакційний еквівалент
+
------------
$ git branch <new-branch>
$ git switch <new-branch>
------------
+
тобто, гілка не скидається/не створюється, доки команда `git switch` не буде успішною (наприклад, коли гілка використовується в іншому робочому дереві, не лише поточна гілка залишається незмінною, але й гілка не скидається до початкової точки).

`-C <new-branch>`::
`--force-create <new-branch>`::
	Подібно до `--create`, за винятком того, що якщо _<нова-гілка>_ вже існує, її значення буде скинуто до _<початкова-точка>_. Це зручне скорочення для:
+
------------
$ git branch -f _<new-branch>_
$ git switch _<new-branch>_
------------

`-d`::
`--detach`::
	Переключіться на коміт для перевірки та експериментів, які можна відкинути. Дивіться розділ "ВІДРІЗНЕНА ГОЛОВА" в linkgit:git-checkout[1] для отримання детальної інформації.

`--guess`::
`--no-guess`::
	Якщо _<гілка>_ не знайдено, але існує гілка відстеження рівно в одному віддаленому середовищі (назвемо його _<віддаленим>_) з відповідним ім'ям, розглядати як еквівалент
+
------------
$ git switch -c <branch> --track <remote>/<branch>
------------
+
Якщо гілка існує на кількох віддалених серверах, і одна з них названа змінною конфігурації `checkout.defaultRemote`, ми використовуватимемо її для усунення неоднозначностей, навіть якщо _<branch>_ не є унікальною на всіх віддалених серверах. Встановіть її, наприклад, на `checkout.defaultRemote=origin`, щоб завжди отримувати віддалені гілки звідти, якщо _<branch>_ є неоднозначною, але існує на віддаленому сервері 'origin'. Див. також `checkout.defaultRemote` у linkgit:git-config[1].
+
`--guess` — це поведінка за замовчуванням. Використовуйте `--no-guess`, щоб вимкнути її.
+
Поведінку за замовчуванням можна встановити за допомогою змінної конфігурації `checkout.guess`.

`-f`::
`--force`::
	Псевдонім для `--discard-changes`.

`--discard-changes`::
	Продовжити, навіть якщо індекс або робоче дерево відрізняється від `HEAD`. Як індекс, так і робоче дерево відновлюються відповідно до цілі перемикання. Якщо вказано `--recurse-submodules`, вміст підмодуля також відновлюється відповідно до цілі перемикання. Це використовується для скасування локальних змін.

`-m`::
`--merge`::
	Якщо у вас є локальні зміни до одного або кількох файлів, які відрізняються між поточною гілкою та гілкою, до якої ви перемикаєтесь, команда відмовляється перемикати гілки, щоб зберегти ваші зміни в контексті. Однак, за допомогою цієї опції тристороннє злиття між поточною гілкою, вмістом вашого робочого дерева та новою гілкою виконується, і ви опинитеся на новій гілці.
+
Коли виникає конфлікт злиття, записи індексу для конфліктуючих шляхів залишаються необ'єднаними, і вам потрібно вирішити конфлікти та позначити вирішені шляхи за допомогою `git add` (або `git rm`, якщо злиття має призвести до видалення шляху).

`--conflict=<стиль>`::
	Те саме, що й опція `--merge` вище, але змінює спосіб представлення конфліктуючих фрагментів, перевизначаючи змінну конфігурації `merge.conflictStyle`. Можливі значення: `merge` (за замовчуванням), `diff3` та `zdiff3`.

`-q`::
`--quiet`::
	Тихі, придушені повідомлення зворотного зв'язку.

`--progress`::
`--no-progress`::
	Стан виконання за замовчуванням повідомляється у стандартному потоці помилок, коли він підключений до терміналу, якщо не вказано `--quiet`. Цей прапорець дозволяє повідомляти про хід виконання, навіть якщо він не підключений до терміналу, незалежно від `--quiet`.

`-t`::
`--track[ (direct|inherit)]`::
	Під час створення нової гілки налаштуйте конфігурацію "upstream". Мається на увазі `-c`. Див. `--track` у linkgit:git-branch[1] для отримання детальної інформації.
+
Якщо не вказано опцію `-c`, назва нової гілки буде отримана з гілки віддаленого відстеження, шляхом перегляду локальної частини специфікації посилань, налаштованої для відповідної віддаленої гілки, а потім видалення початкової частини до "*". Це підкаже нам використовувати `hack` як локальну гілку під час розгалуження від `origin/hack` (або `remotes/origin/hack`, або навіть `refs/remotes/origin/hack`). Якщо задана назва не має косої риски, або вищевказане вгадування призводить до порожньої назви, вгадування переривається. У такому випадку ви можете явно вказати назву за допомогою `-c`.

`--no-track`::
	Не налаштовуйте конфігурацію "upstream", навіть якщо змінна конфігурації `branch.autoSetupMerge` має значення true.

`--orphan <new-branch>`::
	Створіть нову ненароджену гілку з назвою _<нова-гілка>_. Усі відстежувані файли видаляються.

`--ignore-other-worktrees`::
	`git switch` відмовляє, коли потрібне посилання вже отримано іншим робочим деревом. Ця опція дозволяє йому все одно отримати посилання. Іншими словами, посилання може зберігатися більш ніж одним робочим деревом.

`--recurse-submodules`::
`--no-recurse-submodules`::
	Використання `--recurse-submodules` оновить вміст усіх активних підмодулів відповідно до коміту, записаного в суперпроекті. Якщо нічого не використовується (або `--no-recurse-submodules`), робочі дерева підмодулів не оновлюватимуться. Так само, як і linkgit:git-submodule[1], це від'єднає `HEAD` підмодулів.

ПРИКЛАДИ
--------

Наступна команда перемикає на гілку "master":

------------
$ git switch master
------------

Після роботи в неправильній гілці, перемикання на правильну гілку буде здійснюватися за допомогою:

------------
$ git switch mytopic
------------

Однак, ваша "неправильна" гілка та правильна гілка "mytopic" можуть відрізнятися у файлах, які ви змінили локально, і в такому разі вищезгаданий перемикач не спрацює ось так:

------------
$ git switch mytopic
error: You have local changes to 'frotz'; not switching branches.
------------

Ви можете надати команді прапорець `-m`, що спробує виконати тристороннє злиття:

------------
$ git switch -m mytopic
Auto-merging frotz
------------

Після цього тристороннього злиття локальні зміни _не_ реєструються у вашому індексному файлі, тому `git diff` покаже вам, які зміни ви внесли з моменту створення нової гілки.

Щоб повернутися до попередньої гілки перед тим, як ми переключилися на mytopic (тобто гілку "master"):

------------
$ git switch -
------------

Ви можете створити нову гілку з будь-якого коміту. Наприклад, перейдіть на "`HEAD~3`" та створіть гілку "`fixup`":

------------
$ git switch -c fixup HEAD~3
Switched to a new branch 'fixup'
------------

Якщо ви хочете розпочати нову гілку з віддаленої гілки з такою ж назвою:

------------
$ git switch new-topic
Branch `new-topic` set up to track remote branch `new-topic` from `origin`
Switched to a new branch `new-topic`
------------

Щоб тимчасово перевірити коміт `HEAD~3` або перевірити його без створення нової гілки:

------------
$ git switch --detach HEAD~3
HEAD is now at 9fc9555312 Merge branch 'cc/shared-index-permbits'
------------

Якщо виявиться, що будь-що з того, що ви зробили, варто зберегти, ви завжди можете створити для нього нову назву (не змінюючи її):

------------
$ git switch -c good-surprises
------------

КОНФІГУРАЦІЯ
------------

include::includes/cmd-config-section-all.adoc[]

include::config/checkout.adoc[]

ДИВ. ТАКОЖ
----------
linkgit:git-checkout[1], linkgit:git-branch[1]

GIT
---
Частина набору linkgit:git[1]
