git-status(1)
=============

НАЗВА
-----
git-status - Показати стан робочого дерева


СИНОПСИС
--------
[verse]
'git status' [<options>] [--] [<pathspec>...]

ОПИС
----
Відображає шляхи, що відрізняються між індексним файлом та поточним комітом HEAD, шляхи, що відрізняються між робочим деревом та індексним файлом, а також шляхи в робочому дереві, які не відстежуються Git (і не ігноруються linkgit:gitignore[5]). Перші - це те, що ви _б_ закомітили, виконавши `git commit`; другий і третій - це те, що ви _могли б_ закомітити, виконавши `git add' перед запуском `git commit`.

ОПЦІЇ
-----

-s::
--short::
	Надайте результат у скороченому форматі.

-b::
--branch::
	Відображати відділення та інформацію про відстеження навіть у скороченому форматі.

--show-stash::
	Показати кількість записів, що наразі зберігаються в сховищі.

--porcelain[=<version>]::
	Вивід надайте у форматі, зручному для розбору для скриптів. Це схоже на короткий вивід, але залишатиметься стабільним у різних версіях Git та незалежно від конфігурації користувача. Детальніше дивіться нижче.
+
Параметр version використовується для визначення версії формату. Це необов'язково, і за замовчуванням використовується формат оригінальної версії 'v1'.

--long::
	Виведіть результат у довгому форматі. Це значення за замовчуванням.

-v::
--verbose::
	Окрім назв файлів, які було змінено, також покажіть текстові зміни, які підготовлені для фіксації (тобто, як у виводі `git diff --cached`). Якщо `-v` вказано двічі, тоді також покажіть зміни в робочому дереві, які ще не були підготовлені (тобто, як у виводі `git diff`).

-u[<mode>]::
--untracked-files[=<mode>]::
	Показати невідстежувані файли.
+
--
Параметр mode використовується для визначення обробки невідстежуваних файлів. Він необов'язковий: за замовчуванням має значення «all», і якщо його вказано, він має бути пов'язаний з опцією (наприклад, `-uno`, але не `-u no`).

Можливі варіанти:

	- 'no' - Не показувати невідстежувані файли.
	- 'normal' - Показує невідстежувані файли та каталоги.
	- 'all' - Також показує окремі файли в невідстежуваних каталогах.

Коли опція `-u` не використовується, відображаються невідстежувані файли та каталоги (тобто те саме, що й при визначенні `normal`), щоб допомогти вам не забути додати щойно створені файли. Оскільки пошук невідстежуваних файлів у файловій системі потребує додаткової роботи, цей режим може зайняти деякий час у великому робочому дереві. Спробуйте ввімкнути невідстежуваний кеш та розділений індекс, якщо вони підтримуються (див. `git update-index --untracked-cache` та `git update-index --split-index`). В іншому випадку ви можете використовувати `no`, щоб `git status` повертав дані швидше, не показуючи невідстежувані файли. Усі звичайні варіанти написання логічного значення `true` сприймаються як `normal`, а `false` як `no`.

Значення за замовчуванням можна змінити за допомогою змінної конфігурації status.showUntrackedFiles, задокументованої в linkgit:git-config[1].
--

--ignore-submodules[=<when>]::
	Ігноруйте зміни в підмодулях під час пошуку змін. <when> може мати значення "none", "untracked", "dirty" або "all", що є значенням за замовчуванням. Використання "none" вважатиме підмодуль зміненим, якщо він містить невідстежувані або змінені файли, або його HEAD відрізняється від коміту, записаного в суперпроекті, і може бути використано для перевизначення будь-яких налаштувань опції 'ignore' у linkgit:git-config[1] або linkgit:gitmodules[5]. Коли використовується "untracked", підмодулі не вважаються брудними, якщо вони містять лише невідстежуваний контент (але вони все одно скануються на наявність зміненого контенту). Використання "dirty" ігнорує всі зміни в робочому дереві підмодулів, відображаються лише зміни в коммітах, що зберігаються в суперпроекті (така поведінка була до версії 1.7.0). Використання "all" приховує всі зміни в підмодулях (і пригнічує вивід зведень підмодулів, коли встановлено опцію конфігурації `status.submoduleSummary`).

--ignored[=<mode>]::
	Також показувати ігноровані файли.
+
--
Параметр mode використовується для визначення обробки ігнорованих файлів. Він необов'язковий: за замовчуванням використовується значення «traditional».

Можливі варіанти:

	- 'traditional' - Показує ігноровані файли та каталоги, окрім випадків
			  --untracked-files=all вказано, і в цьому випадку
			  відображаються
			  окремі файли в ігнорованих каталогах.
	- 'no'	        - Не показувати ігноровані файли.
	- 'matching'    - Показує ігноровані файли та каталоги, що відповідають
			  ігнорувати шаблон.

Коли вказано режим «зіставлення», відображаються шляхи, які явно відповідають ігнорованому шаблону. Якщо каталог відповідає шаблону ігнорування, то відображається він, але не шляхи, що містяться в ігнорованому каталозі. Якщо каталог не відповідає шаблону ігнорування, але весь його вміст ігнорується, то каталог не відображається, але відображається весь його вміст.
--

-z::
	Завершуйте записи символом NUL замість LF. Це означає вихідний формат `--porcelain=v1`, якщо не вказано інший формат.

--column[=<options>]::
--no-column::
	Відображати невідстежувані файли у стовпцях. Синтаксис опцій дивіться у змінній конфігурації `column.status`. `--column` та `--no-column` без опцій еквівалентні «always» та «never» відповідно.

--ahead-behind::
--no-ahead-behind::
	Відображати або не відображати детальну кількість пропущених/відсталих етапів для гілки відносно її гілки вище за течією. За замовчуванням встановлено значення «true».

--renames::
--no-renames::
	Увімкнути/вимкнути виявлення перейменування незалежно від конфігурації користувача. Див. також linkgit:git-diff[1] `--no-renames`.

--find-renames[=<n>]::
	Увімкнути виявлення перейменування, за бажанням встановити поріг подібності. Див. також linkgit:git-diff[1] `--find-renames`.

<pathspec>...::
	Див. запис «pathspec» у linkgit:gitglossary[7].

ВИХІД
-----
Вивід цієї команди призначений для використання як коментар шаблону коміту. Стандартний, довгий формат розроблений таким чином, щоб бути читабельним людиною, детальним та описовим. Його вміст та формат можуть бути змінені в будь-який час.

Шляхи, згадані у виводі, на відміну від багатьох інших команд Git, створюються відносно поточного каталогу, якщо ви працюєте в підкаталозі (це зроблено навмисно, щоб полегшити копіювання та вставку). Дивіться параметр конфігурації status.relativePaths нижче.

Короткий формат
~~~~~~~~~~~~~~~

У скороченому форматі статус кожного шляху відображається в одній з цих форм

	XY PATH
	XY ORIG_PATH -> PATH

де `ORIG_PATH` – це походження перейменованого/скопійованого вмісту. `ORIG_PATH` відображається лише тоді, коли запис перейменовано або скопійовано. `XY` – це дволітерний код стану.

Поля (включно з `->`) розділені одне від одного одним пробілом. Якщо ім'я файлу містить пробіли або інші недруковані символи, це поле буде взято в лапки як рядковий літерал C: оточене подвійними лапками ASCII (34) та з внутрішніми спеціальними символами, екранованими зворотною скісну рискою.

У цьому форматі відображаються три різні типи станів, і кожен з них використовує синтаксис `XY` по-різному:

* Коли відбувається злиття, і воно пройшло успішно, або поза межами злиття
	У цій ситуації `X` показує стан індексу, а `Y` показує стан робочого дерева.
* Коли виник конфлікт злиття, який ще не вирішено, `X` та `Y`
	показати стан, введений кожним голівкою злиття, відносно спільного предка. Ці шляхи називаються _незлитими_.
* Коли шлях не відстежується, `X` та `Y` завжди однакові, оскільки вони
	невідомий індексу. `??` використовується для невідстежуваних шляхів. Ігноровані файли не відображаються, якщо не використовується `--ignored`; якщо використовується, ігноровані файли позначаються `!!`.

Зверніть увагу, що термін _merge_ тут також включає перебазування з використанням стратегії `--merge` за замовчуванням, вибіркові варіанти та будь-що інше, що використовує механізм злиття.

У наступній таблиці ці три класи показано в окремих розділах, а ці символи використовуються для полів `X` та `Y` для перших двох розділів, які показують відстежувані шляхи:

* ' ' = unmodified
* 'M' = modified
* 'T' = тип файлу змінено (звичайний файл, символічне посилання або підмодуль)
* 'A' = додано
* 'D' = видалено
* 'R' = перейменовано
* 'C' = скопійовано (якщо для параметра конфігурації status.renames встановлено значення "копії")
* 'U' = оновлено, але не об'єднано

....
X          Y     Значення
-------------------------------------------------
	 [AMD]   не оновлено
M        [ MTD]  оновлено в індексі
T        [ MTD]  тип змінено в індексі
A        [ MTD]  додано до індексу
D                видалено з індексу
R        [ MTD]  перейменовано в індексі
C        [ MTD]  скопійовано в індекс
[MTARC]          збіги індексу та робочого дерева
[ MTARC]    M    Робоче дерево змінилося з моменту індексування
[ MTARC]    T    тип змінено в робочому дереві з моменту індексування
[ MTARC]    D    видалено в дереві робіт
	    R    перейменовано в дереві робіт
	    C    скопійовано в робоче дерево
-------------------------------------------------
D           D    роз’єднано, обидва видалено
A           U    роз’єднано, додані нами
U           D    роз’єднано, видалені ними
U           A    роз’єднано, додані ними
D           U    роз’єднано, видалено нами
A           A     роз’єднано, обидва додані
U           U    роз’єднано, обидва змінені
-------------------------------------------------
?           ?    невідстежений
!           !    ігнорується
-------------------------------------------------
....

Підмодулі мають більше станів і натомість звітують

* 'M' = підмодуль має значення HEAD, відмінне від записаного в індексі
* 'm' = підмодуль має змінений вміст
* '?' = підмодуль містить невідстежувані файли

Це пояснюється тим, що змінений контент або невідстежувані файли в підмодулі не можна додати через `git add` у суперпроекті для підготовки коміту.

'm' та '?' застосовуються рекурсивно. Наприклад, якщо вкладений підмодуль у підмодулі містить невідстежуваний файл, це також повідомляється як '?'.

If -b використовується, статусу короткого формату передує рядок

    ## інформація про відстеження назви філії

Формат порцеляни, версія 1
~~~~~~~~~~~~~~~~~~~~~~~~~~

Формат porcelain версії 1 схожий на короткий формат, але гарантовано не змінюватиметься зворотно несумісним чином між версіями Git або залежно від конфігурації користувача. Це робить його ідеальним для парсингу скриптами. Опис короткого формату вище також описує формат porcelain, за кількома винятками:

1. Конфігурація color.status користувача не враховується; колір завжди буде вимкнено.

2. Конфігурація status.relativePaths користувача не враховується; показані шляхи завжди будуть відносними до кореневого каталогу репозиторію.

Також існує альтернативний формат -z, рекомендований для машинного розбору. У цьому форматі поле стану залишається тим самим, але деякі інші речі змінюються. По-перше, '\->' пропускається з записів перейменування, а порядок полів змінюється на протилежний (наприклад, 'from \-> to' стає 'to from'). По-друге, після кожного імені файлу йде NUL (ASCII 0), який замінює пробіл як роздільник полів та символ нового рядка в кінці (але пробіл все ще відокремлює поле стану від першого імені файлу). По-третє, імена файлів, що містять спеціальні символи, не форматуються спеціально; лапки та екранування зворотною скісну рискою не виконуються.

Будь-які зміни підмодулів повідомляються як модифікований `M` замість `m` або одинарного `?`.

Формат порцеляни, версія 2
~~~~~~~~~~~~~~~~~~~~~~~~~~

Формат версії 2 додає детальнішу інформацію про стан робочого дерева та змінені елементи. Версія 2 також визначає розширюваний набір простих для розбору додаткових заголовків.

Заголовки починаються з символу "#" і додаються у відповідь на певні аргументи командного рядка. Парсери повинні ігнорувати заголовки, які вони не розпізнають.

Заголовки гілок
^^^^^^^^^^^^^^^

Якщо вказано `--branch`, виводиться серія рядків заголовка з інформацією про поточну гілку.

....
Лінія                                     Нотатки
------------------------------------------------------------
# branch.oid <commit> | (initial)        Поточний коміт.
# branch.head <branch> | (detached)      Поточна гілка.
# branch.upstream <upstream-branch>      Якщо встановлено вихідний сигнал.
# branch.ab +<ahead> -<behind>           Якщо встановлено вихідний сигнал та
					 коміт присутній.
------------------------------------------------------------
....

Інформація про схованку
^^^^^^^^^^^^^^^^^^^^^^^

Якщо вказано `--show-stash`, виводиться один рядок, який показує кількість записів stash, якщо вони не нульові:

    # запас <N>

Змінені відстежувані записи
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Після заголовків друкується серія рядків для відстежуваних записів. Для опису запису може бути використаний один із трьох різних форматів рядків залежно від типу зміни. Відстежувані записи друкуються у невизначеному порядку; парсери повинні дозволяти поєднання 3 типів рядків у будь-якому порядку.

Звичайні змінені записи мають такий формат:

    1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>

Перейменовані або скопійовані записи мають такий формат:

    2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>

....
Значення.     поля
--------------------------------------------------------
<XY>        Поле з 2 символів, що містить проміжні та
	    неіндексовані значення XY, описані у скороченому форматі,
	    з незмінним, позначеним символом "." замість
	    простір.
<sub>       Поле з 4 символів, що описує стан підмодуля.
	    "N..." коли запис не є підмодулем.
	    "S<c><m><u>" коли запис є підмодулем.
	    <c> "C", якщо коміт змінився; інакше ".".
	    <m> має значення «M», якщо відстежені зміни; інакше — «.».
	    <u> «U», якщо є невідстежені зміни; інакше «.».
<mH>        Вісімковий режим файлу в HEAD.
<mI>        Вісімковий режим файлу в індексі.
<mW>        Вісімковий режим файлу в робочому дереві.
<hH>        Ім'я об'єкта в HEAD.
<hI>        Ім'я об'єкта в індексі.
<X><score>  Оцінка перейменування або копіювання (що позначає відсоток
	    подібності між джерелом та цільовою аудиторією
	    переміщення або копіювання). Наприклад, «R100» або «C75».
<path>      Шлях. У перейменованому/скопійованому записі це
	    цільовий шлях.
<sep>       Коли використовується опція `-z`, два шляхи розділяються
	    з байтом NUL (ASCII 0x00); інакше, символ табуляції (ASCII 0x09)
	    байт розділяє їх.
<origPath>  Шлях у коміті в HEAD або в індексі.
	    Це присутнє лише у перейменованому/скопійованому записі, та
	    повідомляє, звідки взявся перейменований/скопійований вміст.
--------------------------------------------------------
....

Необ'єднані записи мають такий формат; перший символ — це «u», щоб відрізнити їх від звичайних змінених записів.

    u <XY> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>

....
Значення      поля
--------------------------------------------------------
<XY>        Двосимвольне поле, що описує тип конфлікту
	    як описано в скороченому форматі.
<sub>       Поле з 4 символів, що описує стан підмодуля
	    як описано вище.
<m1>        Вісімковий режим файлу на етапі 1.
<m2>        Вісімковий режим файлу на етапі 2.
<m3>        Вісімковий режим файлу на етапі 3.
<mW>        Вісімковий режим файлу в робочому дереві.
<h1>        Ім'я об'єкта на етапі 1.
<h2>        Ім'я об'єкта на етапі 2.
<h3>        Ім'я об'єкта на етапі 3.
<path>      Назва шляху.
--------------------------------------------------------
....

Інші товари
^^^^^^^^^^^

Після відстежуваних записів (і за запитом) буде виведено серію рядків для невідстежуваних, а потім ігнорованих елементів, знайдених у робочому дереві.

Невідстежувані елементи мають такий формат:

    ? <path>

Ігноровані елементи мають такий формат:

    ! <path>

Примітки щодо формату імені шляху та -z
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Коли вказано опцію `-z`, шляхи виводяться як є та без лапок, а рядки завершуються байтом NUL (ASCII 0x00).

Без опції `-z` шляхи з "незвичайними" символами взяті в лапки, як пояснено для змінної конфігурації `core.quotePath` (див. linkgit:git-config[1]).


КОНФІГУРАЦІЯ
------------

Команда враховує змінні конфігурації `color.status` (або `status.color` -- вони означають одне й те саме, і остання зберігається для зворотної сумісності) та `color.status.<slot>` для розфарбовування виводу.

Якщо змінна конфігурації `status.relativePaths` має значення false, то всі показані шляхи відносні до кореневого каталогу репозиторію, а не до поточного каталогу.

Якщо для `status.submoduleSummary` встановлено значення, відмінне від нуля, або значення true (ідентичне -1 або необмеженому числу), зведення підмодуля буде ввімкнено для довгого формату, а також буде показано зведення комітів для змінених підмодулів (див. опцію --summary-limit у linkgit:git-submodule[1]). Зверніть увагу, що вивід зведення з команди status буде приховано для всіх підмодулів, коли для `diff.ignoreSubmodules` встановлено значення 'all' або лише для тих підмодулів, де `submodule.<назва>.ignore=all`. Щоб також переглянути зведення для ігнорованих підмодулів, ви можете скористатися опцією командного рядка --ignore-submodules=dirty або командою 'git submodule summary', яка показує подібний вивід, але не враховує ці налаштування.

ОНОВЛЕННЯ ФОНУ
--------------

За замовчуванням, `git status` автоматично оновлюватиме індекс, оновлюючи кешовану статистичну інформацію з робочого дерева та записуючи результат. Запис оновленого індексу – це оптимізація, яка не є абсолютно необхідною (`status` обчислює значення для себе, але їх запис призначений лише для того, щоб наступні програми не повторювали наші обчислення). Коли `status` виконується у фоновому режимі, блокування, що утримується під час запису, може конфліктувати з іншими одночасними процесами, що призведе до їх збою. Скрипти, що виконують `status` у фоновому режимі, повинні розглянути можливість використання `git --no-optional-locks status` (див. linkgit:git[1] для отримання детальнішої інформації).

НЕВІДСЛІДЖЕНІ ФАЙЛИ ТА ПРОДУКТИВНІСТЬ
-------------------------------------

Команда `git status` може бути дуже повільною у великих робочих деревах, якщо/коли потрібно шукати невідстежувані файли та каталоги. Існує багато опцій конфігурації, які дозволяють пришвидшити цей процес, або уникаючи цієї роботи, або використовуючи кешовані результати попередніх команд Git. Не існує єдиного оптимального набору налаштувань, який підходить усім. Ми наведемо короткий опис відповідних опцій, щоб допомогти вам, але перш ніж переходити до списку, можливо, ви захочете запустити `git status` ще раз, оскільки ваша конфігурація вже може кешувати результати `git status`, тому наступні запуску можуть бути швидшими.

* Прапорець `--untracked-files=no` або
	Конфігурація `status.showUntrackedFiles=no` (див. вище для обох): вказує, що `git status` не повинен повідомляти про невідстежувані файли. Це найшвидший варіант. `git status` не відображатиме невідстежувані файли, тому вам потрібно бути обережним, якщо ви створюєте нові файли та вручну `git add` їх.

* `advice.statusUoption=false` (див. linkgit:git-config[1]):
	Встановлення цієї змінної на `false` вимикає попередження, яке виводиться, коли перерахування невідстежуваних файлів займає більше 2 секунд. У великому проекті це може зайняти більше часу, і користувач, можливо, вже погодився на компроміс (наприклад, використання "-uno" може бути неприйнятним варіантом для користувача), і в такому випадку немає сенсу видавати попередження, і в такому випадку вимкнення попередження може бути найкращим варіантом.

* `core.untrackedCache=true` (see linkgit:git-update-index[1]):
	Увімкніть функцію невідстежуваного кешу та шукайте лише ті каталоги, які були змінені з моменту попередньої команди `git status`. Git запам'ятовує набір невідстежуваних файлів у кожному каталозі та припускає, що якщо каталог не був змінений, то набір невідстежуваних файлів у ньому не змінився. Це набагато швидше, ніж перерахування вмісту кожного каталогу, але все одно не без витрат, оскільки Git все одно має шукати набір змінених каталогів. Невідстежуваний кеш зберігається у файлі `.git/index`. Зменшення витрат на пошук невідстежуваних файлів дещо компенсується збільшеним розміром індексу та витратами на його оновлення. Таке скорочення часу пошуку зазвичай виправдовує додатковий розмір.

* `core.untrackedCache=true` та `core.fsmonitor=true` або
	`core.fsmonitor=<hook-command-pathname>` (див. linkgit:git-update-index[1]): увімкнути як невідстежуваний кеш, так і функції FSMonitor, і шукати лише ті каталоги, які були змінені з моменту попередньої команди `git status`. Це швидше, ніж використовувати лише невідстежуваний кеш, оскільки Git також може уникнути пошуку змінених каталогів. Git потрібно лише перерахувати точний набір каталогів, які нещодавно змінилися. Хоча функцію FSMonitor можна ввімкнути без невідстежуваного кешу, переваги в цьому випадку значно зменшуються.

Зверніть увагу, що після ввімкнення функцій невідстежуваного кешу та/або FSMonitor може знадобитися кілька команд `git status` для розігріву різних кешів, перш ніж ви побачите покращення часу виконання команд. Це нормально.

ДИВ. ТАКОЖ
----------
linkgit:gitignore[5]

GIT
---
Частина набору linkgit:git[1]
