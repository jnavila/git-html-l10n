git-rm(1)
=========

НАЗВА
-----
git-rm - Видалити файли з робочого дерева та з індексу

СИНОПСИС
--------
[synopsis]
git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]
       [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]
       [--] [<pathspec>...]

ОПИС
----
Видаліть файли, що відповідають специфікації шляхів (pathspec), з індексу або з робочого дерева та індексу. `git rm` не видалятиме файл лише з вашого робочого каталогу. (Немає можливості видалити файл лише з робочого дерева, але зберегти його в індексі; використовуйте `/bin/rm`, якщо хочете це зробити.) Файли, що видаляються, мають бути ідентичними кінчику гілки, і жодні оновлення їхнього вмісту не можуть бути поміщені в індекс, хоча цю поведінку за замовчуванням можна змінити за допомогою опції `-f`. Коли вказано `--cached`, поміщений вміст має відповідати або кінчику гілки, або файлу на диску, що дозволяє видалити файл лише з індексу. Коли використовуються розріджені перевірки (див. linkgit:git-sparse-checkout[1]), `git rm` видалятиме лише шляхи в межах шаблонів розріджених перевірок.


ОПЦІЇ
-----
`<pathspec>...`::
	Файли для видалення. Можна вказати початкову назву каталогу (наприклад, `dir` для видалення `dir/file1` та `dir/file2`) для видалення всіх файлів у каталозі та рекурсивно всіх підкаталогів, але для цього потрібно явно вказати опцію `-r`.
+
Команда видаляє лише ті шляхи, які відомі Git.
+
Зміщення файлів у глобалізації збігається з межами каталогів. Таким чином, враховуючи два каталоги `d` та `d2`, існує різниця між використанням `git rm 'd*'` та `git rm 'd/*'`, оскільки перше також видалить весь каталог `d2`.
+
Для отримання додаткової інформації див. запис _<pathspec>_ у linkgit:gitglossary[7].

`-f`::
`--force`::
	Скасувати перевірку актуальності.

`-n`::
`--dry-run`::
	Насправді не видаляйте жодних файлів. Натомість просто покажіть, чи існують вони в індексі та чи були б видалені командою.

`-r`::
        Дозволити рекурсивне видалення, якщо вказано назву початкового каталогу.

`--`::
	Цей параметр можна використовувати для відокремлення параметрів командного рядка від списку файлів (корисно, коли імена файлів можуть бути сплутані з параметрами командного рядка).

`--cached`::
	Використовуйте цю опцію, щоб видалити лише шляхи з індексу. Робочі файли дерев, змінені чи ні, залишаться без змін.

`--ignore-unmatch`::
	Вихід з нульовим статусом, навіть якщо не знайдено жодних збігів у файлах.

`--sparse`::
	Дозволити оновлення записів індексу поза межами конуса розрідженого контролю. Зазвичай, `git rm` відмовляється оновлювати записи індексу, шляхи яких не вписуються в конус розрідженого контролю. Див. linkgit:git-sparse-checkout[1] для отримання додаткової інформації.

`-q`::
`--quiet`::
	`git rm` зазвичай виводить один рядок (у формі команди `rm`) для кожного видаленого файлу. Ця опція пригнічує цей вивід.

`--pathspec-from-file=<файл>`::
	Специфікація шляху передається у _<файл>_ замість аргументів. Якщо _<файл>_ дорівнює саме `-`, то використовується стандартний ввід. Елементи Pathspec розділяються символами _LF_ або _CR_/_LF_. Елементи Pathspec можна брати в лапки, як пояснено для змінної конфігурації `core.quotePath` (див. linkgit:git-config[1]). Див. також `--pathspec-file-nul` та глобальну змінну `--literal-pathspecs`.

`--pathspec-file-nul`::
	Має сенс лише з `--pathspec-from-file`. Елементи Pathspec розділяються символом _NUL_, а всі інші символи (включно з символами нового рядка та лапками) сприймаються буквально.


ВИДАЛЕННЯ ФАЙЛІВ, ЯКІ ЗНИКЛИ З ФАЙЛОВОЇ СИСТЕМИ
-----------------------------------------------
Команда `git rm` не має можливості видаляти з індексу лише ті шляхи, які зникли з файлової системи. Однак, залежно від випадку використання, існує кілька способів зробити це.

Використання ``git commit -a''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Якщо ви маєте намір, щоб ваш наступний коміт записував усі модифікації відстежуваних файлів у робочому дереві та записував усі видалення файлів, які були видалені з робочого дерева за допомогою `rm` (на відміну від `git rm`), використовуйте `git commit -a`, оскільки він автоматично помітить та запише всі видалення. Ви також можете досягти подібного ефекту без коміту, використовуючи `git add -u`.

Використання ``git add -A''
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Під час прийняття нового додавання коду для гілки постачальника, ймовірно, ви захочете записати як видалення шляхів, так і додавання нових шляхів, а також зміни існуючих шляхів.

Зазвичай спочатку потрібно видалити всі відстежувані файли з робочого дерева за допомогою цієї команди:

----------------
git ls-files -z | xargs -0 rm -f
----------------

а потім розпакуйте новий код у робочому дереві. Або ж ви можете «rsync» зміни в робочому дереві.

Після цього найпростіший спосіб записувати всі видалення, додавання та модифікації в робочому дереві:

----------------
git add -A
----------------

Див. linkgit:git-add[1].

Інші способи
~~~~~~~~~~~~
Якщо все, що ви дійсно хочете зробити, це видалити з індексу файли, яких більше немає в робочому дереві (можливо, тому, що ваше робоче дерево "брудне", тому ви не можете використовувати `git commit -a`), скористайтеся такою командою:

----------------
git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached
----------------

ПІДМОДУЛІ
---------
Тільки підмодулі, що використовують gitfile (це означає, що вони були клоновані за допомогою Git версії 1.7.8 або новішої), будуть видалені з робочого дерева, оскільки їхній репозиторій знаходиться в директорії `.git` суперпроекту. Якщо підмодуль (або один з вкладених у нього) все ще використовує директорію `.git`, `git rm` переміщує директорію submodules git до директорії superprojects git, щоб захистити історію підмодуля. Якщо вона існує, розділ `submodule.<name>` у файлі linkgit:gitmodules[5] також буде видалено, і цей файл буде поміщено в проміжок (якщо не використовується `--cached` або `-n`).

Підмодуль вважається оновленим, коли `HEAD` такий самий, як записаний в індексі, жодні відстежувані файли не змінені, а в робочому дереві підмодуля немає невідстежуваних файлів, які не ігноруються. Ігноровані файли вважаються такими, що можна використовувати, і це не запобігає видаленню робочого дерева підмодуля.

Якщо ви хочете лише видалити локальне отримання підмодуля з вашого робочого дерева без фіксації видалення, використовуйте замість цього linkgit:git-submodule[1] `deinit`. Також дивіться linkgit:gitsubmodules[7] для отримання детальної інформації про видалення підмодулів.

ПРИКЛАДИ
--------
`git rm Documentation/\*.txt`::
	Видаляє всі файли `*.txt` з індексу, що знаходяться в каталозі `Documentation` та будь-яких його підкаталогах.
+
Зверніть увагу, що зірочку `*` у цьому прикладі взято в лапки з боку оболонки; це дозволяє Git, а не оболонці, розширювати шляхи до файлів та підкаталогів у каталозі `Documentation/`.

`git rm -f git-*.sh`::
	Оскільки цей приклад дозволяє командній оболонці розгорнути зірочку (тобто ви явно перераховуєте файли), він не видаляє `subdir/git-foo.sh`.

ПОМИЛКИ
-------
Щоразу, коли оновлення суперпроекту видаляє заповнений підмодуль (наприклад, під час перемикання між комітами до та після видалення), застаріле отримання підмодуля залишатиметься у старому місці. Видалення старого каталогу безпечне лише тоді, коли використовується git-файл, оскільки в іншому випадку історія підмодуля також буде видалена. Цей крок буде застарілим після реалізації рекурсивного оновлення підмодуля.

ДИВ. ТАКОЖ
----------
linkgit:git-add[1]

GIT
---
Частина набору linkgit:git[1]
