git-rev-parse(1)
================

НАЗВА
-----
git-rev-parse - Вибір та визначення параметрів


СИНОПСИС
--------
[verse]
'git rev-parse' [<options>] <arg>...

ОПИС
----

Багато порцелянових команд Git приймають суміш прапорців (тобто параметрів, що починаються з тире '-') та параметрів, призначених для базової команди 'git rev-list', яку вони використовують внутрішньо, а також прапорців і параметрів для інших команд, які вони використовують після 'git rev-list'. Основна мета цієї команди — дозволити викликаючим програмам розрізняти їх. Існує кілька інших режимів роботи, які не мають нічого спільного з вищезгаданими "допомогою розібрати параметри командного рядка".

Якщо не вказано інше, більшість опцій та режимів роботи вимагають виконання цієї команди всередині репозиторію git або робочого дерева, що знаходиться під керуванням репозиторію git, і в іншому випадку виникне фатальна помилка.


ОПЦІЇ
-----

Режими роботи
~~~~~~~~~~~~~

Кожен із цих параметрів має з’явитися першим у командному рядку.

--parseopt::
	Використовуйте 'git rev-parse' у режимі розбору опцій (див. розділ PARSEOPT нижче). Команду в цьому режимі можна використовувати поза репозиторієм або робочим деревом, що контролюється репозиторієм.

--sq-quote::
	Використовуйте 'git rev-parse' у режимі цитування оболонки (див. розділ SQ-QUOTE нижче). На відміну від опції `--sq` нижче, цей режим виконує лише цитування. Більше нічого не робиться з введенням команди. Команда в цьому режимі може бути використана поза репозиторієм або робочим деревом, контрольованим репозиторієм.

Варіанти для --parseopt
~~~~~~~~~~~~~~~~~~~~~~~

--keep-dashdash::
	Має значення лише в режимі `--parseopt`. Наказує синтаксичному аналізу опцій виводити перший зустрінутий `--` замість того, щоб пропускати його.

--stop-at-non-option::
	Має значення лише в режимі `--parseopt`. Дозволяє синтаксичному аналізу опцій зупинитися на першому аргументі, який не є опцією. Це можна використовувати для розбору підкоманд, які самі приймають опції.

--stuck-long::
	Має значення лише в режимі `--parseopt`. Виведіть параметри у їхньому розгорнутому вигляді, якщо вони доступні, та з їхніми аргументами, що залишилися.

Параметри фільтрації
~~~~~~~~~~~~~~~~~~~~

--revs-only::
	Не виводити прапорці та параметри, не призначені для команди 'git rev-list'.

--no-revs::
	Не виводити прапорці та параметри, призначені для команди 'git rev-list'.

--flags::
	Не виводьте параметри, що не є прапорцями.

--no-flags::
	Не виводьте параметри прапорців.

Параметри виводу
~~~~~~~~~~~~~~~~

--default <arg>::
	Якщо користувач не вказав параметр, використовуйте замість нього `<arg>`.

--prefix <arg>::
	Поводитися так, ніби 'git rev-parse' було викликано з підкаталогу `<arg>` робочого дерева. Будь-які відносні імена файлів розпізнаються так, ніби вони мають префікс `<arg>`, і будуть виведені у цьому вигляді.
+
Це можна використовувати для перетворення аргументів у команду, що виконується в підкаталозі, щоб їх можна було використовувати після переміщення на верхній рівень репозиторію. Наприклад:
+
----
prefix=$(git rev-parse --show-prefix)
cd "$(git rev-parse --show-toplevel)"
# rev-parse provides the -- needed for 'set'
eval "set $(git rev-parse --sq --prefix "$prefix" -- "$@")"
----

--verify::
	Перевірте, чи надано лише один параметр, і чи його можна перетворити на необроблений 20-байтовий SHA-1, який можна використовувати для доступу до бази даних об'єктів. Якщо так, виведіть його на стандартний вивід; інакше виведіть помилку.
+
Якщо ви хочете переконатися, що вивід дійсно називає об'єкт у вашій базі даних об'єктів та/або може бути використаний як певний тип об'єкта, який вам потрібен, ви можете додати оператор відшаровування `^{type}` до параметра. Наприклад, `git rev-parse "$VAR^{commit}"` гарантує, що `$VAR` називатиме існуючий об'єкт, який є комітом (тобто коміт або анотований тег, що вказує на коміт). Щоб переконатися, що `$VAR` називає існуючий об'єкт будь-якого типу, можна використовувати `git rev-parse "$VAR^{object}"`.
+
Зверніть увагу, що якщо ви перевіряєте ім'я з ненадійного джерела, доцільно використовувати `--end-of-options`, щоб аргумент імені не було сплутано з іншим параметром.

-q::
--quiet::
	Має значення лише в режимі `--verify`. Не виводити повідомлення про помилку, якщо перший аргумент не є коректним ім'ям об'єкта; натомість завершити роботу з ненульовим статусом без жодних зусиль. SHA-1 для коректних імен об'єктів виводяться на стандартний вивід у разі успіху.

--sq::
	Зазвичай вивід виконується в один рядок на кожен прапорець та параметр. Ця опція робить вивід одним рядком, належним чином взятим у лапки для використання оболонкою. Корисно, коли ви очікуєте, що ваш параметр містить пробіли та символи нового рядка (наприклад, під час використання pickaxe `-S` з 'git diff-{asterisk}'). На відміну від опції `--sq-quote`, введені команди все ще інтерпретуються як завжди.

--short[=<довжина>]::
	Те саме, що й `--verify`, але скорочує назву об'єкта до унікального префікса з принаймні символами `length`. Мінімальна довжина — 4, значення за замовчуванням дорівнює ефективному значенню змінної конфігурації `core.abbrev` (див. linkgit:git-config[1]).

--not::
	Під час відображення назв об'єктів додавайте перед ними префікс '{caret}' та видаляйте префікс '{caret}' з назв об'єктів, які вже мають такий префікс.

--abbrev-ref[=(strict|loose)]::
	Неоднозначна коротка назва об'єкта. Для вибору режиму суворого скорочення використовується параметр core.warnAmbiguousRefs.

--symbolic::
	Зазвичай імена об'єктів виводяться у форматі SHA-1 (з можливим префіксом '{caret}'); ця опція робить їх виведеними у формі, максимально наближеній до оригінального вхідного значення.

--symbolic-full-name::
	Це схоже на --symbolic, але воно пропускає вхідні дані, які не є посиланнями (тобто назви гілок або тегів; або, більш чітко, форму "heads/master", що усуває неоднозначність, коли ви хочете назвати гілку "master", коли є тег з невдалою назвою "master"), і показує їх як повні назви посилань (наприклад, "refs/heads/master").

--output-object-format=(sha1|sha256|storage)::

	Дозволити введення oids з будь-якого формату об'єктів, який підтримує поточний репозиторій.

	Вказівка "sha1" за потреби перетворює та повертає sha1 oid.

	Вказівка "sha256" за потреби перетворює та повертає oid sha256.

	Вказівка "storage" за потреби перетворює значення та повертає oid, закодоване в алгоритмі хешування сховища.

Параметри для об'єктів
~~~~~~~~~~~~~~~~~~~~~~

--all::
	Показати всі посилання, знайдені в `refs/`.

--branches[=<pattern>]::
--tags[=<pattern>]::
--remotes[=<pattern>]::
	Показати всі гілки, теги або гілки віддаленого відстеження відповідно (тобто посилання, знайдені в `refs/heads`, `refs/tags` або `refs/remotes` відповідно).
+
Якщо задано `шаблон`, відображаються лише посилання, що відповідають заданому глобусу оболонки. Якщо шаблон не містить символу глобулювання (`?`, `*` або `[`), він перетворюється на префіксний збіг шляхом додавання `/*`.

--glob=<візерунок>::
	Показати всі посилання, що відповідають шаблону глобального поля оболонки `pattern`. Якщо шаблон не починається з `refs/`, це автоматично додається на початку. Якщо шаблон не містить символу глобального поля (`?`, `*` або `[`), він перетворюється на префіксний збіг шляхом додавання `/*`.

--exclude=<glob-pattern>::
	Не включайте посилання, що відповідають '<glob-pattern>', які наступні `--all`, `--branches`, `--tags`, `--remotes` або `--glob` враховували б. Повторення цієї опції накопичують шаблони виключень до наступної опції `--all`, `--branches`, `--tags`, `--remotes` або `--glob` (інші опції або аргументи не очищують накопичені шаблони).
+
Наведені шаблони не повинні починатися з `refs/heads`, `refs/tags` або `refs/remotes` при застосуванні до `--branches`, `--tags` або `--remotes` відповідно, і вони повинні починатися з `refs/` при застосуванні до `--glob` або `--all`. Якщо передбачається завершальна '/{asterisk}', її потрібно вказати явно.

--exclude-hidden=(fetch|receive|uploadpack)::
	Не включайте посилання, які можуть бути приховані командами `git-fetch`, `git-receive-pack` або `git-upload-pack`, звернувшись до відповідної конфігурації `fetch.hideRefs`, `receive.hideRefs` або `uploadpack.hideRefs` разом із `transfer.hideRefs` (див. linkgit:git-config[1]). Цей параметр впливає на наступний параметр псевдопосилання `--all` або `--glob` та очищається після їх обробки.

--disambiguate=<prefix>::
	Показати кожен об'єкт, ім'я якого починається із заданого префікса. <префікс> має містити щонайменше 4 шістнадцяткові цифри, щоб уникнути помилкового перерахування кожного об'єкта в репозиторії.

Параметри для файлів
~~~~~~~~~~~~~~~~~~~~

--local-env-vars::
	Перелічіть змінні середовища GIT_*, які є локальними для репозиторію (наприклад, GIT_DIR або GIT_WORK_TREE, але не GIT_EDITOR). Перелічено лише назви змінних, а не їхні значення, навіть якщо вони встановлені.

--path-format=(absolute|relative)::
	Керує поведінкою деяких інших параметрів. Якщо вказано як абсолютний, шляхи, що виводяться цими параметрами, будуть абсолютними та канонічними. Якщо вказано як відносний, шляхи будуть відносними до поточного робочого каталогу, якщо це можливо. Значення за замовчуванням залежить від параметра.
+
Цей параметр можна вказувати кілька разів, і він впливає лише на аргументи, що йдуть після нього в командному рядку, або до кінця командного рядка, або до наступного екземпляра цього параметра.

Наступні опції змінюються за допомогою параметра `--path-format`:

--git-dir::
	Показувати `$GIT_DIR`, якщо визначено. В іншому випадку показувати шлях до каталогу .git. Показаний шлях, якщо він відносний, є відносним до поточного робочого каталогу.
+
Якщо `$GIT_DIR` не визначено, і поточний каталог не виявлено в репозиторії Git або робочому дереві, вивести повідомлення на stderr та завершити роботу з ненульовим статусом.

--git-common-dir::
	Показувати `$GIT_COMMON_DIR`, якщо визначено, інакше `$GIT_DIR`.

--resolve-git-dir <path>::
	Перевірити, чи <шлях> є дійсним репозиторієм або git-файлом, який вказує на дійсний репозиторій, та вивести розташування репозиторію. Якщо <шлях> є git-файлом, то вивести визначений шлях до справжнього репозиторію.

--git-path <path>::
	Вирішує проблему з "$GIT_DIR/<шлях>" та враховує інші змінні переміщення шляху, такі як $GIT_OBJECT_DIRECTORY, $GIT_INDEX_FILE.... Наприклад, якщо $GIT_OBJECT_DIRECTORY встановлено на /foo/bar, тоді "git rev-parse --git-path objects/abc" повертає /foo/bar/abc.

--show-toplevel::
	Показати (за замовчуванням абсолютний) шлях до каталогу верхнього рівня робочого дерева. Якщо робочого дерева немає, повідомити про помилку.

--show-superproject-working-tree::
	Показати абсолютний шлях до кореня робочого дерева суперпроекту (якщо існує), який використовує поточний репозиторій як свій підмодуль. Нічого не виводить, якщо поточний репозиторій не використовується як підмодуль жодним проєктом.

--shared-index-path::
	Показати шлях до спільного файлу індексу в режимі розділеного індексу або порожній, якщо не в режимі розділеного індексу.

Наступні опції не залежать від `--path-format`:

--absolute-git-dir::
	Подібно до `--git-dir`, але його вивід завжди є канонізованим абсолютним шляхом.

--is-inside-git-dir::
	Коли поточний робочий каталог знаходиться нижче каталогу репозиторію, виведіть "true", інакше "false".

--is-inside-work-tree::
	Коли поточний робочий каталог знаходиться всередині робочого дерева репозиторію, виведіть "true", інакше "false".

--is-bare-repository::
	Коли репозиторій чистий, вивести "true", інакше "false".

--is-shallow-repository::
	Коли репозиторій поверхневий, вивести "true", інакше "false".

--show-cdup::
	Коли команда викликається з підкаталогу, відображає шлях до каталогу верхнього рівня відносно поточного каталогу (зазвичай послідовність "../" або порожній рядок).

--show-prefix::
	Коли команда викликається з підкаталогу, показати шлях до поточного каталогу відносно каталогу верхнього рівня.

--show-object-format[=(storage|input|output)]::
	Показати формат об'єкта (алгоритм хешування), що використовується для репозиторію для зберігання всередині каталогу `.git`, вхідних або вихідних даних. Для вхідних даних можна вивести кілька алгоритмів, розділених пробілами. Якщо не вказано, значення за замовчуванням — "storage".

--show-ref-format::
	Показати формат сховища посилань, який використовується для репозиторію.


Інші варіанти
~~~~~~~~~~~~~

--since=<рядок дати>::
--after=<рядок дати>::
	Розберіть рядок дати та виведіть відповідний параметр --max-age= для 'git rev-list'.

--until=<рядок дати>::
--before=<рядок дати>::
	Розберіть рядок дати та виведіть відповідний параметр --min-age= для 'git rev-list'.

<arg>...::
	Прапорці та параметри, що підлягають розбору.


include::revisions.adoc[]

ПАРСЕОПТ
--------

У режимі `--parseopt`, 'git rev-parse' допомагає з опціями, щоб надати скриптам оболонки ті ж можливості, що й вбудовані функції C. Він працює як нормалізатор опцій (наприклад, розділяє агреговані значення окремих перемикачів), трохи подібно до `getopt(1)`.

Він приймає на стандартний вхід специфікацію опцій для розбору та розуміння, а на стандартний вивід виводить рядок, придатний для `sh(1)` `eval`, щоб замінити аргументи нормалізованими. У разі помилки він виводить використання у стандартному потоці помилок та завершує роботу з кодом 129.

Примітка: Переконайтеся, що ви цитуєте результат, передаючи його до `eval`. Дивіться приклад нижче.

Формат введення
~~~~~~~~~~~~~~~

Формат вхідних даних 'git rev-parse --parseopt' повністю текстовий. Він складається з двох частин, розділених рядком, який містить лише `--`. Рядки перед роздільником (їх має бути один або більше) використовуються для використання. Рядки після роздільника описують опції.

Кожен рядок опцій має такий формат:

------------
<opt-spec><flags>*<arg-hint>? SP+ help LF
------------

`<opt-spec>`::
	його формат такий: спочатку короткий символ опції, потім довга назва опції, розділені комою. Обидві частини не є обов'язковими, хоча принаймні одна є необхідною. Не може містити жодного з символів `<flags>`. `h,help`, `dry-run` та `f` є прикладами правильного `<opt-spec>`.

`<flags>`::
	`<flags>` є `*`, `=`, `?` або `!`.
	* Використовуйте `=`, якщо опція приймає аргумент.

	* Використовуйте `?`, щоб означити, що опція приймає необов'язковий аргумент. Ймовірно, вам варто використовувати режим `--stuck-long`, щоб мати змогу однозначно розібрати необов'язковий аргумент.

	* Використовуйте `*`, щоб означити, що цей параметр не слід вказувати у використанні, згенерованому для аргументу `-h`. Він відображається для `--help-all`, як задокументовано в linkgit:gitcli[7].

	* Використовуйте символ `!`, щоб не зробити відповідний заперечений довгий параметр доступним.

`<arg-hint>`::
	`<arg-hint>`, якщо вказано, використовується як назва аргументу у виводі довідки для опцій, що приймають аргументи. `<arg-hint>` завершується першим пробілом. Зазвичай для розділення слів у підказці аргументу з кількох слів використовується тире.

Решта рядка, після видалення пробілів, використовується як довідка, пов'язана з опцією.

Пусті рядки ігноруються, а рядки, що не відповідають цій специфікації, використовуються як заголовки групи опцій (починайте рядок з пробілу, щоб навмисно створювати такі рядки).

Приклад
~~~~~~~

------------
OPTS_SPEC="\
some-command [<options>] <args>...

some-command does foo and bar!
--
г, допоможіть! покажіть допомогу

foo якийсь крутий варіант --foo bar= якийсь крутий варіант --bar з аргументом baz=arg ще один крутий варіант --baz з іменованим аргументом qux?path qux може приймати шлях як аргумент, але має сам по собі значення

  An option group Header
C?        option C with an optional argument"

eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"
------------


Текст використання
~~~~~~~~~~~~~~~~~~

Коли `"$@"` має значення `-h` або `--help` у наведеному вище прикладі, буде показано наступний текст використання:

------------
usage: some-command [<options>] <args>...

    some-command виконує foo та bar!

    -h, --help            show the help
    --[no-]foo            some nifty option --foo
    --[no-]bar ...        some cool option --bar with an argument
    --[no-]baz <arg>      another cool option --baz with a named argument
    --[no-]qux[=<path>]   qux may take a path argument but has meaning by itself

An option group Header
    -C[...]               option C with an optional argument
------------

SQ-ЦИТАТА
---------

У режимі `--sq-quote`, 'git rev-parse' виводить на стандартний вивід один рядок, придатний для `sh(1)` `eval`. Цей рядок створюється шляхом нормалізації аргументів після `--sq-quote`. Нічого, крім взяття аргументів у лапки, не робиться.

Якщо ви хочете, щоб введені команди все ще інтерпретувалися як завжди командою 'git rev-parse' перед тим, як вивід буде взято в лапки оболонки, дивіться опцію `--sq`.

Приклад
~~~~~~~

------------
$ cat >your-git-script.sh <<\EOF
#!/bin/sh
args=$(git rev-parse --sq-quote "$@")   # quote user-supplied arguments
command="git frotz -n24 $args"          # and use it inside a handcrafted
					# command line
eval "$command"
EOF

$ sh your-git-script.sh "a b'c"
------------

ПРИКЛАДИ
--------

* Вивести назву об'єкта поточного коміту:
+
------------
$ git rev-parse --verify HEAD
------------

* Вивести назву об'єкта коміту з ревізії у змінній оболонки $REV:
+
------------
$ git rev-parse --verify --end-of-options $REV^{commit}
------------
+
Це призведе до помилки, якщо $REV порожній або не є коректною редакцією.

* Подібно до вищезазначеного:
+
------------
$ git rev-parse --default master --verify --end-of-options $REV
------------
+
але якщо $REV порожній, буде виведено ім'я об'єкта коміту з master.

GIT
---
Частина набору linkgit:git[1]
