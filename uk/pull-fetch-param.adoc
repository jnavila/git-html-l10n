<repository>::
	«Віддалене» сховище, яке є джерелом операції fetch або pull. Цей параметр може бути або URL-адресою (див. розділ <<URLS, GIT URLS>> нижче), або іменем віддаленого сховища (див. розділ <<REMOTES,REMOTES>> нижче).

ifndef::git-pull[]
<group>::
	Ім'я, що посилається на список репозиторіїв як значення remotes.<group> у файлі конфігурації. (Див. linkgit:git-config[1]).
endif::git-pull[]

<refspec>::
	Визначає, які посилання потрібно отримати, а які локальні посилання потрібно оновити. Якщо в командному рядку немає <refspec>, посилання для отримання зчитуються зі змінних `remote.<repository>.fetch`
ifndef::git-pull[]
	(see <<CRTB,CONFIGURED REMOTE-TRACKING BRANCHES>> below).
endif::git-pull[]
ifdef::git-pull[]
	(див. розділ «НАЛАШТУВАНІ ВІДДІЛЕННЯ ДИСТАНЦІЙНОГО ВІДСТЕЖЕННЯ»
	in linkgit:git-fetch[1]).
endif::git-pull[]
+
Формат параметра <refspec> – це необов'язковий символ плюса `+`, за яким іде джерело <src>, далі двокрапка `:`, а потім кінцевий <dst>. Двокрапку можна пропустити, якщо <dst> порожній. <src> зазвичай є посиланням або шаблоном глобального типу з однією символом `*`, який використовується для зіставлення набору посилань, але також може бути повним шістнадцятковим ім'ям об'єкта, написаним у вигляді назви.
+
<refspec> може містити `*` у своєму <src>, щоб вказати просте збігання зі зразком. Така специфікація посилань функціонує як глобальний об'єкт, який зіставляє будь-яке посилання зі зразком. Шаблон <refspec> повинен мати одну і тільки одну `*` як у <src>, так і в <dst>. Вона зіставлятиме посилання з місцем призначення, замінюючи `*` вмістом, що збігається з джерелом.
+
Якщо специфікація посилань починається з префікса `^`, вона буде інтерпретована як негативна специфікація посилань. Замість того, щоб вказувати, які посилання потрібно вибрати або які локальні посилання потрібно оновити, така специфікація посилань натомість визначатиме посилання, які потрібно виключити. Посилання вважатиметься таким, що відповідає, якщо воно відповідає принаймні одній позитивній специфікації посилань і не відповідає жодній негативній специфікації посилань. Негативні специфікації посилань можуть бути корисними для обмеження області дії специфікації посилань шаблону, щоб вона не включала певні посилання. Негативні специфікації посилань самі по собі можуть бути специфікаціями посилань шаблону. Однак вони можуть містити лише <src> і не вказувати <dst>. Повністю написані шістнадцяткові імена об'єктів також не підтримуються.
+
`tag <tag>` означає те саме, що `refs/tags/<tag>:refs/tags/<tag>`; він запитує отримання всього до заданого тегу.
+
Вибирається віддалене посилання, яке відповідає <src>, і якщо <dst> не є порожнім рядком, робиться спроба оновити локальне посилання, яке йому відповідає.
+
Чи дозволено це оновлення без `--force`, залежить від простору імен посилань, до якого воно вибирається, типу об'єкта, що вибирається, та від того, чи вважається оновлення перемотуванням вперед. Загалом, для вибирання застосовуються ті самі правила, що й під час надсилання, див. розділ `<refspec>...` у linkgit:git-push[1], щоб дізнатися, що це таке. Винятки з цих правил, що стосуються `git fetch`, наведено нижче.
+
До версії Git 2.20, на відміну від push-надсилання за допомогою linkgit:git-push[1], будь-які оновлення `refs/tags/*` приймалися без `+` у специфікації refs (або `--force`). Під час отримання змін ми без розбору вважали всі оновлення тегів з віддаленого сервера примусовими. Починаючи з версії Git 2.20, отримання змін для оновлення `refs/tags/*` працює так само, як і під час надсилання змін. Тобто будь-які оновлення будуть відхилені без `+` у специфікації refs (або `--force`).
+
На відміну від push-у з linkgit:git-push[1], будь-які оновлення поза `refs/{tags,heads}/*` будуть прийняті без `+` у специфікації refs (або `--force`), незалежно від того, чи це заміна, наприклад, об'єкта дерева на blob, чи коміту на інший коміт, який не має попереднього коміту як предка тощо.
+
На відміну від push-управління за допомогою linkgit:git-push[1], немає жодної конфігурації, яка б змінювала ці правила, і нічого подібного до хука `pre-fetch`, аналогічного хуку `pre-receive`.
+
Як і у випадку з push-надсиланням за допомогою linkgit:git-push[1], усі описані вище правила щодо того, що не дозволено як оновлення, можна перевизначити, додавши необов'язковий початковий символ `+` до специфікації посилань (або використовуючи параметр командного рядка `--force`). Єдиним винятком є те, що жодне примусове надсилання не змусить простір імен `refs/heads/*` приймати об'єкт без коміту.
+
[NOTE]
Коли відомо, що віддалена гілка, яку ви хочете отримати, регулярно перемотується та перебазується, очікується, що її нова підказка не буде нащадком попередньої підказки (як вона зберігалася у вашій гілці з віддаленим відстеженням під час останнього отримання). Вам слід використовувати знак `+`, щоб вказати, що для таких гілок будуть потрібні оновлення без перемотування вперед. Немає способу визначити або оголосити, що гілка буде доступною в репозиторії з такою поведінкою; користувач, що витягує, просто повинен знати, що це очікуваний шаблон використання гілки.
ifdef::git-pull[]
+
[NOTE]
Існує різниця між перерахуванням кількох <refspec> безпосередньо в командному рядку 'git pull' та наявністю кількох записів `remote.<repository>.fetch` у вашій конфігурації для <repository> та запуском команди 'git pull' без будь-яких явних параметрів <refspec>. <refspec>, явно перелічені в командному рядку, завжди об'єднуються з поточною гілкою після отримання. Іншими словами, якщо ви перерахуєте більше одного віддаленого посилання, 'git pull' створить злиття Octopus. З іншого боку, якщо ви не перерахуєте жодного явного параметра <refspec> у командному рядку, 'git pull' отримає всі <refspec>, які він знайде в конфігурації `remote.<repository>.fetch`, та об'єднає лише перший знайдений <refspec> з поточною гілкою. Це тому, що створення Octopus з віддалених посилань рідко виконується, тоді як відстеження кількох віддалених заголовків за один раз шляхом отримання більш ніж одного часто корисне.
endif::git-pull[]
