git-describe(1)
===============

НАЗВА
-----
git-describe - Дайте об'єкту зрозуміле для людини ім'я на основі доступного посилання

СИНОПСИС
--------
[verse]
'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>...]
'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>]
'git describe' <blob>

ОПИС
----
Команда знаходить найновіший тег, доступний з коміту. Якщо тег вказує на коміт, то відображається лише тег. В іншому випадку, до назви тегу додається суфікс із кількістю додаткових комітів поверх тегованого об'єкта та скорочена назва об'єкта останнього коміту. Результатом є "читабельна для людини" назва об'єкта, яку також можна використовувати для ідентифікації коміту іншими командами git.

За замовчуванням (без --all або --tags) `git describe` показує лише анотовані теги. Для отримання додаткової інформації про створення анотованих тегів дивіться опції -a та -s для linkgit:git-tag[1].

Якщо заданий об'єкт посилається на блоб, він буде описаний як `<commit-ish>:<path>`, таким чином, блоб можна знайти за адресою `<path>` у `<commit-ish>`, що саме описує перший коміт, у якому цей блоб зустрічається у зворотному ході ревізії від HEAD.

ОПЦІЇ
-----
<commit-ish>...::
	Імена об'єктів у стилі Commit для опису. Якщо пропущено, використовується значення HEAD.

--dirty[=<mark>]::
--broken[=<mark>]::
	Опишіть стан робочого дерева. Коли робоче дерево відповідає HEAD, вивід буде таким самим, як "git describe HEAD". Якщо робоче дерево має локальну модифікацію, до нього додається "-dirty". Якщо репозиторій пошкоджений і Git не може визначити, чи є локальна модифікація, Git виведе помилку, якщо не вказано `--broken', що додає суфікс "-broken".

--all::
	Замість використання лише анотованих тегів, використовуйте будь-яке посилання, знайдене в просторі імен `refs/`. Ця опція вмикає зіставлення з будь-якою відомою гілкою, гілкою віддаленого відстеження або полегшеним тегом.

--tags::
	Замість використання лише анотованих тегів, використовуйте будь-який тег з простору імен `refs/tags`. Ця опція вмикає зіставлення з легким (неанотованим) тегом.

--contains::
	Замість пошуку тегу, який передує коміту, знайдіть тег, який йде після коміту і, таким чином, містить його. Автоматично передбачає --tags.

--abbrev=<n>::
	Замість використання стандартної кількості шістнадцяткових цифр (яка змінюватиметься залежно від кількості об'єктів у репозиторії, за замовчуванням це 7) скороченої назви об'єкта, використовуйте <n> цифр або стільки цифр, скільки потрібно для формування унікальної назви об'єкта. <n>, що дорівнює 0, пригнічуватиме довгий формат, показуючи лише найближчий тег.

--candidates=<n>::
	Замість того, щоб розглядати лише 10 найновіших тегів як кандидатів для опису вхідних даних, подібних до комітів, розгляньте до <n> кандидатів. Збільшення <n> вище 10 займе трохи більше часу, але може дати точніший результат. <n>, що дорівнює 0, призведе до виведення лише точних збігів.

--exact-match::
	Виводити лише точні збіги (тег безпосередньо посилається на наданий коміт). Це синонім до --candidates=0.

--debug::
	Детально відображати інформацію про стратегію пошуку, що використовується, з урахуванням стандартної помилки. Назва тегу все одно буде виведена з урахуванням стандартної помилки.

--long::
	Завжди виводьте довгий формат (тег, кількість комітів та скорочену назву коміта), навіть якщо він збігається з тегом. Це корисно, коли ви хочете побачити частини назви об'єкта коміта у виводі "describe", навіть якщо коміт, про який йде мова, є тегованою версією. Замість того, щоб просто виводити назву тегу, такий коміт буде описано як v1.2-0-gdeadbee (0-й коміт з моменту тегу v1.2, який вказує на об'єкт deadbee....).

--match <pattern>::
	Розглядати лише теги, що відповідають заданому шаблону `glob(7)`, за винятком префікса "refs/tags/". Якщо використовується з `--all`, також враховуються локальні гілки та посилання на віддалене відстеження, що відповідають шаблону, за винятком префіксів "refs/heads/" та "refs/remotes/" відповідно; посилання інших типів ніколи не враховуються. Якщо вказано кілька разів, буде накопичено список шаблонів, і будуть розглянуті теги, що відповідають будь-якому з шаблонів. Використовуйте `--no-match`, щоб очистити та скинути список шаблонів.

--exclude <pattern>::
	Не враховувати теги, що відповідають заданому шаблону `glob(7)`, за винятком префікса "refs/tags/". Якщо використовується з `--all`, також не враховуються локальні гілки та посилання на віддалене відстеження, що відповідають шаблону, за винятком префіксів "refs/heads/" та "refs/remotes/" відповідно; посилання інших типів ніколи не враховуються. Якщо вказано кілька разів, буде накопичено список шаблонів, а теги, що відповідають будь-якому з шаблонів, будуть виключені. У поєднанні з --match тег буде розглянуто, коли він відповідає принаймні одному шаблону --match та не відповідає жодному з шаблонів --exclude. Використовуйте `--no-exclude` для очищення та скидання списку шаблонів.

--always::
	Показувати унікально скорочений об'єкт коміту як резервний варіант.

--first-parent::
	Слідкуйте лише за першим батьківським комітом після перегляду коміту злиття. Це корисно, коли ви не хочете збігатися з тегами на гілках, об'єднаних в історії цільового коміту.

ПРИКЛАДИ
--------

З чимось на кшталт git.git current tree я отримую:

	[torvalds@g5 git]$ git describe parent
	v1.0.4-14-g2414721

тобто поточний head моєї "батьківської" гілки базується на версії 1.0.4, але оскільки вона має кілька комітів на додаток до цього, describe додав кількість додаткових комітів ("14") та скорочену назву об'єкта для самого коміту ("2414721") в кінці.

Кількість додаткових комітів — це кількість комітів, які відображатимуться командою "git log v1.0.4..parent". Хеш-суфікс — "-g" + однозначне скорочення для коміта tip parent (яким було `2414721b194453f058079d897d13c4e377f92dc6`). Довжина скорочення масштабується в міру зростання репозиторію, використовуючи приблизну кількість об'єктів у репозиторії та трохи математики навколо парадоксу дня народження, і за замовчуванням становить мінімум 7. Префікс "g" означає "git" і використовується для опису версії програмного забезпечення залежно від SCM, за допомогою якої керується програмне забезпечення. Це корисно в середовищі, де люди можуть використовувати різні SCM.

Виконання команди 'git describe' для імені тегу просто покаже назву тегу:

	[torvalds@g5 git]$ git describe v1.0.4
	v1.0.4

З параметром --all команда може використовувати заголовки гілок як посилання, тому вивід також показує шлях посилання:

	[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2
	tags/v1.0.0-21-g975b

	[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^
	heads/lt/describe-7-g975b

Якщо для параметра --abbrev встановлено значення 0, команду можна використовувати для пошуку найближчого тегу без будь-якого суфікса:

	[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2
	tags/v1.0.0

Зверніть увагу, що суфікс, який ви отримаєте, якщо введете ці команди сьогодні, може бути довшим, ніж той, що бачив Лінус вище, коли він виконував ці команди, оскільки ваш репозиторій Git може мати нові коміти, імена об'єктів яких починаються з 975b, яких тоді не існувало, і суфікса "-g975b" може бути недостатньо для усунення неоднозначності цих комітів.


СТРАТЕГІЯ ПОШУКУ
----------------

Для кожного наданого коміту типу «приблизно», «git describe» спочатку шукатиме тег, який тегує саме цей коміт. Анотовані теги завжди матимуть перевагу над легкими тегами, а теги з новішими датами завжди матимуть перевагу над тегами зі старішими датами. Якщо знайдено точний збіг, буде виведено його назву, і пошук зупиниться.

Якщо точний збіг не знайдено, 'git describe' перегляне історію комітів, щоб знайти коміт-предок, який було позначено тегом. Тег предка буде виведено разом зі скороченням SHA-1 вхідного коміту. Якщо було вказано `--first-parent`, тоді під час обходу буде розглянуто лише першого батька кожного коміта.

Якщо під час перегляду було знайдено кілька тегів, то буде вибрано та виведено тег, який має найменшу кількість комітів, відмінних від вхідних. Тут найменша кількість різних комітів визначається як кількість комітів, яка буде відображена командою `git log tag..input`, і це буде найменша можлива кількість комітів.

ПОМИЛКИ
-------

Об'єкти дерева, а також об'єкти тегів, які не вказують на коміти, не можуть бути описані. Під час опису блобів, легкі теги, що вказують на блоби, ігноруються, але блоб все одно описується як <commit-ish>:<шлях>, незважаючи на те, що легкий тег є сприятливим.

GIT
---
Частина набору linkgit:git[1]
