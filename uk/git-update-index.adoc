git-update-index(1)
===================

НАЗВА
-----
git-update-index - Зареєструвати вміст файлу в робочому дереві в індексі


СИНОПСИС
--------
[verse]
'git update-index'
	     [--add] [--remove | --force-remove] [--replace]
	     [--refresh] [-q] [--unmerged] [--ignore-missing]
	     [(--cacheinfo <mode>,<object>,<file>)...]
	     [--chmod=(+|-)x]
	     [--[no-]assume-unchanged]
	     [--[no-]skip-worktree]
	     [--[no-]ignore-skip-worktree-entries]
	     [--[no-]fsmonitor-valid]
	     [--ignore-submodules]
	     [--[no-]split-index]
	     [--[no-|test-|force-]untracked-cache]
	     [--[no-]fsmonitor]
	     [--really-refresh] [--unresolve] [--again | -g]
	     [--info-only] [--index-info]
	     [-z] [--stdin] [--index-version <n>]
	     [--show-index-version]
	     [--verbose]
	     [--] [<file>...]

ОПИС
----
Змінює індекс. Кожен згаданий файл оновлюється в індексі, а будь-який стан «не об'єднано» або «потребує оновлення» очищується.

Дивіться також linkgit:git-add[1] для зручнішого способу виконання деяких найпоширеніших операцій з індексом.

Спосіб, у який 'git update-index' обробляє файли, про які йому повідомляють, можна змінити за допомогою різних опцій:

ОПЦІЇ
-----
--add::
	Якщо вказаного файлу ще немає в індексі, він додається. Поведінка за замовчуванням — ігнорувати нові файли.

--remove::
	Якщо вказаний файл є в індексі, але відсутній, він видаляється. Поведінка за замовчуванням — ігнорувати видалені файли.

--refresh::
	Переглядає поточний індекс та перевіряє, чи потрібні злиття або оновлення, перевіряючи інформацію stat().

-q::
Тихо. Якщо --refresh виявляє, що індекс потребує оновлення, поведінка за замовчуванням полягає в виведенні помилки. Ця опція змушує 'git update-index' продовжувати роботу в будь-якому разі.

--ignore-submodules::
	Не намагайтеся оновлювати підмодулі. Цей параметр враховується лише тоді, коли його передано раніше. --refresh.

--unmerged::
Якщо --refresh виявляє необ'єднані зміни в індексі, поведінка за замовчуванням полягає в виведенні помилки. Ця опція змушує 'git update-index' продовжувати роботу в будь-якому разі.

--ignore-missing::
	Ігнорує відсутні файли під час виконання команди --refresh

--cacheinfo <mode>,<object>,<path>::
--cacheinfo <mode> <object> <path>::
	Безпосередньо вставте вказану інформацію в індекс. Для зворотної сумісності ви також можете надати ці три аргументи як три окремі параметри, але новим користувачам рекомендується використовувати форму з одним параметром.

--index-info::
        Зчитування інформації індексу зі stdin.

--chmod=(+|-)x::
        Встановіть дозволи на виконання для оновлених файлів.

--[no-]assume-unchanged::
	Коли цей прапорець вказано, імена об'єктів, записані для шляхів, не оновлюються. Натомість, ця опція встановлює/скасовує біт "припускати без змін" для шляхів. Коли біт "припускати без змін" увімкнено, користувач обіцяє не змінювати файл і дозволяє Git вважати, що робочий файл дерева відповідає тому, що записано в індексі. Якщо ви хочете змінити робочий файл дерева, вам потрібно скинути цей біт, щоб повідомити Git. Це іноді корисно під час роботи з великим проектом на файловій системі, яка має дуже повільний системний виклик lstat(2) (наприклад, cifs).
+
Git завершить роботу (коректно), якщо йому потрібно буде змінити цей файл в індексі, наприклад, під час злиття в коміті; таким чином, якщо передбачуваний невідстежуваний файл буде змінено в основній частині програми, вам доведеться обробити ситуацію вручну.

--really-refresh::
	Подібно до `--refresh`, але перевіряє статистичну інформацію безумовно, незалежно від налаштування "припускати незмінність".

--[no-]skip-worktree::
	Коли вказано один із цих прапорців, імена об’єктів, записані для шляхів, не оновлюються. Натомість ці опції встановлюють та скидають значення біта «skip-worktree» для шляхів. Див. розділ «Біт пропуску робочого дерева» нижче для отримання додаткової інформації.


--[no-]ignore-skip-worktree-entries::
	Не видаляти записи skip-worktree (також відомі як "лише для індексу"), навіть якщо було вказано опцію `--remove`.

--[no-]fsmonitor-valid::
	Коли вказано один із цих прапорців, імена об’єктів, записані для шляхів, не оновлюються. Натомість ці опції встановлюють та скидають значення біта «fsmonitor valid» для шляхів. Див. розділ «Монітор файлової системи» нижче для отримання додаткової інформації.

-g::
--again::
	Запускає сам 'git update-index' для шляхів, записи індексу яких відрізняються від записів коміту `HEAD`.

--unresolve::
	Відновлює стан «не об’єднано» або «потребує оновлення» файлу під час об’єднання, якщо його було випадково очищено.

--info-only::
	Не створюйте об'єкти в базі даних об'єктів для всіх аргументів <file>, що йдуть після цього прапорця; просто вставте їхні ідентифікатори об'єктів в індекс.

--force-remove::
	Видалити файл з індексу, навіть якщо в робочому каталозі все ще є такий файл. (Має на увазі --remove.)

--replace::
	За замовчуванням, коли файл `path` існує в індексі, 'git update-index' відхиляє спробу додати `path/file`. Аналогічно, якщо файл `path/file` існує, файл `path` не може бути доданий. З прапорцем --replace існуючі записи, що конфліктують із записом, що додається, автоматично видаляються з попередженнями.

--stdin::
	Замість того, щоб брати список шляхів з командного рядка, зчитайте список шляхів зі стандартного вводу. Шляхи за замовчуванням розділяються символом LF (тобто один шлях на рядку).

--verbose::
	Повідомляйте про те, що додається та видаляється з індексу.

--index-version <n>::
	Запишіть результуючий індекс у вказаній версії формату на диску. Підтримувані версії: 2, 3 та 4. Поточна версія за замовчуванням — 2 або 3, залежно від того, чи використовуються додаткові функції, такі як `git add -N`. За допомогою `--verbose` також повідомте версію, яку використовує файл індексу до та після цієї команди.
+
Версія 4 виконує просте стиснення шляхів, яке зменшує розмір індексу на 30%-50% у великих репозиторіях, що призводить до швидшого завантаження. Git підтримує його з версії 1.8.0, випущеної в жовтні 2012 року, а його підтримка була додана до libgit2 у 2016 році та до JGit у 2020 році. У старіших версіях цієї сторінки довідки його називали "відносно молодим", але в наші дні його слід вважати зрілою технологією.

--show-index-version::
	Повідомити версію формату індексу, що використовується файлом індексу на диску. Див. `--index-version` вище.

-z::
	Має сенс лише з `--stdin` або `--index-info`; шляхи розділяються символом NUL замість LF.

--split-index::
--no-split-index::
	Увімкнути або вимкнути режим розділеного індексу. Якщо режим розділеного індексу вже ввімкнено та знову задано параметр `--split-index`, усі зміни в $GIT_DIR/index будуть повернуті назад до спільного файлу індексу.
+
Ці опції набувають чинності незалежно від значення змінної конфігурації `core.splitIndex` (див. linkgit:git-config[1]). Але попередження видається, коли зміна суперечить налаштованому значенню, оскільки налаштоване значення набуде чинності наступного разу, коли індекс буде зчитуватися, і це скасує передбачуваний ефект опції.

--untracked-cache::
--no-untracked-cache::
	Увімкнути або вимкнути функцію кешування без відстеження. Будь ласка, скористайтеся параметром `--test-untracked-cache` перед її ввімкненням.
+
Ці опції набувають чинності незалежно від значення змінної конфігурації `core.untrackedCache` (див. linkgit:git-config[1]). Але попередження видається, коли зміна суперечить налаштованому значенню, оскільки налаштоване значення набуде чинності наступного разу, коли індекс буде зчитуватися, і це скасує передбачуваний ефект опції.

--test-untracked-cache::
	Виконуйте тести лише в робочому каталозі, щоб переконатися, що можна використовувати невідстежуваний кеш. Вам потрібно буде вручну ввімкнути невідстежуваний кеш за допомогою `--untracked-cache` або `--force-untracked-cache` або змінної конфігурації `core.untrackedCache`, якщо ви дійсно хочете його використовувати. Якщо тест не пройшов, код виходу дорівнює 1, і повідомлення пояснює, що не працює, як потрібно, інакше код виходу дорівнює 0, і друкується OK.

--force-untracked-cache::
	Те саме, що й `--untracked-cache`. Забезпечено зворотну сумісність зі старими версіями Git, де `--untracked-cache` раніше означало `--test-untracked-cache`, але ця опція безумовно вмикає розширення.

--fsmonitor::
--no-fsmonitor::
	Увімкнути або вимкнути функцію моніторингу файлової системи. Ці опції діють незалежно від значення змінної конфігурації `core.fsmonitor` (див. linkgit:git-config[1]). Але попередження видається, коли зміна суперечить налаштованому значенню, оскільки налаштоване значення набуде чинності наступного разу, коли індекс буде зчитуватися, і це скасує передбачуваний ефект опції.

\--::
	Не інтерпретуйте жодних додаткових аргументів як варіанти.

<file>::
	Файли, з якими потрібно працювати. Зверніть увагу, що файли, що починаються з '.', відкидаються. Це стосується `./file` та `dir/./file`. Якщо ви цього не хочете, використовуйте чистіші назви. Те саме стосується каталогів, що закінчуються на '/', та шляхів з '//'

USING --REFRESH
---------------
`--refresh` не обчислює новий sha1-файл і не оновлює індекс для змін режиму/вмісту. Але він *дійсно* «повторно зіставляє» статистичну інформацію файлу з індексом, щоб ви могли оновити індекс для файлу, який не був змінений, але де запис статистики застарів.

Наприклад, вам потрібно буде зробити це після виконання команди «git read-tree», щоб пов’язати деталі індексу статистики з відповідними файлами.

USING --CACHEINFO OR --INFO-ONLY
--------------------------------
`--cacheinfo` використовується для реєстрації файлу, який не знаходиться в поточному робочому каталозі. Це корисно для об'єднання з мінімальним отриманням.

Щоб уявити, що у вас є файл за адресою path з mode та sha1, скажімо:

----------------
$ git update-index --add --cacheinfo <mode>,<sha1>,<path>
----------------

`--info-only` використовується для реєстрації файлів без розміщення їх у базі даних об'єктів. Це корисно для репозиторіїв, що відображають лише статус.

Як `--cacheinfo`, так і `--info-only` поводяться подібно: індекс оновлюється, але база даних об'єктів не оновлюється. `--cacheinfo` корисний, коли об'єкт є в базі даних, але файл недоступний локально. `--info-only` корисний, коли файл доступний, але ви не хочете оновлювати базу даних об'єктів.


USING --INDEX-INFO
------------------

`--index-info` — це потужніший механізм, який дозволяє вам передавати кілька визначень записів зі стандартного вводу, розроблений спеціально для скриптів. Він може приймати вхідні дані трьох форматів:

    . режим SP тип SP sha1 шлях TAB
+
Цей формат призначений для запису виводу `git ls-tree` в індекс.

    . режим SP sha1 етап SP шлях TAB
+
Цей формат призначений для розміщення етапів вищого порядку в індексному файлі та відповідає виводу 'git ls-files --stage'.

    . режим SP sha1 шлях TAB
+
Цей формат більше не створюється жодною командою Git, але підтримується і продовжуватиме підтримуватися командою `update-index --index-info`.

Щоб розмістити запис вищого рівня до індексу, шлях спочатку слід видалити, вказавши для шляху запис mode=0, а потім вказавши необхідні вхідні рядки у третьому форматі.

Наприклад, починаючи з цього індексу:

------------
$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz
------------

Ви можете передати наступні дані до `--index-info`:

------------
$ git update-index --index-info
0 0000000000000000000000000000000000000000	frotz
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1	frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2	frotz
------------

Перший рядок вхідних даних містить значення 0 як режим видалення шляху; SHA-1 не має значення, головне, щоб він був правильно відформатований. Потім другий і третій рядки містять записи етапу 1 та етапу 2 для цього шляху. Після вищезазначеного ми отримаємо ось що:

------------
$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1	frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2	frotz
------------


ВИКОРИСТАННЯ БІТА ``ASSUME UNCHANGED''
--------------------------------------

Багато операцій у Git залежать від вашої файлової системи для ефективної реалізації `lstat(2)`, щоб інформацію `st_mtime` для робочих файлів дерева можна було легко перевірити, щоб побачити, чи змінився вміст файлу порівняно з версією, записаною в індексному файлі. На жаль, деякі файлові системи мають неефективний `lstat(2)`. Якщо ваша файлова система є однією з них, ви можете встановити біт "assume unchanged" для шляхів, які ви не змінювали, щоб Git не виконував цю перевірку. Зауважте, що встановлення цього біта для шляху не означає, що Git перевірятиме вміст файлу, щоб побачити, чи змінився він – це змушує Git пропустити будь-яку перевірку та вважати, що він *не* змінився. Коли ви вносите зміни до робочих файлів дерева, ви повинні явно повідомити Git про це, видаливши біт "assume unchanged", до або після їх зміни.

Щоб встановити біт "припускати незмінним", використовуйте опцію `--assume-unchanged`. Щоб скасувати встановлення, використовуйте `--no-assume-unchanged`. Щоб побачити, для яких файлів встановлено біт "припускати незмінним", використовуйте `git ls-files -v` (див. linkgit:git-ls-files[1]).

Команда перевіряє змінну конфігурації `core.ignorestat`. Коли це значення є true, шляхи, оновлені за допомогою `git update-index paths...`, та шляхи, оновлені іншими командами Git, які оновлюють як індекс, так і робоче дерево (наприклад, 'git apply --index', 'git checkout-index -u' та 'git read-tree -u'), автоматично позначаються як "припускати без змін". Зверніть увагу, що біт "припускати без змін" *не* встановлюється, якщо `git update-index --refresh` знаходить, що файл робочого дерева відповідає індексу (використовуйте `git update-index --really-refresh`, якщо ви хочете позначити їх як "припускати без змін").

Іноді користувачі плутають біт assume-unchanged з бітом skip-worktree. Див. останній абзац розділу «Skip-worktree bit» нижче для пояснення відмінностей.


ПРИКЛАДИ
--------
Щоб оновити та оновити лише ті файли, які вже витягнуті на чергу:

----------------
$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh
----------------

На неефективній файловій системі з встановленим `core.ignorestat`::
+
------------
$ git update-index --really-refresh              <1>
$ git update-index --no-assume-unchanged foo.c   <2>
$ git diff --name-only                           <3>
$ edit foo.c
$ git diff --name-only                           <4>
M foo.c
$ git update-index foo.c                         <5>
$ git diff --name-only                           <6>
$ edit foo.c
$ git diff --name-only                           <7>
$ git update-index --no-assume-unchanged foo.c   <8>
$ git diff --name-only                           <9>
M foo.c
------------
+
<1> змушує lstat(2) встановлювати біти "припускати незмінність" для шляхів, що відповідають індексу.
<2> позначте шлях для редагування.
<3> Це виконує lstat(2) та знаходить індекс, що відповідає шляху.
<4> Це виконує lstat(2) і знаходить, що індекс *не* відповідає шляху.
<5> реєстрація нової версії для наборів індексів, біт "припускати незмінність".
<6> і вважається, що він не змінюється.
<7> навіть після того, як ви його відредагуєте.
<8> ви можете сказати про зміни після того, як вони сталися.
<9> тепер він перевіряє за допомогою lstat(2) і виявляє, що його було змінено.


ПРОПУСКАЙТЕ РІЗНИЦЮ ДЛЯ РОБОЧОГО ДЕРЕВА
---------------------------------------

Біт пропуску робочого дерева можна визначити одним (довгим) реченням: наказати git уникати запису файлу в робочий каталог, коли це можливо, та розглядати файл як незмінний, коли його немає в робочому каталозі.

Зверніть увагу, що не всі команди git звертатимуть увагу на цей біт, а деякі підтримують його лише частково.

Прапорці update-index та можливості read-tree, пов'язані з бітом skip-worktree, з'явилися раніше, ніж команда linkgit:git-sparse-checkout[1], яка забезпечує набагато простіший спосіб налаштування та обробки бітів skip-worktree. Якщо ви хочете зменшити обсяг вашого робочого дерева до обробки лише підмножини файлів у репозиторії, ми наполегливо рекомендуємо використовувати linkgit:git-sparse-checkout[1] замість низькорівневих примітивів update-index та read-tree.

Основне призначення біта skip-worktree — увімкнути розріджене отримання, тобто мати робочі каталоги лише з підмножиною шляхів. Коли біт skip-worktree встановлено, команди Git (такі як `switch`, `pull`, `merge`) уникатимуть запису в ці файли. Однак, ці команди іноді все одно записуватимуть ці файли у важливих випадках, таких як конфлікти під час злиття або перебазування. Команди Git також уникатимуть трактування відсутності таких файлів як навмисного видалення; наприклад, `git add -u` не індексуватиме видалення для цих файлів, а `git commit -a` також не створить коміт, видаляючи їх.

Хоча цей біт схожий на біт assume-unchanged, його мета інша. Біт assume-unchanged призначений для того, щоб файл залишався в робочому дереві, але Git пропускав перевірку його на наявність змін і припускав, що файл не був змінений (хоча якщо він може визначити без повідомлення про файл, що він змінився, він може записати зміни). skip-worktree повідомляє Git про необхідність ігнорувати відсутність файлу, уникати його оновлення, коли це можливо, за допомогою команд, які зазвичай оновлюють більшу частину робочого каталогу (наприклад, `checkout`, `switch`, `pull` тощо), і не записувати його відсутність у коммітах. Зверніть увагу, що в розріджених визованих файлах (налаштованих за допомогою `git sparse-checkout` або шляхом налаштування core.sparseCheckout на true), якщо файл позначено як skip-worktree в індексі, але знайдено в робочому дереві, Git очистить біт skip-worktree для цього файлу.

РОЗДІЛЕНИЙ ІНДЕКС
-----------------

Цей режим розроблено для репозиторіїв з дуже великими індексами та спрямований на скорочення часу, необхідного для багаторазового запису цих індексів.

У цьому режимі індекс розділяється на два файли: $GIT_DIR/index та $GIT_DIR/sharedindex.<SHA-1>. Зміни накопичуються в $GIT_DIR/index, розділеному індексі, тоді як спільний файл індексу містить усі записи індексу та залишається незмінним.

Усі зміни в розділеному індексі переносяться назад до спільного файлу індексу, коли кількість записів у розділеному індексі досягає рівня, визначеного змінною конфігурації splitIndex.maxPercentChange (див. linkgit:git-config[1]).

Щоразу, коли створюється новий спільний індексний файл, старі спільні індексні файли видаляються, якщо час їхньої модифікації старший за значення, вказане змінною конфігурації splitIndex.sharedIndexExpire (див. linkgit:git-config[1]).

Щоб уникнути видалення спільного індексного файлу, який все ще використовується, час його модифікації оновлюється до поточного часу щоразу, коли створюється або зчитується новий розділений індекс на основі спільного індексного файлу.

НЕВІДСЛІДЖЕНИЙ КЕШ
------------------

Цей кеш призначений для пришвидшення виконання команд, що передбачають визначення невідстежуваних файлів, таких як `git status`.

Ця функція працює шляхом запису часу зміни (mtime) робочих каталогів дерева, а потім пропускає читання каталогів та виклики статистичних даних для файлів у тих каталогах, час зміни яких не змінився. Щоб це працювало, базова операційна система та файлова система повинні змінити поле `st_mtime` каталогів, якщо файли в каталозі додаються, змінюються або видаляються.

Ви можете перевірити, чи підтримує це файлова система, за допомогою опції `--test-untracked-cache`. Опція `--untracked-cache` раніше неявно виконувала цю перевірку в старіших версіях Git, але це вже не так.

Якщо ви хочете ввімкнути (або вимкнути) цю функцію, простіше використовувати змінну конфігурації `core.untrackedCache` (див. linkgit:git-config[1]), ніж використовувати опцію `--untracked-cache` для `git update-index` у кожному репозиторії, особливо якщо ви хочете зробити це для всіх репозиторіїв, які ви використовуєте, оскільки ви можете встановити змінну конфігурації на `true` (або `false`) у вашому `$HOME/.gitconfig` лише один раз, і це вплине на всі репозиторії, до яких ви торкаєтеся.

Коли змінюється змінна конфігурації `core.untrackedCache`, невідстежуваний кеш додається до індексу або видаляється з нього наступного разу, коли команда зчитує індекс; тоді як коли використовуються `--[no-|force-]untracked-cache`, невідстежуваний кеш негайно додається до індексу або видаляється з нього.

До версії 2.17 у невідстежуваному кеші була помилка, через яку заміна каталогу символічним посиланням на інший каталог могла призвести до неправильного відображення файлів, що відстежуються git, як невідстежуваних. Див. коміт "status: add a failing test showing a core.untrackedCache bug" до git.git. Обхідний шлях для цього (і це може спрацювати для інших невиявлених помилок у майбутньому):

----------------
$ git -c core.untrackedCache=false status
----------------

Також було показано, що ця помилка впливає на випадки заміни каталогу файлом без символічних посилань, коли йдеться про внутрішні структури невідстежуваного кешу, але не було зареєстровано жодного випадку, коли це призводило до неправильного виводу "статус git".

Також трапляються випадки, коли існуючі індекси, написані версіями git до версії 2.17, посилатимуться на каталоги, яких більше не існує, що потенційно призведе до появи багатьох попереджень «не вдалося відкрити каталог» у «статусі git». Це нові попередження для існуючих проблем, які раніше були непомітно відкинуті.

Як і у випадку з помилкою, описаною вище, рішенням є одноразове виконання "git status" з `core.untrackedCache=false`, щоб видалити залишки поганих даних.

МОНІТОР ФАЙЛОВОЇ СИСТЕМИ
------------------------

Ця функція призначена для пришвидшення операцій git для репозиторіїв з великими робочими каталогами.

Це дозволяє git працювати разом із монітором файлової системи (див. linkgit:git-fsmonitor{litdd}daemon[1] та розділ "fsmonitor-watchman" у linkgit:githooks[5]), який може інформувати його про те, які файли були змінені. Це дозволяє git уникнути необхідності використовувати lstat() для кожного файлу, щоб знайти змінені файли.

При використанні разом із невідстежуваним кешем це може додатково покращити продуктивність, уникаючи витрат на сканування всього робочого каталогу в пошуках нових файлів.

Якщо ви хочете ввімкнути (або вимкнути) цю функцію, простіше використовувати змінну конфігурації `core.fsmonitor` (див. linkgit:git-config[1]), ніж використовувати опцію `--fsmonitor` для `git update-index` у кожному репозиторії, особливо якщо ви хочете зробити це для всіх репозиторіїв, які ви використовуєте, оскільки ви можете встановити змінну конфігурації у вашому `$HOME/.gitconfig` лише один раз, і вона вплине на всі репозиторії, до яких ви торкаєтеся.

Коли змінюється змінна конфігурації `core.fsmonitor`, монітор файлової системи додається до індексу або видаляється з нього під час наступного зчитування індексу командою. Коли використовуються `--[no-]fsmonitor`, монітор файлової системи негайно додається до індексу або видаляється з нього.

КОНФІГУРАЦІЯ
------------

Команда враховує змінну конфігурації `core.filemode`. Якщо ваш репозиторій знаходиться на файловій системі, біти виконуваного файлу якої ненадійні, для неї слід встановити значення 'false' (див. linkgit:git-config[1]). Це призведе до того, що команда ігноруватиме відмінності в режимах файлів, записаних в індексі, та режимі файлу на файловій системі, якщо вони відрізняються лише бітом виконуваного файлу. У такій невдалій файловій системі вам може знадобитися використовувати 'git update-index --chmod='.

Аналогічно, якщо змінна конфігурації `core.symlinks` має значення 'false' (див. linkgit:git-config[1]), символічні посилання перевіряються як звичайні файли, і ця команда не змінює режим записаного файлу з символічного посилання на звичайний файл.

Команда перевіряє змінну конфігурації `core.ignorestat`. Див. розділ «Використання біта «припускати незмінним»» вище.

Команда також перевіряє змінну конфігурації `core.trustctime`. Це може бути корисним, коли час зміни inode регулярно змінюється чимось поза Git (сканери файлової системи та системи резервного копіювання використовують ctime для позначення оброблених файлів) (див. linkgit:git-config[1]).

Розширення кешу без відстеження можна ввімкнути за допомогою змінної конфігурації `core.untrackedCache` (див. linkgit:git-config[1]).

НОТАТКИ
-------

Користувачі часто намагаються використовувати біти assume-unchanged та skip-worktree, щоб вказати Git ігнорувати зміни у файлах, що відстежуються. Це не працює належним чином, оскільки Git все ще може перевіряти файли робочого дерева за індексом під час виконання певних операцій. Загалом, Git не надає способу ігнорувати зміни у файлах, що відстежуються, тому рекомендуються альтернативні рішення.

Наприклад, якщо файл, який ви хочете змінити, є певним конфігураційним файлом, репозиторій може містити зразок конфігураційного файлу, який потім можна скопіювати в ігнороване ім'я та змінити. Репозиторій може навіть містити скрипт для обробки зразка файлу як шаблону, автоматично змінюючи та копіюючи його.

ДИВ. ТАКОЖ
----------
linkgit:git-config[1], linkgit:git-add[1], linkgit:git-ls-files[1]

GIT
---
Частина набору linkgit:git[1]
