git-checkout-index(1)
=====================

НАЗВА
-----
git-checkout-index - Копіювати файли з індексу до робочого дерева


СИНОПСИС
--------
[verse]
'git checkout-index' [-u] [-q] [-a] [-f] [-n] [--prefix=<string>]
		   [--stage=<number>|all]
		   [--temp]
		   [--ignore-skip-worktree-bits]
		   [-z] [--stdin]
		   [--] [<file>...]

ОПИС
----
Копіює всі перелічені файли з індексу до робочого каталогу (не перезаписуючи існуючі файли).

ОПЦІЇ
-----
-u::
--index::
	оновити статистичну інформацію для витягнутих записів у файлі індексу.

-q::
--quiet::
	не повідомляти про існування файлів або їх відсутність в індексі

-f::
--force::
	примусово перезаписує існуючі файли

-a::
--all::
	перевіряє всі файли в індексі, окрім тих, для яких встановлено біт skip-worktree (див. `--ignore-skip-worktree-bits`). Не може використовуватися разом із явними іменами файлів.

-n::
--no-create::
	Не виводити на редагування нові файли, оновлювати лише вже виведені файли.

--prefix=<string>::
	Під час створення файлів додайте перед рядком <string> (зазвичай каталог, що включає завершальну символ /)

--stage=<number>|all::
	Замість отримання необ’єднаних записів, скопіюйте файли з іменованого етапу. <число> має бути від 1 до 3. Примітка: --stage=all автоматично означає --temp.

--temp::
	Замість копіювання файлів до робочого каталогу, запишіть вміст у тимчасові файли. Тимчасові асоціації імен будуть записані у stdout.

--ignore-skip-worktree-bits::
	Перевірити всі файли, включаючи ті, для яких встановлено біт skip-worktree.

--stdin::
	Замість того, щоб брати список шляхів з командного рядка, зчитайте список шляхів зі стандартного вводу. Шляхи за замовчуванням розділяються символом LF (тобто один шлях на рядок).

-z::
	Має сенс лише з `--stdin`; шляхи розділяються символом NUL замість LF.

\--::
	Не інтерпретуйте жодних додаткових аргументів як варіанти.

Порядок прапорів раніше мав значення, але зараз ні.

Просто виконання `git checkout-index` нічого не дає. Ви, мабуть, мали на увазі `git checkout-index -a`. А якщо ви хочете примусово це зробити, вам знадобиться `git checkout-index -f -a`.

Тут метою не є інтуїтивність. Метою є повторюваність. Причина поведінки «відсутність аргументів означає відсутність роботи» полягає в тому, що зі скриптів ви повинні мати змогу робити:

----------------
$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --
----------------

що призведе до заміни всіх існуючих файлів `*.h` їхніми кешованими копіями. Якщо порожній командний рядок означатиме "all", то це призведе до примусового оновлення всього індексу, що не було метою. Але оскільки 'git checkout-index' приймає --stdin, було б швидше використовувати:

----------------
$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin
----------------

`--` — це гарна ідея, коли ви знаєте, що решта будуть іменами файлів; це запобіжить проблемам з іменем файлу, наприклад, `-a`. Використання `--`, ймовірно, є гарною політикою в скриптах.


Використання --temp або --stage=all
-----------------------------------
Коли використовується `--temp` (або це мається на увазі через `--stage=all`), 'git checkout-index' створить тимчасовий файл для кожного запису індексу, що витягується. Індекс не оновлюватиметься статистичною інформацією. Ці опції можуть бути корисними, якщо викликаючій функції потрібні всі етапи всіх необ'єднаних записів, щоб необ'єднані файли можна було обробити зовнішнім інструментом об'єднання.

Список буде записано на stdout, що забезпечить зв'язок тимчасових імен файлів з іменами шляхів, що відстежуються. Формат списку має два варіанти:

    . тимчасова назва TAB шлях RS
+
Перший формат використовується, коли `--stage` пропущено або відрізняється від `--stage=all`. Поле tempname – це тимчасова назва файлу, що містить вміст файлу, а path – це відстежувана назва шляху в індексі. Виводяться лише запитувані записи.

    . stage1temp SP stage2temp SP stage3tmp TAB path RS
+
Другий формат використовується, коли `--stage=all`. Три тимчасові поля етапу (stage1temp, stage2temp, stage3temp) містять назву тимчасового файлу, якщо в індексі є запис етапу, або `.`, якщо запису етапу немає. Шляхи, які мають лише запис етапу 0, завжди будуть пропущені з виводу.

В обох форматах RS (роздільник записів) за замовчуванням є символом нового рядка, але буде нульовим байтом, якщо в командному рядку було передано параметр -z. Тимчасові імена файлів завжди є безпечними рядками; вони ніколи не міститимуть роздільників каталогів або пробіли. Поле шляху завжди відносне до поточного каталогу, а тимчасові імена файлів завжди відносні до каталогу верхнього рівня.

Якщо об'єкт, що копіюється у тимчасовий файл, є символічним посиланням, вміст посилання буде записано у звичайний файл. Використання цієї інформації залежить від кінцевого користувача або Porcelain.


ПРИКЛАДИ
--------
Оновити та оновити лише файли, які вже витягнуті на редагування::
+
----------------
$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh
----------------

Використання 'git checkout-index' для "експорту всього дерева"::
	Можливість використання префікса по суті спрощує використання 'git checkout-index' як функції "експорт як дерево". Просто зчитайте потрібне дерево в індекс і виконайте:
+
----------------
$ git checkout-index --prefix=git-export-dir/ -a
----------------
+
Команда `git checkout-index` "експортує" індекс у вказаний каталог.
+
Кінцевий символ "/" є важливим. Експортоване ім'я буквально просто починається з вказаного рядка. Порівняйте це з наступним прикладом.

Експорт файлів з префіксом::
+
----------------
$ git checkout-index --prefix=.merged- Makefile
----------------
+
Це перевірить поточну кешовану копію `Makefile` у файл `.merged-Makefile`.

GIT
---
Частина набору linkgit:git[1]
