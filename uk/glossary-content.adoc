[[def_alternate_object_database]]альтернативна база даних об'єктів::
	Через механізм альтернатив, <<def_repository,repository>> може успадковувати частину своєї <<def_object_database,object database>> від іншої об'єктної бази даних, яка називається "альтернативною".

[[def_bare_repository]]голий репозиторій::
	Голий репозиторій зазвичай є відповідним чином названим <<def_directory,directory>> із суфіксом `.git`, який не має локально витягнутої копії жодного з файлів під контролем версій. Тобто, всі адміністративні та керуючі файли Git, які зазвичай присутні в прихованому підкаталозі `.git`, безпосередньо присутні в каталозі `repository.git`, і жодні інші файли не присутні та не витягнуті. Зазвичай видавці публічних репозиторіїв роблять доступними голі репозиторії.

[[def_blob_object]]об'єкт blob::
	Нетипізований <<def_object,object>>, наприклад, вміст файлу.

[[def_branch]]гілка::
	«Гілка» – це лінія розробки. Найновіший <<def_commit,commit>> на гілці називається верхівкою цієї гілки. Верхівка гілки називається <<def_ref,referenced>> гілкою <<def_head,head>>, яка рухається вперед, коли на ній виконується додаткова розробка. Одна гілка Git <<def_repository,repository>> може відстежувати довільну кількість гілок, але ваша <<def_working_tree,working tree>> пов'язана лише з однією з них («поточною» або «використаною» гілкою), а <<def_HEAD,HEAD>> вказує на цю гілку.

[[def_cache]]кеш::
	Застаріло для: <<def_index,index>>.

[[def_chain]]ланка::
	Список об'єктів, де кожен <<def_object,object>> у списку містить посилання на свого наступника (наприклад, наступником <<def_commit,commit>> може бути один з його <<def_parent,parents>>).

[[def_changeset]]набір змін::
	BitKeeper/cvsps використовуються для визначення "<<def_commit,commit>>". Оскільки Git не зберігає зміни, а зберігає стани, використання терміна "набори змін" з Git насправді не має сенсу.

[[def_checkout]]оформлення замовлення::
	Дія оновлення всього або частини <<def_working_tree,working tree>> за допомогою об'єкта <<def_tree_object,tree>> або <<def_blob_object,blob>> з бази даних <<def_object_database,object>>, та оновлення <<def_index,index>> та <<def_HEAD,HEAD>>, якщо все робоче дерево було спрямовано на нову <<def_branch,branch>>.

[[def_cherry-picking]]вибірковий підхід::
	На жаргоні <<def_SCM,SCM>> «вибір cherry pick» означає вибір підмножини змін із серії змін (зазвичай комітів) та запис їх як нової серії змін поверх іншої кодової бази. У Git це виконується командою «git cherry-pick», щоб витягти зміну, внесену існуючим <<def_commit,commit>>, та записати її на основі кінчика поточної <<def_branch,branch>> як новий коміт.

[[def_clean]]чистий::
	Дерево <<def_working_tree,working_tree>> вважається чистим, якщо воно відповідає <<def_revision,revision>>, на яке посилається поточне <<def_head,head>>. Див. також "<<def_dirty,dirty>>".

[[def_commit]]коміт::
	Як іменник: Окремий момент в історії Git; вся історія проекту представлена як набір взаємопов'язаних комітів. Слово "commit" часто використовується Git там, де інші системи контролю версій використовують слова "revision" або "version". Також використовується як скорочене позначення для <<def_commit_object,commit object>>.
+
Як дієслово: Дія зберігання нового знімка стану проєкту в історії Git шляхом створення нового коміту, що представляє поточний стан <<def_index,index>>, та переміщення <<def_HEAD,HEAD>> до нового коміту.

[[def_commit_graph_general]]концепція, представлення та використання графа комітів::
	Синонім структури <<def_DAG,DAG>>, утвореної комітами в базі даних об'єктів, <<def_ref,referenced>> – підказками гілок, використовуючи <<def_chain,chain>> пов'язаних комітів. Ця структура є остаточним графом комітів. Граф можна представити іншими способами, наприклад, файлом <<def_commit_graph_file,"commit-graph">>.

[[def_commit_graph_file]]файл commit-graph::
	Файл "commit-graph" (зазвичай через дефіс) є додатковим представленням <<def_commit_graph_general,commit graph>>, яке пришвидшує прогулянки графом комітів. Файл "commit-graph" зберігається або в каталозі .git/objects/info, або в каталозі info альтернативної бази даних об'єктів.

[[def_commit_object]]об'єкт commit::
	Об'єкт <<def_object,object>>, що містить інформацію про певний <<def_revision,revision>>, такий як <<def_parent,parents>>, комітер, автор, дата та об'єкт <<def_tree_object,tree>>, що відповідає верхньому <<def_directory,directory>> збереженої ревізії.

[[def_commit-ish]]коміт-подібний (також комітний)::
	Об'єкт <<def_commit_object,commit>> або <<def_object,object>>, який можна рекурсивно <<def_dereference,dereferenced>> перевести в об'єкт commit. Наступні об'єкти є аналогами commit: об'єкт commit, об'єкт <<def_tag_object,tag>>, що вказує на об'єкт commit, об'єкт tag, що вказує на об'єкт tag, що вказує на об'єкт commit тощо.

[[def_core_git]]ядро Git::
	Фундаментальні структури даних та утиліти Git. Надає доступ лише до обмежених інструментів керування вихідним кодом.

[[def_DAG]]DAG::
	Орієнтований ациклічний граф. Об'єкти <<def_commit_object,commit>> утворюють орієнтований ациклічний граф, оскільки вони мають батьків (орієнтовані), а граф об'єктів commit є ациклічним (немає <<def_chain,chain>>, який починається та закінчується тим самим <<def_object,object>>).

[[def_dangling_object]]підвішений предмет::
	Об'єкт <<def_unreachable_object,недосяжний>>, який не є <<def_reachable,досяжним>> навіть з інших недосяжних об'єктів; висячий об'єкт не має посилань на нього з жодного посилання або <<def_object,object>> в <<def_repository,repository>>.

[[def_dereference]]розіменування::
	Посилання на <<def_symref,символічне посилання>>: дія доступу до <<def_ref,посилання>>, на яке вказує символічне посилання. Рекурсивне розіменування включає повторення вищезгаданого процесу для результуючого посилання, доки не буде знайдено несимволічне посилання.
+
Посилання на об'єкт <<def_tag_object,tag>>: дія доступу до <<def_object,object>>, на який вказує тег. Теги рекурсивно розіменуються шляхом повторення операції з результуючим об'єктом, доки результат не матиме або заданого <<def_object_type,object type>> (де це можливо), або будь-якого типу об'єкта, відмінного від "tag". Синонімом "рекурсивного розіменування" в контексті тегів є "<<def_peel,peel>>".
+
Посилання на об'єкт <<def_commit_object,commit>>: дія доступу до об'єкта дерева коміту. Коміти не можна рекурсивно розіменувати.
+
Якщо не зазначено інше, «рознайменування», як воно використовується в контексті команд або протоколів Git, є неявно рекурсивним.

[[def_detached_HEAD]]відокремлена ГОЛОВА::
	Зазвичай, <<def_HEAD,HEAD>> зберігає назву <<def_branch,branch>>, а команди, що працюють з історією, яку представляє HEAD, працюють з історією, що веде до вершини гілки, на яку вказує HEAD. Однак, Git також дозволяє вам <<def_checkout,check out>> довільну <<def_commit,commit>>, яка не обов'язково є вершиною якоїсь конкретної гілки. HEAD у такому стані називається "відокремленим".
+
Зверніть увагу, що команди, які працюють з історією поточної гілки (наприклад, `git commit` для створення нової історії поверх неї), все ще працюють, навіть коли HEAD від'єднаний. Вони оновлюють HEAD, щоб він вказував на кінець оновленої історії, не впливаючи на жодну гілку. Команди, які оновлюють або запитують інформацію _про_ поточну гілку (наприклад, `git branch --set-upstream-to`, яка встановлює, з якою гілкою віддаленого відстеження інтегрується поточна гілка), очевидно, не працюють, оскільки в цьому стані немає (реальної) поточної гілки, про яку можна запитати.

[[def_directory]]каталог::
	Список, який ви отримуєте за допомогою "ls" :-)

[[def_dirty]]dirty::
	<<def_working_tree,working tree>> називається "брудним", якщо воно містить модифікації, які не були <<def_commit,committed>> внесені до поточної <<def_branch,branch>>.

[[def_evil_merge]]злиття зла::
	Злісне злиття — це <<def_merge,merge>>, яке вносить зміни, що не відображаються в жодному <<def_parent,parent>>.

[[def_fast_forward]]перемотування вперед::
	Перемотування вперед — це особливий тип <<def_merge,merge>>, де у вас є <<def_revision,revision>>, і ви "зливаєте" зміни з іншої <<def_branch,branch>>, які є нащадком вашої. У такому випадку ви не створюєте новий <<def_merge,merge>> <<def_commit,commit>>, а просто оновлюєте свою гілку, щоб вона вказувала на ту саму ревізію, що й гілка, яку ви зливаєте. Це часто трапляється на гілці <<def_remote_tracking_branch,remote-tracking>> віддаленого <<def_repository,repository>>.

[[def_fetch]]принести::
	Отримання <<def_branch,branch>> означає отримання <<def_head_ref,head ref>> гілки з віддаленого <<def_repository,repository>>, щоб знайти, які об'єкти відсутні в локальній <<def_object_database,object database>>, та отримати їх. Див. також linkgit:git-fetch[1].

[[def_file_system]]файлова система::
	Лінус Торвальдс спочатку розробляв Git як файлову систему простору користувача, тобто інфраструктуру для зберігання файлів і каталогів. Це забезпечило ефективність і швидкість Git.

[[def_git_archive]]Git-архів::
	Синонім до <<def_repository,repository>> (для архітекторів).

[[def_gitfile]]gitfile::
	Звичайний файл `.git` у корені робочого дерева, який вказує на каталог, що є справжнім репозиторієм. Інструкції з правильного використання див. у linkgit:git-worktree[1] або linkgit:git-submodule[1]. Синтаксис див. у linkgit:gitrepository-layout[5].

[[def_grafts]]трансплантати::
	Графти дозволяють об'єднати дві інакше різні лінії розробки, записуючи фальшиву інформацію про походження для комітів. Таким чином, ви можете змусити Git вдавати, що набір <<def_parent,parents>> <<def_commit,commit>> відрізняється від того, що було записано під час створення коміту. Налаштовується через файл `.git/info/grafts`.
+
Зверніть увагу, що механізм пересадки застарів і може призвести до проблем із передачею об'єктів між репозиторіями; див. linkgit:git-replace[1] для більш гнучкої та надійної системи для виконання того ж завдання.

[[def_hash]]хеш::
	У контексті Git, синонім <<def_object_name,object name>>.

[[def_head]]голова::
	Посилання <<def_ref,іменоване>> на <<def_commit,commit>> наприкінці <<def_branch,branch>>. Заголовки зберігаються у файлі в каталозі `$GIT_DIR/refs/heads/`, за винятком випадків використання упакованих посилань. (Див. linkgit:git-pack-refs[1].)

[[def_HEAD]]ГОЛОВА::
	Поточна <<def_branch,branch>>. Детальніше: Ваше <<def_working_tree, робоче дерево>> зазвичай походить від стану дерева, на яке посилається HEAD. HEAD – це посилання на один з <<def_head,heads>> у вашому репозиторії, за винятком випадків використання <<def_detached_HEAD,detached HEAD>>, у цьому випадку воно безпосередньо посилається на довільний коміт.

[[def_head_ref]]головний суддя::
	Синонім до <<def_head,head>>.

[[def_hook]]гачок::
	Під час звичайного виконання кількох команд Git викликаються додаткові скрипти, які дозволяють розробнику додавати функціональність або перевіряти. Зазвичай, перехоплювальні скрипти дозволяють попередньо перевірити команду та потенційно перервати її, а також дозволяють відправити повідомлення після завершення операції. Перехоплювальні скрипти знаходяться в каталозі `$GIT_DIR/hooks/` та активуються простим видаленням суфікса `.sample` з назви файлу. У попередніх версіях Git їх потрібно було зробити виконуваними.

[[def_index]]індекс::
	Колекція файлів зі статистичною інформацією, вміст яких зберігається як об'єкти. Індекс – це збережена версія вашого <<def_working_tree,working tree>>. Правду кажучи, він також може містити другу, і навіть третю версію робочого дерева, які використовуються при <<def_merge,merging>>.

[[def_index_entry]]запис індексу::
	Інформація щодо певного файлу, що зберігається в <<def_index,index>>. Запис індексу можна роз'єднати, якщо <<def_merge,merge>> було розпочато, але ще не завершено (тобто, якщо індекс містить кілька версій цього файлу).

[[def_master]]майстер::
	Розробка за замовчуванням <<def_branch,branch>>. Щоразу, коли ви створюєте Git <<def_repository,repository>>, створюється гілка з назвою "master", яка стає активною гілкою. У більшості випадків вона містить локальну розробку, хоча це виключно за домовленістю і не є обов'язковим.

[[def_merge]]об'єднати::
	Як дієслово: Перенести вміст іншої <<def_branch,branch>> (можливо, із зовнішнього <<def_repository,repository>>) до поточної гілки. У випадку, коли об'єднана гілка знаходиться з іншого репозиторію, це робиться спочатку шляхом <<def_fetch,fetching>> віддаленої гілки, а потім об'єднання результату з поточною гілкою. Ця комбінація операцій вибірки та злиття називається <<def_pull,pull>>. Об'єднання виконується автоматичним процесом, який ідентифікує зміни, внесені з моменту розбіжності гілок, а потім застосовує всі ці зміни разом. У випадках, коли зміни конфліктують, для завершення об'єднання може знадобитися ручне втручання.
+
Як іменник: якщо це не <<def_fast_forward,fast-forward>>, успішне злиття призводить до створення нового <<def_commit,commit>>, що представляє результат злиття, і має як <<def_parent,parents>> кінці об'єднаних <<def_branch,branches>>. Цей коміт називається "merge commit" або іноді просто "merge".

[[def_object]]об'єкт::
	Одиниця сховища в Git. Вона однозначно ідентифікується <<def_SHA1,SHA-1>> її вмісту. Отже, об'єкт не можна змінити.

[[def_object_database]]об'єктна база даних::
	Зберігає набір "об'єктів", а окремий <<def_object,object>> ідентифікується за його <<def_object_name,object name>>. Об'єкти зазвичай знаходяться в `$GIT_DIR/objects/`.

[[def_object_identifier]]ідентифікатор об'єкта (oid)::
	Синонім до <<def_object_name,назва_об'єкта>>.

[[def_object_name]]назва об'єкта::
	Унікальний ідентифікатор <<def_object,object>>. Ім'я об'єкта зазвичай представлено шістнадцятковим рядком із 40 символів. Також розмовно називається <<def_SHA1,SHA-1>>.

[[def_object_type]]тип об'єкта::
	Один з ідентифікаторів "<<def_commit_object,commit>>", "<<def_tree_object,tree>>", "<<def_tag_object,tag>>" або "<<def_blob_object,blob>>", що описує тип <<def_object,object>>.

[[def_octopus]]восьминіг::
	Щоб виконати <<def_merge,merge>> більше двох <<def_branch,branches>>.

[[def_orphan]]сирота::
	Акт переходу на гілку <<def_branch,branch>>, яка ще не існує (тобто гілку <<def_unborn,unborn>>). Після такої операції спочатку створений коміт стає комітом без батьківського елемента, починаючи нову історію.

[[def_origin]]походження::
	За замовчуванням розгортається `<<def_repository,repository>>`. Більшість проектів мають принаймні один розгортається проект, який вони відстежують. За замовчуванням для цієї мети використовується 'origin'. Нові оновлення розгортаються будуть завантажуватися в `<<def_remote_tracking_branch,remote-tracking branchs>>` з назвою origin/name-of-upstream-branch, яку ви можете побачити за допомогою `git branch -r`.

[[def_overlay]]накладання::
	Оновлювати та додавати файли лише до робочого каталогу, але не видаляти їх, подібно до того, як 'cp -R' оновлює вміст у каталозі призначення. Це режим за замовчуванням у <<def_checkout,checkout>> під час отримання файлів з <<def_index,index>> або <<def_tree-ish,tree-ish>>. На противагу цьому, режим без накладання також видаляє відстежувані файли, яких немає у джерелі, подібно до 'rsync --delete'.

[[def_pack]]пачка::
	Набір об'єктів, стиснутих в один файл (для економії місця або ефективної передачі).

[[def_pack_index]]індекс пачки::
	Список ідентифікаторів та іншої інформації про об'єкти в <<def_pack,pack>>, що допомагає в ефективному доступі до вмісту пакета.

[[def_pathspec]]специфікація шляху::
	Шаблон, який використовується для обмеження шляхів у командах Git.
+
Специфікації шляхів використовуються в командному рядку команд "git ls-files", "git ls-tree", "git add", "git grep", "git diff", "git checkout" та багатьох інших, щоб обмежити область дії певною підмножиною дерева або робочим деревом. Дивіться документацію кожної команди, щоб дізнатися, чи шляхи відносні до поточного каталогу чи верхнього рівня. Синтаксис специфікації шляхів такий:
+
--

* будь-який шлях відповідає сам собі
* Специфікація шляху до останньої косої риски представляє префікс каталогу. Область дії цієї специфікації шляху обмежена цим піддеревом.
* Решта специфікації шляху є шаблоном для решти імені шляху. Шляхи відносно префікса каталогу будуть зіставлені з цим шаблоном за допомогою fnmatch(3); зокрема, '*' та '?' _можуть_ збігатися з роздільниками каталогів.

--
+
Наприклад, Documentation/*.jpg відповідатиме всім файлам .jpg у піддереві Документація, включаючи Documentation/chapter_1/figure_1.jpg.
+
Специфікація шляху, що починається з двокрапки `:`, має спеціальне значення. У скороченій формі після початкової двокрапки `:` йде нуль або більше літер "магічного підпису" (яка необов'язково завершується ще однією двокрапкою `:`), а решта - це шаблон для зіставлення зі шляхом. "Магічний підпис" складається з символів ASCII, які не є ні буквено-цифровими, ні глобальними, ні спеціальними символами регулярних виразів, ні двокрапкою. Необов'язкова двокрапка, яка завершує "магічний підпис", може бути пропущена, якщо шаблон починається з символу, який не належить до набору символів "магічного підпису" і не є двокрапкою.
+
У довгій формі після двокрапки `:` йде відкрита дужка `(`, список з нуля або більше «магічних слів», розділений комами, та закриваюча дужка `)`, а решта — це шаблон, який потрібно зіставити зі шляхом.
+
Специфікація шляху, що містить лише двокрапку, означає, що «специфікації шляху немає». Цю форму не слід поєднувати з іншими специфікаціями шляху.
+
--
верх;;
	Магічне слово `top` (магічний підпис: `/`) забезпечує збіг зі зразком з кореня робочого дерева, навіть якщо ви виконуєте команду з підкаталогу.

буквальний;;
	Символи-підстановки у шаблоні, такі як `*` або `?`, обробляються як літерали.

справа;;
	Збіг без урахування регістру.

глоб;;
	Git трактує шаблон як глобальний об'єкт оболонки, придатний для використання fnmatch(3) з прапорцем FNM_PATHNAME: підстановлювальні символи у шаблоні не збігатимуться з / у шляху. Наприклад, "Documentation/{asterisk}.html" відповідає "Documentation/git.html", але не "Documentation/ppc/ppc.html" або "tools/perf/Documentation/perf.html".
+
Дві послідовні зірочки ("**") у шаблонах, що збігаються з повним шляхом, можуть мати спеціальне значення:

 - Початковий символ "`**`", а потім скісний риса, означає збіг у всіх каталогах. Наприклад, "`**/foo`" відповідає файлу або каталогу "`foo`" будь-де. "`**/foo/bar`" відповідає файлу або каталогу "`bar`" будь-де, що знаходиться безпосередньо в каталозі "`foo`".

 - Завершальний "`/**`" відповідає всьому всередині. Наприклад, "`abc/**`" відповідає всім файлам у каталозі "abc", відносно розташування файлу `.gitignore`, з нескінченною глибиною.

 - Слеш-риска, за якою слідують дві послідовні зірочки, а потім ще одна скісну риска, відповідає нулю або більше каталогам. Наприклад, "`a/**/b`" відповідає "`a/b`", "`a/x/b`", "`a/x/y/b`" тощо.

 - Інші послідовні зірочки вважаються недійсними.
+
Глобальна магія несумісна з буквальною магією.

атрибут;;
Після `attr:` йде список "вимог до атрибутів", розділений пробілами, всі з яких мають бути виконані, щоб шлях вважався збігом; це на додаток до звичайного немагічного зіставлення зі зразком pathspec. Див. linkgit:gitattributes[5].
+
Кожен з атрибутів, що вимагаються для шляху, має одну з таких форм:

- "`ATTR`" вимагає, щоб атрибут `ATTR` був встановлений.

- "`-ATTR`" вимагає, щоб атрибут `ATTR` був скасований.

- "`ATTR=VALUE`" вимагає, щоб атрибут `ATTR` був встановлений на рядок `VALUE`.

- "`!ATTR`" вимагає, щоб атрибут `ATTR` був невказаним.
+
Зверніть увагу, що під час зіставлення з об'єктом дерева атрибути все одно отримуються з робочого дерева, а не з заданого об'єкта дерева.

виключити;;
	Після того, як шлях збігається з будь-якою невиключеною специфікацією шляху, він буде пропущений через усі виключені специфікації шляху (магічний підпис: `!` або її синонім `^`). Якщо шлях збігається, його ігнорується. Якщо невиключеної специфікації шляху немає, виключення застосовується до результуючого набору так, ніби викликано без будь-якої специфікації шляху.
--

[[def_parent]]батько::
	Об'єкт <<def_commit_object,commit>> містить (можливо, порожній) список логічних попередників у лінії розробки, тобто його батьків.

[[def_peel]]шкірка::
	Дія рекурсивного виконання <<def_dereference,dereferencing>> об'єкта <<def_tag_object,tag>>.

[[def_pickaxe]]кирка::
	Термін <<def_pickaxe,pickaxe>> стосується опції процедур diffcore, які допомагають вибирати зміни, що додають або видаляють заданий текстовий рядок. За допомогою опції `--pickaxe-all` її можна використовувати для перегляду повного <<def_changeset,changeset>>, який додав або видалив, скажімо, певний рядок тексту. Див. linkgit:git-diff[1].

[[def_plumbing]]сантехніка::
	Миле ім'я для <<def_core_git,core Git>>.

[[def_porcelain]]порцеляна::
	Миле ім'я для програм та пакетів програм, що залежать від <<def_core_git,core Git>>, що забезпечує високорівневий доступ до ядра Git. Порцелянові елементи надають більше інтерфейсу <<def_SCM,SCM>>, ніж <<def_plumbing,plumbing>>.

[[def_per_worktree_ref]]посилання на робоче дерево::
	Посилання, що є per-<<def_worktree,worktree>>, а не глобальними. Наразі це лише <<def_HEAD,HEAD>> та будь-які посилання, що починаються з `refs/bisect/`, але пізніше можуть включати інші незвичайні посилання.

[[def_pseudoref]]псевдопосилання::
	Посилання, яке має іншу семантику, ніж звичайні посилання. Ці посилання можна зчитувати за допомогою звичайних команд Git, але не можна записувати в них за допомогою команд, таких як linkgit:git-update-ref[1].
+
Git відомі такі псевдопосилання:

 - `FETCH_HEAD` записується за допомогою linkgit:git-fetch[1] або linkgit:git-pull[1]. Він може посилатися на кілька ідентифікаторів об'єктів. Кожен ідентифікатор об'єкта анотується метаданими, що вказують, звідки його було отримано, та його статус отримання.

 - `MERGE_HEAD` записується командою linkgit:git-merge[1] під час вирішення конфліктів злиття. Він містить усі ідентифікатори комітів, які об'єднуються.

[[def_pull]]тягнути::
	Витягування <<def_branch,branch>> означає виконання <<def_fetch,fetch>> та <<def_merge,merge>> її. Див. також linkgit:git-pull[1].

[[def_push]]штовхати::
	Надсилання <<def_branch,branch>> означає отримання <<def_head_ref,head ref>> гілки з віддаленого <<def_repository,repository>>, з'ясування, чи є вона предком локального head ref гілки, і в цьому випадку поміщення всіх об'єктів, які є <<def_reachable,reachable>> з локального head ref та які відсутні у віддаленому репозиторії, до віддаленої <<def_object_database,object database>> та оновлення віддаленого head ref. Якщо віддалений <<def_head,head>> не є предком локального head, надсилання завершується невдачею.

[[def_reachable]]досяжний::
	Усі предки заданого <<def_commit,commit>> називаються "досяжними" з цього коміту. У більш загальному випадку, один <<def_object,object>> є досяжним з іншого, якщо ми можемо досягти одного з іншого за допомогою <<def_chain,chain>>, який йде після <<def_tag,tags>> до будь-якого їхнього тегу, <<def_commit_object,commits>> до їхніх батьківських об'єктів або дерев, та <<def_tree_object,trees>> до дерев або <<def_blob_object,blobs>>, які вони містять.

[[def_reachability_bitmap]]бітові карти досяжності::
	Бітові карти досяжності зберігають інформацію про <<def_reachable,reachability>> вибраного набору комітів у пакетному файлі або індексі мультипаків (MIDX) для пришвидшення пошуку об'єктів. Бітові карти зберігаються у файлі ".bitmap". Репозиторій може використовувати щонайбільше один файл бітових карт. Файл бітових карт може належати або до одного пакету, або до індексу мультипаків репозиторію (якщо він існує).

[[def_rebase]]лисиця::
	Щоб повторно застосувати серію змін з <<def_branch,branch>> до іншої бази та скинути <<def_head,head>> цієї гілки до результату.

[[def_ref]]посилання::
	Ім'я, що вказує на <<def_object_name,ім'я об'єкта>> або інше посилання (останнє називається <<def_symref,символічне посилання>>). Для зручності посилання іноді можна скорочувати, коли воно використовується як аргумент команди Git; див. linkgit:gitrevisions[7] для отримання детальної інформації. Посилання зберігаються в <<def_repository,репозиторії>>.
+
Простір імен посилань є ієрархічним. Імена посилань повинні починатися з `refs/` або розташовуватися в корені ієрархії. Для останнього їх імена повинні відповідати таким правилам:
+
 - Ім'я складається лише з символів верхнього регістру або символів підкреслення.

 - Ім'я закінчується на "`_HEAD`" або дорівнює "`HEAD`".
+
У корені ієрархії є деякі нерегулярні посилання, які не відповідають цим правилам. Наведений нижче список є вичерпним і не буде розширюватися в майбутньому:
+
 - `AUTO_MERGE`

 - `BISECT_EXPECTED_REV`

 - `NOTES_MERGE_PARTIAL`

 - `NOTES_MERGE_REF`

 - `MERGE_AUTOSTASH`
+
Різні підієрархії використовуються для різних цілей. Наприклад, ієрархія `refs/heads/` використовується для представлення локальних гілок, тоді як ієрархія `refs/tags/` використовується для представлення локальних тегів.

[[def_reflog]]повторно заповнити::
	Reflog показує локальну «історію» посилання. Іншими словами, він може повідомити вам, якою була третя остання ревізія в _this_ репозиторії та який був поточний стан у _this_ репозиторії вчора о 21:14. Див. linkgit:git-reflog[1] для отримання детальної інформації.

[[def_refspec]]специфікація посилання::
	"Refspec" використовується <<def_fetch,fetch>> та <<def_push,push>> для опису відповідності між віддаленим <<def_ref,ref>> та локальним посиланням. Див. linkgit:git-fetch[1] або linkgit:git-push[1] для отримання детальної інформації.

[[def_remote]]віддаленого сховища::
	Об'єкт <<def_repository,repository>>, який використовується для відстеження того самого проєкту, але знаходиться деінде. Щоб зв'язатися з віддаленими серверами, див. <<def_fetch,fetch>> або <<def_push,push>>.

[[def_remote_tracking_branch]]гілка віддаленого відстеження::
	Гілка <<def_ref,ref>>, яка використовується для відстеження змін з іншого <<def_repository,repository>>. Зазвичай вона виглядає як 'refs/remotes/foo/bar' (що вказує на те, що вона відстежує гілку з назвою 'bar' у віддаленому репозиторії з назвою 'foo') та відповідає правій частині налаштованого fetch <<def_refspec,refspec>>. Гілка з віддаленим відстеженням не повинна містити прямих модифікацій або локальних комітів.

[[def_repository]]сховище::
	Колекція <<def_ref,refs>> разом з <<def_object_database,object базою даних>>, що містить усі об'єкти, які є <<def_reachable,reachable>> з посилань, можливо, супроводжувані метаданими з одного або кількох <<def_porcelain,porcelains>>. Репозиторій може спільно використовувати базу даних об'єктів з іншими репозиторіями через механізм <<def_alternate_object_database,alternates>>.

[[def_resolve]]вирішити::
	Дія виправлення вручну того, що залишилося після невдалого автоматичного <<def_merge,merge>>.

[[def_revision]]перегляд::
	Синонім до <<def_commit,commit>> (іменник).

[[def_rewind]]перемотування назад::
	Відкинути частину розробки, тобто призначити <<def_head,head>> попередньому <<def_revision,revision>>.

[[def_SCM]]SCM::
	Управління вихідним кодом (інструмент).

[[def_SHA1]]SHA-1::
	"Secure Hash Algorithm 1"; криптографічна хеш-функція. У контексті Git використовується як синонім <<def_object_name,object name>>.

[[def_shallow_clone]]поверхневий клон::
	Здебільшого синонім <<def_shallow_repository,shallow repository>>, але ця фраза чіткіше вказує на те, що його було створено за допомогою команди `git clone --depth=...`.

[[def_shallow_repository]]неглибоке сховище::
	Неглибокий <<def_repository,repository>> має неповну історію, деякі з <<def_commit,commits>> якої <<def_parent,parents>> знищені (іншими словами, Git має вдати, що ці коміти не мають батьківських комітів, навіть якщо вони записані в <<def_commit_object,commit object>>). Це іноді корисно, коли вас цікавить лише недавня історія проекту, хоча реальна історія, записана в апстрімі, набагато більша. Неглибокий репозиторій створюється шляхом надання опції `--depth` для linkgit:git-clone[1], а його історію пізніше можна поглибити за допомогою linkgit:git-fetch[1].

[[def_stash]]запис у сховищі::
	Об'єкт <<def_object,object>> використовується для тимчасового зберігання вмісту робочого каталогу <<def_dirty,dirty>> та індексу для подальшого використання.

[[def_submodule]]підмодуль::
	Об'єкт <<def_repository,repository>>, що містить історію окремого проєкту всередині іншого репозиторію (останній називається <<def_superproject, superproject>>).

[[def_superproject]]суперпроект::
	Об'єкт <<def_repository,repository>>, який посилається на репозиторії інших проектів у своєму робочому дереві як <<def_submodule,submodules>>. Суперпроект знає про назви (але не містить копій) об'єктів комітів підмодулів, що містяться в ньому.

[[def_symref]]симреф::
	Символічне посилання: замість того, щоб містити сам ідентифікатор <<def_SHA1,SHA-1>>, воно має формат 'ref: refs/some/thing', і під час посилання воно рекурсивно <<def_dereference,dereferences>> переходить до цього посилання. '<<def_HEAD,HEAD>>' є яскравим прикладом символічного посилання. Символьні посилання маніпулюють командою linkgit:git-symbolic-ref[1].

[[def_tag]]тег::
	Об'єкт <<def_ref,ref>> у просторі імен `refs/tags/`, який вказує на об'єкт довільного типу (зазвичай тег вказує або на <<def_tag_object,tag>>, або на <<def_commit_object,commit об'єкт>>). На відміну від <<def_head,head>>, тег не оновлюється командою `commit`. Тег Git не має нічого спільного з тегом Lisp (який у контексті Git називався б <<def_object_type,object type>>). Тег найчастіше використовується для позначення певної точки в походженні комітів <<def_chain,chain>>.

[[def_tag_object]]об'єкт тегу::
	Об'єкт <<def_object,object>>, що містить <<def_ref,ref>>, що вказує на інший об'єкт, який може містити повідомлення, як і об'єкт <<def_commit_object,commit>>. Він також може містити підпис (PGP), і в цьому випадку він називається "підписаним об'єктом тегу".

[[def_topic_branch]]тематична гілка::
	Звичайний Git <<def_branch,branch>>, який використовується розробником для визначення концептуальної лінії розробки. Оскільки гілки дуже прості та недорогі, часто бажано мати кілька невеликих гілок, кожна з яких містить дуже чітко визначені концепції або невеликі інкрементальні, але пов'язані зміни.

[[def_trailer]]трейлер::
	Метадані ключ-значення. Трейлери необов'язково знаходяться в кінці повідомлення коміту. В інших спільнотах можуть називатися "футерами" або "тегами". Див. linkgit:git-interpret-trailers[1].

[[def_tree]]дерево::
	Або <<def_working_tree,working tree>>, або <<def_tree_object,tree object>> разом із залежними об'єктами <<def_blob_object,blob>> та tree (тобто збережене представлення робочого дерева).

[[def_tree_object]]деревоподібний об'єкт::
	Об'єкт <<def_object,object>>, що містить список імен файлів та режимів, а також посилання на пов'язані блоб-об'єкти та/або деревоподібні об'єкти. <<def_tree,tree>> еквівалентний <<def_directory,directory>>.

[[def_tree-ish]]деревоподібний (також деревоподібний)::
	Об'єкт <<def_tree_object,tree>> або <<def_object,object>>, який можна рекурсивно <<def_dereference,dereference>> перенести на об'єкт дерева. Розіменування об'єкта <<def_commit_object,commit>> повертає об'єкт дерева, що відповідає верхньому <<def_directory,directory>> об'єкта <<def_revision,revision>>. Наступні об'єкти є деревоподібними: <<def_commit-подібний,commit-подібний>>, об'єкт дерева, об'єкт <<def_tag_object,tag>>, що вказує на об'єкт дерева, об'єкт tag, що вказує на об'єкт tag, що вказує на об'єкт дерева тощо.

[[def_unborn]]ненароджений::
	<<def_HEAD,HEAD>> може вказувати на <<def_branch,branch>>, якої ще не існує і на якій ще немає жодного коміту, і така гілка називається ненародженою гілкою. Найтиповіший спосіб, яким користувачі стикаються з ненародженою гілкою, - це створення репозиторію заново без клонування з іншого місця. HEAD вказуватиме на «головну» (або «головну», залежно від вашої конфігурації) гілку, яка ще не народилася. Також деякі операції можуть перемістити вас на ненароджену гілку за допомогою їхнього параметра <<def_orphan,orphan>>.


[[def_unmerged_index]]необ'єднаний індекс::
	Об'єкт <<def_index,index>>, що містить необ'єднані записи <<def_index_entry,index>>.

[[def_unreachable_object]]недосяжний об'єкт::
	Об'єкт <<def_object,object>>, який не є <<def_reachable,reachable>> з <<def_branch,branch>>, <<def_tag,tag>> або будь-якого іншого посилання.

[[def_upstream_branch]]вище за течією гілка::
	Значення за замовчуванням <<def_branch,branch>>, яке об'єднується з відповідною гілкою (або на яке перебазується відповідна гілка). Налаштовується через branch.<name>.remote та branch.<name>.merge. Якщо гілкою вище за течією 'A' є 'origin/B', іноді ми кажемо, що "'A' відстежує 'origin/B'".

[[def_working_tree]]робоче дерево::
	Дерево фактично отриманих файлів. Робоче дерево зазвичай містить вміст дерева комітів <<def_HEAD,HEAD>>, а також будь-які локальні зміни, які ви внесли, але ще не закомітили.

[[def_worktree]]робоче дерево::
	До репозиторію може бути прикріплено нуль (тобто голий репозиторій) або одне чи декілька робочих дерев. Одне «робоче дерево» складається з «робочого дерева» та метаданих репозиторію, більшість з яких є спільними для інших робочих дерев одного репозиторію, а деякі з них підтримуються окремо для кожного робочого дерева (наприклад, індекс, HEAD та псевдопосилання, такі як MERGE_HEAD, посилання для кожного робочого дерева та файл конфігурації для кожного робочого дерева).
