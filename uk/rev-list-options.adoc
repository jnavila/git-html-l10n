Обмеження комітів
~~~~~~~~~~~~~~~~~

Окрім визначення діапазону комітів, які слід перерахувати, за допомогою спеціальних позначень, пояснених в описі, можуть бути застосовані додаткові обмеження кількості комітів.

Використання більшої кількості опцій зазвичай ще більше обмежує вивід (наприклад, `--since=<date1>` обмежує коміти, новіші за _<date1>_, а використання з `--grep=<pattern>` ще більше обмежує коміти, повідомлення журналу яких містить рядок, що відповідає _<pattern>_), якщо не зазначено інше.

Зверніть увагу, що ці параметри застосовуються перед упорядкуванням комітів та параметрами форматування, такими як `--reverse`.

`-<number>`::
`-n <number>`::
`--max-count=<number>`::
	Обмежити вивід до _<number>_ комітів.

`--skip=<number>`::
	Пропустити _<number>_ комітів перед початком відображення виводу коміта.

`--since=<date>`::
`--after=<date>`::
	Показати коміти, новіші за _<date>_.

`--since-as-filter=<date>`::
	Показати всі коміти, новіші за _<date>_. Це відвідує всі коміти в діапазоні, а не зупиняється на першому коміті, який старший за _<date>_.

`--until=<date>`::
`--before=<date>`::
	Показати коміти, старші за _<date>_.

ifdef::git-rev-list[]
`--max-age=<timestamp>`::
`--min-age=<timestamp>`::
	Обмежити вивід комітів заданим часовим діапазоном.
endif::git-rev-list[]

`--author=<pattern>`::
`--committer=<pattern>`::
	Обмежте виведення комітів тими, у яких заголовки автора/комітера відповідають регулярному виразу _<шаблон>_. Якщо є більше одного `--author=<шаблон>`, вибираються коміти, автор яких відповідає будь-якому з _<шаблон>_ (аналогічно для кількох `--committer=<шаблон>`).

`--grep-reflog=<pattern>`::
	Обмежте вивід комітів тими, у яких записи reflog відповідають регулярному виразу _<pattern>_. Якщо `--grep-reflog` використовується більше одного шаблону, вибираються коміти, повідомлення reflog яких відповідає будь-якому з заданих шаблонів. Використання цієї опції є помилкою, якщо не використовується `--walk-reflogs`.

`--grep=<pattern>`::
	Обмежте вивід комітів тими, у яких повідомлення журналу відповідає регулярному виразу _<шаблон>_. Якщо є більше одного `--grep=<шаблон>`, вибираються коміти, повідомлення яких відповідає будь-якому з _<шаблон>_ (але див. `--all-match`).
ifndef::git-rev-list[]
+
Коли діє параметр `--notes`, повідомлення з нотаток зіставляється так, ніби воно є частиною повідомлення журналу.
endif::git-rev-list[]

`--all-match`::
	Обмежте вивід комітів тими, що відповідають усім заданим `--grep`, замість тих, що відповідають хоча б одному.

`--invert-grep`::
	Обмежте вивід комітів тими, у яких повідомлення журналу не відповідає _<шаблон>_, зазначеному за допомогою `--grep=<шаблон>`.

`-i`::
`--regexp-ignore-case`::
	Зіставляє обмежувальні шаблони регулярних виразів без урахування регістру літер.

`--basic-regexp`::
	Вважайте обмежувальні шаблони простими регулярними виразами; це значення за замовчуванням.

`-E`::
`--extended-regexp`::
	Вважайте обмежувальні шаблони розширеними регулярними виразами, а не базовими регулярними виразами за замовчуванням.

`-F`::
`--fixed-strings`::
	Вважайте обмежувальні шаблони фіксованими рядками (не інтерпретуйте шаблон як регулярний вираз).

`-P`::
`--perl-regexp`::
	Вважайте обмежуючі шаблони Perl-сумісними регулярними виразами.
+
Підтримка цих типів регулярних виразів є необов'язковою залежністю під час компіляції. Якщо Git не було скомпільовано з їх підтримкою, надання цієї опції призведе до його завершення роботи.

`--remove-empty`::
	Зупинитися, коли заданий шлях зникає з дерева.

`--merges`::
	Виводити лише коміти злиття. Це точно те саме, що й `--min-parents=2`.

`--no-merges`::
	Не виводьте коміти з більш ніж одним батьківським елементом. Це точно те саме, що й `--max-parents=1`.

`--min-parents=<number>`::
`--max-parents=<number>`::
`--no-min-parents`::
`--no-max-parents`::
	Показувати лише коміти, які мають щонайменше (або максимум) певну кількість батьківських комітів. Зокрема, `--max-parents=1` те саме, що `--no-merges`, `--min-parents=2` те саме, що `--merges`. `--max-parents=0` повертає всі кореневі коміти, а `--min-parents=3` повертає всі злиття Octopus.
+
`--no-min-parents` та `--no-max-parents` знову скидають ці обмеження (до нульового значення). Еквівалентними формами є `--min-parents=0` (будь-який коміт має 0 або більше батьків) та `--max-parents=-1` (від'ємні числа означають відсутність верхньої межі).

`--first-parent`::
	Під час пошуку комітів для включення, слідкуйте лише за першим батьківським комітом після перегляду коміту злиття. Ця опція може дати кращий огляд еволюції певної тематичної гілки, оскільки злиття в тематичну гілку, як правило, полягає лише в адаптації до оновлень основної версії, і ця опція дозволяє ігнорувати окремі коміти, що додаються до вашої історії в результаті такого злиття.
ifdef::git-log[]
+
Ця опція також змінює формат різниці за замовчуванням для комітів злиття на `first-parent`, див. `--diff-merges=first-parent` для отримання детальної інформації.
endif::git-log[]

`--exclude-first-parent-only`::
	Під час пошуку комітів для виключення (за допомогою '{caret}') слідкуйте лише за першим батьківським комітом після виявлення коміту злиття. Це можна використовувати для пошуку набору змін у тематичній гілці з точки, де вона відійшла від віддаленої гілки, враховуючи, що довільні злиття можуть бути дійсними змінами тематичної гілки.

`--not`::
	Змінює значення префікса '{caret}' (або його відсутності) на протилежне для всіх наступних специфікаторів версій, аж до наступного `--not`. При використанні в командному рядку перед --stdin, версії, передані через stdin, не будуть піддані його впливу. І навпаки, при передачі через стандартний ввід, версії, передані в командному рядку, не будуть піддані його впливу.

`--all`::
	Зробіть вигляд, що всі посилання в `refs/`, разом з `HEAD`, перелічені в командному рядку як _<commit>_.

`--branches[=<pattern>]`::
	Зробіть вигляд, ніби всі посилання в `refs/heads` перелічені в командному рядку як _<commit>_. Якщо задано _<pattern>_, обмежте гілки тими, що відповідають заданому глобусу оболонки. Якщо _<pattern>_ не містить '?', '{asterisk}' або '[', мається на увазі '/{asterisk}' в кінці.

`--tags[=<pattern>]`::
	Зробіть вигляд, ніби всі посилання в `refs/tags` перелічені в командному рядку як _<commit>_. Якщо задано _<pattern>_, обмежте теги тими, що відповідають заданому глобусу оболонки. Якщо у шаблоні відсутні '?', '{asterisk}' або '[', мається на увазі '/{asterisk}' в кінці.

`--remotes[=<pattern>]`::
	Зробіть вигляд, що всі посилання в `refs/remotes` перелічені в командному рядку як _<commit>_. Якщо задано _<pattern>_, обмежте гілки віддаленого відстеження тими, що відповідають заданому глобусу оболонки. Якщо у шаблоні відсутні '?', '{asterisk}' або '[', мається на увазі '/{asterisk}' в кінці.

`--glob=<glob-pattern>`::
	Зробіть вигляд, що всі посилання, що відповідають глобальному шаблону оболонки _<глоб-шаблон>_, перелічені в командному рядку як _<комміт>_. Початковий 'refs/' автоматично додається на початку, якщо відсутній. Якщо у шаблоні відсутні '?', '{asterisk}' або '[', мається на увазі '/{asterisk}' в кінці.

`--exclude=<glob-pattern>`::

	Не включайте посилання, що відповідають _<glob-pattern>_, які наступні `--all`, `--branches`, `--tags`, `--remotes` або `--glob` враховували б. Повторення цієї опції накопичують шаблони виключень до наступної опції `--all`, `--branches`, `--tags`, `--remotes` або `--glob` (інші опції або аргументи не очищують накопичені шаблони).
+
Наведені шаблони не повинні починатися з `refs/heads`, `refs/tags` або `refs/remotes` при застосуванні до `--branches`, `--tags` або `--remotes` відповідно, і вони повинні починатися з `refs/` при застосуванні до `--glob` або `--all`. Якщо передбачається завершальна '/{asterisk}', її потрібно вказати явно.

`--exclude-hidden=(fetch|receive|uploadpack)`::
	Не включайте посилання, які можуть бути приховані командами `git-fetch`, `git-receive-pack` або `git-upload-pack`, звернувшись до відповідної конфігурації `fetch.hideRefs`, `receive.hideRefs` або `uploadpack.hideRefs` разом із `transfer.hideRefs` (див. linkgit:git-config[1]). Цей параметр впливає на наступний параметр псевдопосилання `--all` або `--glob` та очищається після їх обробки.

`--reflog`::
	Зробіть вигляд, що всі об'єкти, згадані в reflogs, перелічені в командному рядку як _<commit>_.

`--alternate-refs`::
	Зробіть вигляд, що всі об'єкти, згадані як поради альтернативних репозиторіїв, перелічені в командному рядку. Альтернативний репозиторій – це будь-який репозиторій, каталог об'єктів якого вказано в `objects/info/alternates`. Набір включених об'єктів можна змінити за допомогою `core.alternateRefsCommand` тощо. Див. linkgit:git-config[1].

`--single-worktree`::
	За замовчуванням усі робочі дерева будуть перевірені наступними опціями, якщо їх більше одного (див. linkgit:git-worktree[1]): `--all`, `--reflog` та `--indexed-objects`. Ця опція змушує їх перевіряти лише поточне робоче дерево.

`--ignore-missing`::
	Побачивши недійсне ім'я об'єкта у вхідних даних, зробіть вигляд, що неправильне ім'я не було вказано.

ifndef::git-rev-list[]
`--bisect`::
	Зробіть вигляд, що посилання на погану бісекцію `refs/bisect/bad` було перераховано, а за нею слідувало `--not`, а в командному рядку — посилання на хорошу бісекцію `refs/bisect/good-*`.
endif::git-rev-list[]

`--stdin`::
	Окрім отримання аргументів з командного рядка, їх також можна зчитувати зі стандартного вводу. Це дозволяє зчитувати коміти та псевдо-опції, такі як `--all` та `--glob=`. Коли бачиться роздільник `--`, наступний ввід обробляється як шлях і використовується для обмеження результату. Прапорці, такі як `--not`, які зчитуються через стандартний ввід, враховуються лише для аргументів, переданих таким самим чином, і не впливатимуть на будь-які наступні аргументи командного рядка.

ifdef::git-rev-list[]
`--quiet`::
	Не виводьте нічого на стандартний вивід. Ця форма в першу чергу призначена для того, щоб викликатий стороні вдалося перевірити статус виходу, щоб побачити, чи повноцінно підключено діапазон об'єктів (чи ні). Це швидше, ніж перенаправлення stdout на `/dev/null`, оскільки вивід не потрібно форматувати.

`--disk-usage`::
`--disk-usage=human`::
	Придушити звичайний вивід; натомість вивести суму байтів, використаних для зберігання на диску вибраними комітами або об'єктами. Це еквівалентно передачі виводу в `git cat-file --batch-check='%(objectsize:disk)'`, за винятком того, що це працює набагато швидше (особливо з `--use-bitmap-index`). Дивіться розділ `CAVEATS` у linkgit:git-cat-file[1] для обмежень того, що означає "сховище на диску". З необов'язковим значенням `human` розмір сховища на диску відображається у вигляді рядка, який читається людиною (наприклад, 12,24 Кб, 3,50 Мб).
endif::git-rev-list[]

`--cherry-mark`::
	Подібно до `--cherry-pick` (див. нижче), але позначте еквівалентні коміти знаком `=`, а не пропускайте їх, а нееквівалентні — знаком `+`.

`--cherry-pick`::
	Пропускати будь-який коміт, який вносить ту саму зміну, що й інший коміт на «іншому боці», коли набір комітів обмежений симетричною різницею.
+
Наприклад, якщо у вас є дві гілки, `A` та `B`, звичайний спосіб перерахувати всі коміти лише з одного боку від них — це використовувати `--left-right` (див. приклад нижче в описі опції `--left-right`). Однак, це показує коміти, які були вибрані з іншої гілки (наприклад, ``3rd on b'' може бути вибраний з гілки A). З цією опцією такі пари комітів виключаються з виводу.

`--left-only`::
`--right-only`::
	Перераховувати лише коміти з відповідного боку симетричної різниці, тобто лише ті, які будуть позначені `<` відповідно `>` за допомогою `--left-right`.
+
Наприклад, `--cherry-pick --right-only A...B` пропускає ті коміти з `B`, які знаходяться в `A` або є патч-еквівалентами коміту в `A`. Іншими словами, це перераховує `+` коміти з `git cherry A B`. Точніше, `--cherry-pick --right-only --no-merges` дає точний список.

`--cherry`::
	Синонім до `--right-only --cherry-mark --no-merges`; корисно для обмеження виводу коммітів на нашому боці та позначення тих, що були застосовані на іншому боці розгалуженої історії, за допомогою `git log --cherry upstream...mybranch`, подібно до `git cherry upstream mybranch`.

`-g`::
`--walk-reflogs`::
	Замість того, щоб проходити ланцюжок походження комітів, перегляньте записи журналу походження від найновішого до найстаріших. Коли використовується ця опція, ви не можете вказати коміти для виключення (тобто нотації `^<commit>`, `<commit1>..<commit2>` та `<commit1>...<commit2>` не можна використовувати).
+
Якщо формат `--pretty` відрізняється від `oneline` та `reference` (з очевидних причин), це призводить до того, що вивід містить два додаткові рядки інформації, взятої з журналу посилань. Позначення журналу посилань у вивідних даних може відображатися як `ref@{<Nth>}` (де _<Nth>_ — це зворотний хронологічний індекс у журналі посилань) або як `ref@{<timestamp>}` (з _<timestamp>_ для цього запису), залежно від кількох правил:
+
--
1. Якщо початкова точка вказана як `ref@{<Nth>}`, показати формат індексу.
+
2. Якщо початкова точка була вказана як `ref@{now}`, показати формат позначки часу.
+
3. Якщо жоден з них не був використаний, але в командному рядку було вказано `--date`, показати позначку часу у форматі, що запитується `--date`.
+
4. В іншому випадку, покажіть формат індексу.
--
+
У розділі `--pretty=oneline` повідомлення коміту має префікс із цією інформацією в тому ж рядку. Цей параметр не можна поєднувати з `--reverse`. Див. також linkgit:git-reflog[1].
+
При параметрі `--pretty=reference` ця інформація взагалі не відображатиметься.

`--merge`::
	Показувати коміти, що торкаються конфліктуючих шляхів у діапазоні `HEAD...<other>`, де `<other>` – це перше існуюче псевдопосилання в `MERGE_HEAD`, `CHERRY_PICK_HEAD`, `REVERT_HEAD` або `REBASE_HEAD`. Працює лише тоді, коли індекс містить необ'єднані записи. Цю опцію можна використовувати для показу відповідних комітів під час вирішення конфліктів із тристороннього злиття.

`--boundary`::
	Вивести виключені граничні коміти. Граничні коміти мають префікс `-`.

ifdef::git-rev-list[]
`--use-bitmap-index`::

	Спробуйте пришвидшити перехід за допомогою індексу растрового зображення пакету (якщо такий доступний). Зверніть увагу, що під час переходу з `--objects`, дерева та блоби не матимуть пов'язаного шляху, що виводиться.

`--progress=<header>`::
	Показувати звіти про хід виконання на stderr під час розгляду об'єктів. Текст `<header>` буде виведено з кожним оновленням прогресу.

`-z`::
	Замість розділення символами нового рядка, кожен виведений об'єкт та супутні йому метадані розділяються за допомогою NUL-байтів. Вивід виводиться у такому вигляді:
+
-----------------------------------------------------------------------
<OID> NUL [<token>=<value> NUL]...
-----------------------------------------------------------------------
+
Додаткові метадані об'єкта, такі як шляхи до об'єктів або граничні об'єкти, друкуються за допомогою форми `<токен>=<значення>`. Значення токенів друкуються як є без будь-якого кодування/скорочення. Запис OID ніколи не містить символу '=' і тому використовується для сигналізації початку нового запису об'єкта. Приклади:
+
-----------------------------------------------------------------------
<OID> NUL
<OID> NUL path=<path> NUL
<OID> NUL boundary=yes NUL
<OID> NUL missing=yes NUL [<token>=<value> NUL]...
-----------------------------------------------------------------------
+
Цей режим сумісний лише з параметрами виводу `--objects`, `--boundary` та `--missing`.
endif::git-rev-list[]

Спрощення історії
~~~~~~~~~~~~~~~~~

Іноді вас цікавлять лише частини історії, наприклад, коміти, що змінюють певний <path>. Але є дві частини «Спрощення історії», одна частина — це вибір комітів, а інша — як це зробити, оскільки існують різні стратегії спрощення історії.

Наступні опції вибирають коміти, які будуть показані:

`<paths>`::
	Вибрано коміти, що змінюють задані <paths>.

`--simplify-by-decoration`::
	Вибираються коміти, на які посилається якась гілка або тег.

Зверніть увагу, що додаткові коміти можуть бути показані для надання змістовної історії.

На спосіб виконання спрощення впливають такі параметри:

`Default mode`::
	Спрощує історію до найпростішої історії, що пояснює кінцевий стан дерева. Найпростіший, тому що він обрізає деякі бічні гілки, якщо кінцевий результат той самий (тобто об'єднання гілок з однаковим вмістом)

`--show-pulls`::
	Включити всі коміти з режиму за замовчуванням, а також будь-які коміти злиття, які не є TREESAME для першого батьківського елемента, але є TREESAME для пізнішого батьківського елемента. Цей режим корисний для відображення комітів злиття, які "першими внесли" зміни до гілки.

`--full-history`::
	Те саме, що й режим за замовчуванням, але не видаляє частину історії.

`--dense`::
	Показуються лише вибрані коміти, а також деякі з них для змістовної історії.

`--sparse`::
	Відображаються всі коміти у спрощеній історії.

`--simplify-merges`::
	Додаткова опція до `--full-history` для видалення деяких непотрібних злиттів з результуючої історії, оскільки немає вибраних комітів, що вносять свій вклад у це злиття.

`--ancestry-path[=<commit>]`::
	Якщо задано діапазон коммітів для відображення (наприклад, `<commit1>..<commit2>` або `<commit2> ^<commit1>`), і коміт _<commit>_ у цьому діапазоні, відображаються лише коміти в цьому діапазоні, які є предками _<commit>_, нащадками _<commit>_ або самим _<commit>_. Якщо коміт не вказано, використовуйте _<commit1>_ (виключену частину діапазону) як _<commit>_. Можна передати кілька разів; якщо так, коміт включається, якщо він є будь-яким із заданих коммітів або якщо він є предком чи нащадком одного з них.

Далі наведено більш детальне пояснення.

Припустимо, ви вказали `foo` як _<шляхи>_. Ми називатимемо коміти, що змінюють `foo`, !TREESAME, а решту TREESAME. (У різниці, відфільтрованій для `foo`, вони виглядають відповідно різними та рівними.)

Далі ми завжди будемо посилатися на ту саму історію прикладів, щоб проілюструвати відмінності між налаштуваннями спрощення. Ми припускаємо, що ви фільтруєте файл `foo` у цьому графі комітів:

-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /   /
	I     B   C   D   E   Y
	 \   /   /   /   /   /
	  `-------------'   X
-----------------------------------------------------------------------

Горизонтальна лінія історії A---Q вважається першим батьківським елементом кожного злиття. Коміти такі:

* `I` — це початковий коміт, в якому існує `foo` зі вмістом `asdf`, та файл `quux` зі вмістом `quux`. Початкові коміти порівнюються з порожнім деревом, тому `I` — це !TREESAME.

* У `A`, `foo` містить лише `foo`.

* `B` містить таку саму зміну, як і `A`. Його злиття `M` є тривіальним і, отже, є TREESAME для всіх батьківських об'єктів.

* `C` не змінює `foo`, але його злиття `N` змінює його на `foobar`, тому воно не є TREESAME для жодного з батьківських об'єктів.

* `D` встановлює `foo` в `baz`. Його злиття `O` поєднує рядки з `N` та `D` у `foobarbaz`; тобто воно не є TREESAME для жодного з батьківських елементів.

* `E` змінює `quux` на `xyzzy`, а його злиття `P` об'єднує рядки в `quux xyzzy`. `P` перетворюється на TREESAME на `O`, але не на `E`.

* `X` — це незалежний кореневий коміт, який додав новий файл `side`, а `Y` змінив його. `Y` — це TREESAME до `X`. Його злиття `Q` додало `side` до `P`, а `Q` — це TREESAME до `P`, але не до `Y`.

`rev-list` переглядає історію назад, включаючи або виключаючи коміти залежно від того, чи використовується `--full-history` та/або перезапис батьківських елементів (через `--parents` або `--children`). Доступні такі налаштування.

Режим за замовчуванням::
	Коміти включаються, якщо вони не є TREESAME для жодного з батьківських об'єктів (хоча це можна змінити, див. `--sparse` нижче). Якщо коміт був злиттям, і він був TREESAME для одного з батьківських об'єктів, слідкуйте лише за цим батьківським об'єктом. (Навіть якщо батьківських об'єктів TREESAME кілька, слідкуйте лише за одним з них.) В іншому випадку, слідкуйте за всіма батьківськими об'єктами.
+
Це призводить до:
+
-----------------------------------------------------------------------
	  .-A---N---O
	 /     /   /
	I---------D
-----------------------------------------------------------------------
+
Зверніть увагу, як правило слідування лише батьківському елементу TREESAME, якщо такий доступний, повністю виключило `B` з розгляду. `C` розглядався через `N`, але є TREESAME. Кореневі коміти порівнюються з порожнім деревом, тому `I` є !TREESAME.
+
Зв'язки батьків/дитина видно лише за допомогою `--parents`, але це не впливає на коміти, вибрані в режимі за замовчуванням, тому ми показали батьківські рядки.

`--full-history` без переписування батьків::
	Цей режим відрізняється від режиму за замовчуванням в одному пункті: завжди слідувати всім батьківським об'єктам злиття, навіть якщо воно є TREESAME для одного з них. Навіть якщо більше ніж одна сторона злиття має включені коміти, це не означає, що саме злиття є таким! У прикладі ми отримуємо
+
-----------------------------------------------------------------------
	I  A  B  N  D  O  P  Q
-----------------------------------------------------------------------
+
`M` було виключено, оскільки воно є TREESAME для обох батьків. `E`, `C` та `B` були пройдені, але лише `B` було !TREESAME, тому інші не відображаються.
+
Зверніть увагу, що без переписування батьківських елементів насправді неможливо говорити про батьківські/дочірні зв'язки між коммітами, тому ми показуємо їх як роз'єднані.

`--full-history` з переписуванням батьків::
	Звичайні коміти включаються лише якщо вони мають значення !TREESAME (хоча це можна змінити, див. `--sparse` нижче).
+
Злиття завжди включаються. Однак список батьківських елементів переписується: вздовж кожного батьківського елемента видаляються коміти, які самі не включені. Це призводить до
+
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /
	I     B   /   D   /
	 \   /   /   /   /
	  `-------------'
-----------------------------------------------------------------------
+
Порівняйте з `--full-history` без перезапису вище. Зверніть увагу, що `E` було видалено, оскільки воно є TREESAME, але батьківський список P було переписано, щоб містити батьківський `I` для `E`. Те саме сталося для `C` та `N`, а також `X`, `Y` та `Q`.

Окрім вищезазначених налаштувань, ви можете змінити, чи впливає TREESAME на включення:

`--dense`::
	Коміти, які пройдено, включаються, якщо вони не є TREESAME для жодного з батьківських об'єктів.

`--sparse`::
	Включаються всі пройдені коміти.
+
Зверніть увагу, що без `--full-history` це все одно спрощує злиття: якщо один з батьківських елементів є TREESAME, ми слідуємо лише за ним, тому інші сторони злиття ніколи не обходяться.

`--simplify-merges`::
	Спочатку побудуйте граф історії так само, як це робить `--full-history` з батьківським перезаписом (див. вище).
+
Потім спростіть кожен коміт `C` до його заміни `C`` у фінальній історії відповідно до наступних правил:
+
--
* Встановіть `C`` на `C`.
+
* Замініть кожного батьківського елемента `P` з `C'' на його спрощений `P''. У процесі, видаліть батьківських елементів, які є предками інших батьківських елементів або кореневих елементів, що коміти TREESAME до порожнього дерева та видаліть дублікати, але будьте обережні, щоб ніколи не видаляти всіх батьківських елементів, до яких ми є TREESAME.
+
* Якщо після цього перезапису батьківського елемента, `C'' є кореневим або злиттям-комітом (має нуль або >1 батьків), граничним комітом або !TREESAME, він залишається. В іншому випадку він замінюється своїм єдиним батьківським елементом.
--
+
Ефект цього найкраще продемонструвати шляхом порівняння з `--full-history` з перезаписом батьківських елементів. Приклад перетворюється на:
+
-----------------------------------------------------------------------
	  .-A---M---N---O
	 /     /       /
	I     B       D
	 \   /       /
	  `---------'
-----------------------------------------------------------------------
+
Зверніть увагу на основні відмінності між `N`, `P` та `Q` порівняно з `--full-history`:
+
--
* З батьківського списку `N` було видалено `I`, оскільки він є предком іншого батьківського списку `M`. Тим не менш, `N` залишився, оскільки він є !TREESAME.
+
* З батьківського списку `P` аналогічно було видалено `I`. `P` потім було видалено повністю, оскільки він мав одного батька та є TREESAME.
+
* У батьківському списку `Q` `Y` було спрощено до `X`. `X` потім було видалено, оскільки він був коренем TREESAME. `Q` потім було повністю видалено, оскільки він мав одного батька і є TREESAME.
--

Існує ще один режим спрощення:

`--ancestry-path[=<commit>]`::
	Обмежити відображення комітів тими, що є предком _<commit>_, або тими, що є нащадком _<commit>_, або тими, що є самим _<commit>_.
+
Як приклад використання, розглянемо наступну історію комітів:
+
-----------------------------------------------------------------------
	    D---E-------F
	   /     \       \
	  B---C---G---H---I---J
	 /                     \
	A-------K---------------L--M
-----------------------------------------------------------------------
+
Звичайна команда 'D..M' обчислює набір комітів, які є предками `M`, але виключає ті, що є предками `D`. Це корисно, щоб побачити, що сталося з історією, що призвела до `M` з часів `D`, у сенсі "що має `M` такого, чого не існувало в `D`". Результатом у цьому прикладі будуть усі коміти, крім `A` та `B` (і самого `D`, звичайно).
+
Однак, коли ми хочемо з'ясувати, які коміти в `M` заражені помилкою, внесеною `D`, і потребують виправлення, ми можемо переглянути лише підмножину `D..M`, які насправді є нащадками `D`, тобто виключаючи `C` та `K`. Саме це робить опція `--ancestry-path`. Застосована до діапазону `D..M`, вона дає:
+
-----------------------------------------------------------------------
		E-------F
		 \       \
		  G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
Ми також можемо використовувати `--ancestry-path=D` замість `--ancestry-path`, що означає те саме, якщо застосувати його до діапазону `D..M`, але є більш чітким.
+
Якщо нас цікавить певна тема в цьому діапазоні та всі коміти, на які впливає ця тема, ми можемо переглянути лише підмножину `D..M`, які містять цю тему у своєму шляху походження. Отже, використання `--ancestry-path=H D..M`, наприклад, призведе до:
+
-----------------------------------------------------------------------
		E
		 \
	      C---G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
Тоді як `--ancestry-path=K D..M` призведе до
+
-----------------------------------------------------------------------
		K---------------L--M
-----------------------------------------------------------------------

Перш ніж обговорювати інший параметр, `--show-pulls`, нам потрібно створити новий приклад історії.

Поширена проблема, з якою стикаються користувачі під час перегляду спрощеної історії, полягає в тому, що коміт, про який вони знають, що змінив файл, якимось чином не відображається у спрощеній історії файлу. Давайте продемонструємо новий приклад і покажемо, як у цьому випадку працюють такі опції, як `--full-history` та `--simplify-merges`:

-----------------------------------------------------------------------
	  .-A---M-----C--N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`-Z'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `---Y--'
-----------------------------------------------------------------------

Для цього прикладу, припустимо, що `I` створив `file.txt`, який був змінений `A`, `B` та `X` різними способами. Коміти з одним батьківським файлом `C`, `Z` та `Y` не змінюють `file.txt`. Коміт злиття `M` був створений шляхом вирішення конфлікту злиття, щоб включити обидві зміни з `A` та `B`, і тому не є TREESAME для жодного з них. Однак коміт злиття `R` був створений шляхом ігнорування вмісту `file.txt` у `M` та взяття лише вмісту `file.txt` у `X`. Отже, `R` є TREESAME для `X`, але не `M`. Зрештою, природним рішенням злиття для створення `N` є взяття вмісту `file.txt` у `R`, тому `N` є TREESAME для `R`, але не для `C`. Коміти злиття `O` та `P` є TREESAME для своїх перших батьків, але не для своїх других батьків, `Z` та `Y` відповідно.

У режимі за замовчуванням, `N` та `R` мають батьківський елемент TREESAME, тому ці ребра обходяться, а інші ігноруються. Результуючий граф історії має такий вигляд:

-----------------------------------------------------------------------
	I---X
-----------------------------------------------------------------------

При використанні `--full-history`, Git проходить кожне ребро. Це виявить коміти `A` та `B`, а також коміти злиття `M`, а також покаже коміти злиття `O` та `P`. Після перезапису батьківських елементів результуючий граф буде таким:

-----------------------------------------------------------------------
	  .-A---M--------N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`--'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `------'
-----------------------------------------------------------------------

Тут коміти злиття `O` та `P` створюють додатковий шум, оскільки вони фактично не внесли змін до `file.txt`. Вони лише об'єднали тему, яка базувалася на старішій версії `file.txt`. Це поширена проблема в репозиторіях, де багато учасників працюють паралельно та об'єднують свої тематичні гілки вздовж однієї магістралі: багато непов'язаних злиття відображаються в результатах `--full-history`.

При використанні опції `--simplify-merges` коміти `O` та `P` зникають з результатів. Це тому, що переписані другі батьки `O` та `P` доступні з їхніх перших батьків. Ці ребра видаляються, і тоді коміти виглядають як коміти з одним батьківським елементом, які є TREESAME для свого батька. Це також відбувається з комітом `N`, що призводить до наступного вигляду історії:

-----------------------------------------------------------------------
	  .-A---M--.
	 /     /    \
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------

У цьому поданні ми бачимо всі важливі зміни для єдиного батьківського елемента з `A`, `B` та `X`. Ми також бачимо ретельно вирішене злиття `M` та не дуже ретельно вирішене злиття `R`. Зазвичай цієї інформації достатньо, щоб визначити, чому коміти `A` та `B` "зникли" з історії у поданні за замовчуванням. Однак, з таким підходом є кілька проблем.

Перша проблема — це продуктивність. На відміну від будь-якої попередньої опції, опція `--simplify-merges` вимагає перегляду всієї історії комітів, перш ніж повернути один результат. Це може ускладнити використання цієї опції для дуже великих репозиторіїв.

Друга проблема стосується аудиту. Коли багато учасників працюють над одним репозиторієм, важливо, які коміти злиття внесли зміни у важливу гілку. Проблемне злиття `R` вище, ймовірно, не є тим комітом злиття, який було використано для злиття у важливу гілку. Натомість, для злиття `R` та `X` у важливу гілку було використано злиття `N`. Цей коміт може містити інформацію про те, чому зміна `X` перевизначила зміни з `A` та `B` у своєму повідомленні коміту.

`--show-pulls`::
	На додаток до комітів, що відображаються в історії за замовчуванням, покажіть кожен коміт злиття, який не є TREESAME для свого першого батьківського об'єкта, але є TREESAME для пізнішого батьківського об'єкта.
+
Коли коміт злиття включається за допомогою `--show-pulls`, злиття обробляється так, ніби воно "витягнуло" зміни з іншої гілки. При використанні `--show-pulls` у цьому прикладі (і без інших опцій) результуючий графік має такий вигляд:
+
-----------------------------------------------------------------------
	I---X---R---N
-----------------------------------------------------------------------
+
Тут включено коміти злиття `R` та `N`, оскільки вони перенесли коміти `X` та `R` відповідно до базової гілки. Ці злиття є причиною того, що коміти `A` та `B` не відображаються в історії за замовчуванням.
+
Коли `--show-pulls` поєднується з `--simplify-merges`, графік містить всю необхідну інформацію:
+
-----------------------------------------------------------------------
	  .-A---M--.   N
	 /     /    \ /
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------
+
Зверніть увагу, що оскільки `M` досяжний з `R`, ребро від `N` до `M` було спрощено. Однак, `N` все ще відображається в історії як важливий коміт, оскільки він "переніс" зміну `R` в головну гілку.

Опція `--simplify-by-decoration` дозволяє переглядати лише загальну картину топології історії, пропускаючи коміти, на які не посилаються теги. Коміти позначаються як !TREESAME (іншими словами, зберігаються після правил спрощення історії, описаних вище), якщо (1) на них посилаються теги, або (2) вони змінюють вміст шляхів, заданих у командному рядку. Усі інші коміти позначаються як TREESAME (підлягають видаленню за допомогою спрощення).

ifndef::git-shortlog[]
ifdef::git-rev-list[]
Помічники з бісекції
~~~~~~~~~~~~~~~~~~~~

`--bisect`::
	Обмежити вивід одним об'єктом коміту, який приблизно знаходиться посередині між включеними та виключеними комітами. Зверніть увагу, що погане посилання на бісекцію `refs/bisect/bad` додається до включених комітів (якщо воно існує), а хороші посилання на бісекцію `refs/bisect/good-*` додаються до виключених комітів (якщо вони існують). Таким чином, припустимо, що в `refs/bisect/` немає посилань, якщо
+
-----------------------------------------------------------------------
	$ git rev-list --bisect foo ^bar ^baz
-----------------------------------------------------------------------
+
виводить «середню точку», вивід двох команд
+
-----------------------------------------------------------------------
	$ git rev-list foo ^midpoint
	$ git rev-list midpoint ^bar ^baz
-----------------------------------------------------------------------
+
матиме приблизно таку ж довжину. Пошук зміни, яка вводить регресію, таким чином зводиться до бінарного пошуку: багаторазово генерувати та тестувати нові «середні точки», доки ланцюжок комітів не досягне довжини одиниці.

`--bisect-vars`::
	Це обчислює те саме, що й `--bisect`, за винятком того, що посилання в `refs/bisect/` не використовуються, і за винятком того, що це виводить текст, готовий до оцінки оболонкою. Ці рядки присвоїть назву середньої ревізії змінній `bisect_rev`, а очікувану кількість комітів, які будуть перевірені після перевірки `bisect_rev`, змінній `bisect_nr`, очікувану кількість комітів, які будуть перевірені, якщо `bisect_rev` виявиться хорошим, `bisect_good`, очікувану кількість комітів, які будуть перевірені, якщо `bisect_rev` виявиться поганим, `bisect_bad`, та кількість комітів, які ми зараз ділимо, `bisect_all`.

`--bisect-all`::
	Це виводить усі об'єкти комітів між включеними та виключеними комітами, упорядковані за їхньою відстанню до включених та виключених комітів. Посилання в `refs/bisect/` не використовуються. Найдальше від них відображається першим. (Це єдине, що відображається за допомогою `--bisect`.)
+
Це корисно, оскільки дозволяє легко вибрати хороший коміт для тестування, коли ви хочете уникнути тестування деяких із них з певної причини (наприклад, вони можуть не компілюватися).
+
Цю опцію можна використовувати разом з `--bisect-vars`, у цьому випадку після всіх відсортованих об'єктів комітів буде той самий текст, як якби `--bisect-vars` використовувався окремо.
endif::git-rev-list[]
endif::git-shortlog[]

ifndef::git-shortlog[]
Порядок фіксації
~~~~~~~~~~~~~~~~

За замовчуванням коміти відображаються у зворотному хронологічному порядку.

`--date-order`::
	Не показувати батьківських об'єктів, поки не будуть показані всі дочірні об'єкти, але в іншому випадку показувати коміти в порядку позначок часу комітів.

`--author-date-order`::
	Не показувати батьківських об'єктів, перш ніж будуть показані всі його дочірні об'єкти, але в іншому випадку показувати коміти в порядку позначення часу автора.

`--topo-order`::
	Не показувати батьківських об'єктів, поки не будуть показані всі їхні дочірні об'єкти, та уникати показу комітів у кількох переплетених рядках історії.
+
Наприклад, у такій історії комітів:
+
----------------------------------------------------------------

    ---1----2----4----7
	\	       \
	 3----5----6----8---

----------------------------------------------------------------
+
де числа позначають порядок позначок часу комітів, `git rev-list` та друзі з `--date-order` показують коміти в порядку позначок часу: 8 7 6 5 4 3 2 1.
+
З `--topo-order` вони б показали 8 6 5 3 7 4 2 1 (або 8 7 4 2 6 5 3 1); деякі старіші коміти показуються перед новішими, щоб уникнути показу комітів з двох паралельних треків розробки разом.

`--reverse`::
	Вивести вибрані коміти для відображення (див. розділ «Обмеження комітів» вище) у зворотному порядку. Не можна поєднувати з `--walk-reflogs`.
endif::git-shortlog[]

ifndef::git-shortlog[]
Обхід об'єкта
~~~~~~~~~~~~~

Ці опції здебільшого призначені для пакування репозиторіїв Git.

ifdef::git-rev-list[]
`--objects`::
	Вивести ідентифікатори об'єктів будь-якого об'єкта, на який посилаються перелічені коміти. `--objects foo ^bar` таким чином означає "надіслати мені всі ідентифікатори об'єктів, які мені потрібно завантажити, якщо в мене є об'єкт коміту `bar`, але немає `foo`". Див. також `--object-names` нижче.

`--in-commit-order`::
	Вивести ідентифікатори дерев та блобів у порядку комітів. Ідентифікатори дерев та блобів виводяться після першого посилання на них у коміті.

`--objects-edge`::
	Подібно до `--objects`, але також виводить ідентифікатори виключених комітів з префіксом "`-`". Це використовується linkgit:git-pack-objects[1] для створення "тонкого" пакету, який записує об'єкти у дельтифікованій формі на основі об'єктів, що містяться в цих виключених комітах, для зменшення мережевого трафіку.

`--objects-edge-aggressive`::
	Подібно до `--objects-edge`, але намагається знайти виключені коміти ціною збільшення часу. Це використовується замість `--objects-edge` для створення «тонких» пакетів для поверхневих репозиторіїв.

`--indexed-objects`::
	Зробіть вигляд, що всі дерева та блоби, що використовуються індексом, перелічені в командному рядку. Зверніть увагу, що ви, ймовірно, також захочете використовувати `--objects`.

`--unpacked`::
	Корисно лише з `--objects`; вивести ідентифікатори об'єктів, які не входять до пакетів.

`--object-names`::
	Корисно лише з `--objects`; вивести назви знайдених ідентифікаторів об'єктів. Це поведінка за замовчуванням. Зверніть увагу, що "ім'я" кожного об'єкта неоднозначне і здебільшого призначене як підказка для пакування об'єктів. Зокрема: не розрізняється назва тегів, дерев і блобів; назви шляхів можна змінювати, щоб видалити символи нового рядка; і якщо об'єкт з'являється кілька разів з різними назвами, відображається лише одна назва.

`--no-object-names`::
	Корисно лише з `--objects`; не виводить назви знайдених ідентифікаторів об'єктів. Це інвертує `--object-names`. Цей прапорець дозволяє легше розбирати вивід за допомогою команд, таких як linkgit:git-cat-file[1].

`--filter=<filter-spec>`::
	Корисно лише з одним із `--objects*`; пропускає об'єкти (зазвичай блоби) зі списку друкованих об'єктів. _<специфікація-фільтра>_ може бути одним із наступних:
+
Форма `--filter=blob:none` пропускає всі блоби.
+
Форма `--filter=blob:limit=<n>[kmg]` пропускає блоби розміром щонайменше _<n>_ байтів або одиниць. _<n>_ може дорівнювати нулю. Суфікси `k`, `m` та `g` можна використовувати для найменування одиниць у KiB, MiB або GiB. Наприклад, `blob:limit=1k` те саме, що й 'blob:limit=1024'.
+
Форма `--filter=object:type=(tag|commit|tree|blob)` пропускає всі об'єкти, які не належать до запитуваного типу.
+
Форма `--filter=sparse:oid=<blob-ish>` використовує специфікацію розрідженого отримання, що міститься в блобі (або блоб-виразі) _<blob-ish>_, щоб пропустити блоби, які не потрібні для розрідженого отримання на запитуваних посиланнях.
+
Форма `--filter=tree:<depth>` пропускає всі блоби та дерева, глибина яких від кореневого дерева дорівнює >= _<depth>_ (мінімальна глибина, якщо об'єкт розташований на кількох глибинах у пройдених коммітах). _<depth>_=0 не включатиме жодних дерев або блобів, якщо вони явно не включені в командному рядку (або стандартному вводі, коли використовується `--stdin`). _<depth>_=1 включатиме лише дерево та блоби, на які безпосередньо посилається коміт, досягнутий з _<commit>_ або явно заданого об'єкта. _<depth>_=2 подібна до <depth>=1, але також включає дерева та блоби, на один рівень віддалені від явно заданого коміту або дерева.
+
Зверніть увагу, що форму `--filter=sparse:path=<шлях>`, яка хоче читати з довільного шляху у файловій системі, було видалено з міркувань безпеки.
+
Для об'єднання фільтрів можна вказати кілька прапорців `--filter=`. Включаються лише об'єкти, які приймаються кожним фільтром.
+
Форму `--filter=combine:<filter1>+<filter2>+...<filterN>` також можна використовувати для об'єднання кількох фільтрів, але це складніше, ніж просто повторювати прапорець `--filter`, і зазвичай це не потрібно. Фільтри об'єднуються за допомогою '{plus}', а окремі фільтри мають %-кодування (тобто URL-кодування). Окрім символів '{plus}' та '%', наступні символи зарезервовані та також мають бути закодовані: `~!@#$^&*()[]{}\;",<>?`+&#39;&#96;+ а також усі символи з кодом ASCII &lt;= `0x20`, включаючи пробіл та символ нового рядка.
+
Також можна закодувати інші довільні символи. Наприклад, `combine:tree:3+blob:none` та `combine:tree%3A3+blob%3Anone` є еквівалентними.

`--no-filter`::
	Вимкніть будь-який попередній аргумент `--filter=`.

`--filter-provided-objects`::
	Фільтрувати список явно заданих об'єктів, які в іншому випадку завжди друкувалися б, навіть якщо б вони не відповідали жодному з фільтрів. Корисно лише з `--filter=`.

`--filter-print-omitted`::
	Корисно лише з `--filter=`; друкує список об'єктів, пропущених фільтром. Ідентифікатори об'єктів починаються з символу ``~''.

`--missing=<missing-action>`::
	Опція налагодження, яка допоможе в майбутній розробці "часткового клонування". Ця опція визначає, як обробляються відсутні об'єкти.
+
Форма `--missing=error` вимагає, щоб список переглядів зупинився з помилкою, якщо виявлено відсутній об'єкт. Це дія за замовчуванням.
+
Форма `--missing=allow-any` дозволить продовжити обхід об'єкта, якщо буде виявлено відсутній об'єкт. Відсутні об'єкти будуть непомітно пропущені з результатів.
+
Форма `--missing=allow-promisor` подібна до `allow-any`, але дозволить продовження обходу об'єктів лише для ОЧІКУВАНИХ відсутніх об'єктів promisor. Неочікувано відсутні об'єкти викличуть помилку.
+
Форма `--missing=print` подібна до `allow-any`, але також виведе список відсутніх об'єктів. Ідентифікатори об'єктів починаються з символу ``?''.
+
Форма `--missing=print-info` подібна до `print`, але також виведе додаткову інформацію про відсутній об'єкт, виведену з об'єкта, що його містить. Вся інформація виводиться в одному рядку з ідентифікатором відсутнього об'єкта у формі: `?<oid> [<токен>=<значення>]...`. Пари `<токен>=<значення>`, що містять додаткову інформацію, відокремлюються одна від одної за допомогою _SP_. Значення кодується специфічним для токена способом, але _SP_ або _LF_, що містяться в значенні, завжди мають бути представлені таким чином, щоб результуюче закодоване значення не мало жодного з цих двох проблемних байтів. Кожен `<токен>=<значення>` може бути одним із наступних:
+
--
* `path=<шлях>` показує шлях до відсутнього об'єкта, виведений з об'єкта-містка. Шлях, що містить _SP_ або спеціальні символи, за потреби береться в подвійні лапки у стилі C.
+
* `type=<тип>` показує тип відсутнього об'єкта, виведений з об'єкта, який його містить.
--
+
Якщо деякі підказки, передані під час обходу, відсутні, вони також вважатимуться відсутніми, і обхід їх проігнорує. Однак, якщо нам не вдасться отримати їхній ідентифікатор об'єкта, буде викликана помилка.

`--exclude-promisor-objects`::
	(Тільки для внутрішнього використання.) Попередня фільтрація обходу об'єкта на межі промісора. Використовується з частковим клонуванням. Це сильніше, ніж `--missing=allow-promisor`, оскільки обмежує обхід, а не просто заглушує помилки про відсутні об'єкти.
endif::git-rev-list[]

`--no-walk[=(sorted|unsorted)]`::
	Показувати лише задані коміти, але не проходити через їхніх предків. Це не має ефекту, якщо вказано діапазон. Якщо вказано аргумент `unsorted`, коміти відображаються в порядку, в якому вони були введені в командному рядку. В іншому випадку (якщо `sorted` або аргумент не вказано), коміти відображаються у зворотному хронологічному порядку за часом коміту. Не можна поєднувати з `--graph`.

`--do-walk`::
	Замінює попередній `--no-walk`.
endif::git-shortlog[]

ifndef::git-shortlog[]
Форматування комітів
~~~~~~~~~~~~~~~~~~~~

ifdef::git-rev-list[]
Використовуючи ці опції, linkgit:git-rev-list[1] працюватиме подібно до більш спеціалізованої родини інструментів для ведення журналу комітів:
ifndef::with-breaking-changes[]
linkgit:git-log[1], linkgit:git-show[1], і linkgit:git-whatchanged[1].
endif::with-breaking-changes[]
ifdef::with-breaking-changes[]
linkgit:git-log[1] і linkgit:git-show[1].
endif::with-breaking-changes[]
endif::git-rev-list[]

include::pretty-options.adoc[]

`--relative-date`::
	Синонім до `--date=relative`.

`--date=<format>`::
	Діє лише для дат, відображених у форматі, зрозумілому для людини, наприклад, при використанні `--pretty`. Змінна конфігурації `log.date` встановлює значення за замовчуванням для опції `--date` команди log. За замовчуванням дати відображаються в оригінальному часовому поясі (або комітера, або автора). Якщо до формату додається `-local` (наприклад, `iso-local`), замість цього використовується локальний часовий пояс користувача.
+
--
`--date=relative` показує дати відносно поточного часу, наприклад, ``2 години тому''. Опція `-local` не має жодного ефекту для `--date=relative`.

`--date=local` є псевдонімом для `--date=default-local`.

`--date=iso` (або `--date=iso8601`) показує позначки часу у форматі, подібному до ISO 8601. Відмінності від суворого формату ISO 8601:

	- пробіл замість роздільника дати/часу `T`
	- простір між часом і часовим поясом
	- без двокрапки між годинами та хвилинами часового поясу

`--date=iso-strict` (або `--date=iso8601-strict`) показує позначки часу у суворому форматі ISO 8601.

`--date=rfc` (або `--date=rfc2822`) показує позначки часу у форматі RFC 2822, які часто зустрічаються в електронних повідомленнях.

`--date=short` показує лише дату, але не час, у форматі `РРРР-ММ-ДД`.

`--date=raw` показує дату в секундах з епохи (1970-01-01 00:00:00 UTC), після чого йде пробіл, а потім часовий пояс як зміщення відносно UTC (`+` або `-` з чотирма цифрами; перші дві - години, а другі дві - хвилини). Тобто, ніби позначка часу була відформатована за допомогою `strftime("%s %z")`). Зверніть увагу, що опція `-local` не впливає на значення seconds-since-epoch (яке завжди вимірюється в UTC), але змінює супутнє значення часового поясу.

`--date=human` показує часовий пояс, якщо часовий пояс не відповідає поточному часовому поясу, і не друкує повну дату, якщо вона збігається (тобто пропускає вивід року для дат, які є "цього року", але також пропускає всю дату, якщо вона в останні кілька днів, і ми можемо просто сказати, який це був день тижня). Для старіших дат година та хвилина також пропускаються.

`--date=unix` показує дату як позначку часу епохи Unix (секунди з 1970 року). Як і у випадку з `--raw`, це завжди в UTC, тому `-local` не має жодного ефекту.

`--date=format:<format>` передає _<format>_ до вашої системної `strftime`, за винятком `%s`, `%z` та `%Z`, які обробляються внутрішньо. Використовуйте `--date=format:%c`, щоб відобразити дату у форматі, що відповідає бажаному формату вашої системної локалізації. Повний список заповнювачів формату дивіться в посібнику `strftime`(3). Під час використання `-local` правильний синтаксис — `--date=format-local:<format>`.

`--date=default` – це формат за замовчуванням, який базується на виводі ctime(3). Він показує один рядок із трилітерним днем тижня, трилітерним місяцем, днем місяця, годинами-хвилинами-секундами у форматі "ГГ:ХХ:СС", далі 4-значний рік та інформація про часовий пояс, якщо не використовується місцевий часовий пояс, наприклад, `Thu Jan 1 00:00:00 1970 +0000`.
--

ifdef::git-rev-list[]
`--header`::
	Вивести вміст коміту у форматі RAW; кожен запис розділяється символом NUL.

`--no-commit-header`::
	Приховувати рядок заголовка, що містить "commit" та ідентифікатор об'єкта, що друкується перед зазначеним форматом. Це не впливає на вбудовані формати; впливають лише на користувацькі формати.

`--commit-header`::
	Перезаписує попередній `--no-commit-header`.
endif::git-rev-list[]

`--parents`::
	Також вивести батьківські елементи коміту (у форматі "commit parent..."). Також увімкнути перезапис батьківських елементів, див. "Спрощення історії" вище.

`--children`::
	Також вивести дочірні елементи коміта (у формі "commit child..."). Також увімкнути перезапис батьківських елементів, див. "Спрощення історії" вище.

ifdef::git-rev-list[]
`--timestamp`::
	Вивести необроблену часову позначку коміту.
endif::git-rev-list[]

`--left-right`::
	Позначає, з якої сторони симетричної різниці досяжний коміт. Коміти з лівого боку мають префікс `<`, а з правого - `>`. У поєднанні з `--boundary` ці коміти мають префікс `-`.
+
Наприклад, якщо у вас така топологія:
+
-----------------------------------------------------------------------
	     y---b---b  branch B
	    / \ /
	   /   .
	  /   / \
	 o---x---a---a  branch A
-----------------------------------------------------------------------
+
ви отримаєте такий результат:
+
-----------------------------------------------------------------------
	$ git rev-list --left-right --boundary --pretty=oneline A...B

	>bbbbbbb... 3rd on b
	>bbbbbbb... 2nd on b
	<aaaaaaa... 3rd on a
	<aaaaaaa... 2nd on a
	-yyyyyyy... 1st on b
	-xxxxxxx... 1st on a
-----------------------------------------------------------------------

`--graph`::
	Намалюйте текстове графічне представлення історії комітів у лівій частині виводу. Це може призвести до друку додаткових рядків між коммітами, щоб історія графу відображалася правильно. Не можна поєднувати з `--no-walk`.
+
Це дозволяє переписування батьківських елементів, див. розділ «Спрощення історії» вище.
+
Це означає використання опції `--topo-order` за замовчуванням, але також можна вказати опцію `--date-order`.

`--show-linear-break[=<barrier>]`::
	Коли `--graph` не використовується, усі гілки історії згладжуються, що може ускладнити визначення того, що два послідовні коміти не належать до лінійної гілки. У такому випадку ця опція встановлює бар'єр між ними. Якщо вказано _<бар'єр>_, то замість рядка за замовчуванням буде показано саме цей рядок.

ifdef::git-rev-list[]
`--count`::
	Виведіть число, яке вказує, скільки комітів було б перераховано, та приховуйте весь інший вивід. При використанні разом з `--left-right`, натомість виведіть кількість лівих та правих комітів, розділених табуляцією. При використанні разом з `--cherry-mark`, пропустіть еквівалентні коміти з цих підрахунків та виведіть кількість еквівалентних комітів, розділених табуляцією.
endif::git-rev-list[]
endif::git-shortlog[]
