git-clone(1)
============

НАЗВА
-----
git-clone - Клонування репозиторію в новий каталог


СИНОПСИС
--------
[synopsis]
git clone [--template=<каталог-шаблонів>]
	  [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]
	  [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]
	  [--dissociate] [--separate-git-dir <git-dir>]
	  [--depth <depth>] [--[no-]single-branch] [--[no-]tags]
	  [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]
	  [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--[no-]reject-shallow]
	  [--filter=<filter-spec>] [--also-filter-submodules]] [--] <repository>
	  [<directory>]

ОПИС
----

Клонує репозиторій у новостворений каталог, створює гілки віддаленого відстеження для кожної гілки в клонованому репозиторії (видимо за допомогою `git branch --remotes`), а також створює та отримує початкову гілку, яка є відгалуженням від поточної активної гілки клонованого репозиторію.

Після клонування, звичайна команда `git fetch` без аргументів оновить усі гілки віддаленого відстеження, а команда `git pull` без аргументів додатково об'єднає віддалену гілку master з поточною гілкою master, якщо така є (це невірно, коли вказано `--single-branch`; див. нижче).

Ця конфігурація за замовчуванням досягається шляхом створення посилань на заголовки віддалених гілок у `refs/remotes/origin` та ініціалізації змінних конфігурації `remote.origin.url` та `remote.origin.fetch`.


ОПЦІЇ
-----
`-l`::
`--local`::
	Коли репозиторій для клонування знаходиться на локальному комп'ютері, цей прапорець обходить звичайний механізм транспортування "Git aware" та клонує репозиторій, створюючи копію `HEAD` та всього, що знаходиться в каталогах objects та refs. Файли в каталозі `.git/objects/` жорстко пов'язані для економії місця, коли це можливо.
+
Якщо репозиторій вказано як локальний шлях (наприклад, `/шлях/до/репозиторію`), це значення за замовчуванням, а `--local` по суті є забороною на виконання. Якщо репозиторій вказано як URL-адресу, то цей прапорець ігнорується (і ми ніколи не використовуємо локальні оптимізації). Вказівка `--no-local` замінить значення за замовчуванням, коли вказано `/шлях/до/репозиторію`, замість нього використовуватиметься звичайний транспорт Git.
+
Якщо каталог `$GIT_DIR/objects` репозиторію містить символічні посилання або є символічним посиланням, клонування не вдасться. Це захід безпеки для запобігання ненавмисному копіюванню файлів шляхом розіменування символічних посилань.
+
Ця опція не працює з репозиторіями, що належать іншим користувачам, з міркувань безпеки, і для успішного клонування необхідно вказати `--no-local`.
+
*ПРИМІТКА*: ця операція може спрацьовувати з одночасною модифікацією репозиторію вихідного коду, подібно до виконання `cp -r <src> <dst>` під час модифікації _<src>_.

`--no-hardlinks`::
	Примусово запустіть процес клонування з репозиторію на локальній файловій системі, щоб скопіювати файли в каталог `.git/objects` замість використання жорстких посилань. Це може бути доцільним, якщо ви намагаєтеся створити резервну копію свого репозиторію.

`-s`::
`--shared`::
	Коли репозиторій для клонування знаходиться на локальному комп'ютері, замість використання жорстких посилань, автоматично налаштуйте `.git/objects/info/alternates` для спільного використання об'єктів з вихідним репозиторієм. Отриманий репозиторій спочатку працюватиме без жодного власного об'єкта.
+
*ПРИМІТКА*: це потенційно небезпечна операція; *не* використовуйте її, якщо не розумієте, що вона робить. Якщо ви клонуєте свій репозиторій за допомогою цієї опції, а потім видалите гілки (або використаєте будь-яку іншу команду Git, яка робить будь-який існуючий коміт без посилання) у вихідному репозиторії, деякі об'єкти можуть стати без посилання (або завислими). Ці об'єкти можуть бути видалені звичайними операціями Git (такими як `git commit`), які автоматично викликають `git maintenance run --auto`. (Див. linkgit:git-maintenance[1].) Якщо ці об'єкти будуть видалені, і на них посилався клонований репозиторій, то клонований репозиторій буде пошкоджено.
+
Зверніть увагу, що запуск `git repack` без опції `--local` у репозиторії, клонованому за допомогою `--shared`, призведе до копіювання об'єктів з вихідного репозиторію в пакет у клонованому репозиторії, що призведе до втрати дискового простору, збереженого за допомогою `clone --shared`. Однак безпечно запускати `git gc`, який за замовчуванням використовує опцію `--local`.
+
Якщо ви хочете розірвати залежність репозиторію, клонованого за допомогою `--shared`, від його вихідного репозиторію, ви можете просто виконати `git repack -a`, щоб скопіювати всі об'єкти з вихідного репозиторію в пакет у клонованому репозиторії.

`--reference[-if-able] <репозиторій>`::
	Якщо посилання _<repository>_ знаходиться на локальному комп'ютері, автоматично налаштувати `.git/objects/info/alternates` для отримання об'єктів з посилання _<repository>_. Використання вже існуючого репозиторію як альтернативного вимагатиме копіювання меншої кількості об'єктів з клонованого репозиторію, що зменшить витрати на мережеве та локальне сховище. Під час використання `--reference-if-able` неіснуючий каталог пропускається з попередженням замість переривання клонування.
+
*ПРИМІТКА*: див. ПРИМІТКУ щодо опції `--shared`, а також опції `--dissociate`.

`--dissociate`::
	Запозичувати об'єкти лише з репозиторіїв-посилань, зазначених за допомогою параметрів `--reference`, щоб зменшити мережеве передавання даних, та припинити запозичення з них після створення клону, створюючи необхідні локальні копії запозичених об'єктів. Цей параметр також можна використовувати під час локального клонування з репозиторію, який вже запозичує об'єкти з іншого репозиторію – новий репозиторій запозичить об'єкти з того ж репозиторію, і цей параметр можна використовувати для зупинки запозичення.

`-q`::
`--quiet`::
	Працюйте тихо. Прогрес не повідомляється у стандартному потоці помилок.

`-v`::
`--verbose`::
	Виконується детально. Не впливає на звітування про стан виконання до стандартного потоку помилок.

`--progress`::
	За замовчуванням статус виконання повідомляється у стандартному потоці помилок, коли він підключений до терміналу, якщо не вказано `--quiet`. Цей прапорець примусово повідомляє про статус виконання, навіть якщо стандартний потік помилок не спрямований до терміналу.

`--server-option=<опція>`::
	Передати заданий рядок на сервер під час зв'язку за протоколом версії 2. Заданий рядок не повинен містити символів NUL або LF. Обробка сервером параметрів сервера, включаючи невідомі, залежить від сервера. Якщо задано кілька параметрів `--server-option=<опція>`, усі вони надсилаються іншій стороні в порядку, зазначеному в командному рядку. Якщо з командного рядка не задано ++--server-option=++__<опція>__, замість них використовуються значення змінної конфігурації `remote.<назва>.serverOption`.

`-n`::
`--no-checkout`::
	Після завершення клонування перевірка `HEAD` не виконується.

`--`[`no-`]`reject-shallow`::
	Невдача, якщо вихідний репозиторій є поверхневим репозиторієм. Змінну конфігурації `clone.rejectShallow` можна використовувати для визначення значення за замовчуванням.

`--bare`::
	Створіть «голий» Git-репозиторій. Тобто, замість створення _<каталог>_ та розміщення адміністративних файлів у `<каталог>/.git`, зробіть сам _<каталог>_ як `$GIT_DIR`. Це, очевидно, передбачає `--no-checkout`, оскільки немає ніде для перевірки робочого дерева. Також заголовки гілок на віддаленому сервері копіюються безпосередньо до відповідних локальних заголовків гілок, без зіставлення їх з `refs/remotes/origin/`. Коли використовується ця опція, не створюються ні гілки віддаленого відстеження, ні пов'язані змінні конфігурації.

`--sparse`::
	Використовуйте розріджене зчитування (sparse-checkout), спочатку зчитуючи лише файли з каталогу верхнього рівня. Команду linkgit:git-sparse-checkout[1] можна використовувати для розширення робочого каталогу за потреби.

`--filter=<filter-spec>`::
	Використовуйте функцію часткового клонування та запитуйте, щоб сервер надсилав підмножину доступних об'єктів відповідно до заданого фільтра об'єктів. Під час використання `--filter`, наданий _<spec-filter>_ використовується для фільтра часткового клонування. Наприклад, `--filter=blob:none` відфільтровуватиме всі блоби (вміст файлу), доки вони не знадобляться Git. Також `--filter=blob:limit=<size>` відфільтровуватиме всі блоби розміром щонайменше _<size>_. Для отримання додаткової інформації про специфікації фільтрів дивіться опцію `--filter` у linkgit:git-rev-list[1].

`--also-filter-submodules`::
	Також застосуйте фільтр часткового клонування до будь-яких підмодулів у репозиторії. Потрібні `--filter` та `--recurse-submodules`. Це можна ввімкнути за замовчуванням, встановивши параметр конфігурації `clone.filterSubmodules`.

`--mirror`::
	Налаштуйте дзеркало вихідного репозиторію. Це означає `--bare`. Порівняно з `--bare`, `--mirror` не лише зіставляє локальні гілки вихідного коду з локальними гілками цільового репозиторію, але й зіставляє всі посилання (включаючи гілки віддаленого відстеження, нотатки тощо) та встановлює конфігурацію refspec таким чином, що всі ці посилання перезаписуються `git remote update` у цільовому репозиторії.

`-o` _<ім'я>_::
`--origin` _<ім'я>_::
	Замість використання віддаленого імені `origin` для відстеження репозиторію основної платформи, використовуйте _<назва>_. Замінює `clone.defaultRemoteName` з конфігурації.

`-b` _<ім'я>_::
`--branch` _<ім'я>_::
	Замість того, щоб вказувати щойно створений `HEAD` на гілку, на яку вказує `HEAD` клонованого репозиторію, вкажіть на гілку _<назва>_. У нечистому репозиторії це гілка, яка буде витягнута. `--branch` також може приймати теги та від'єднувати `HEAD` у цьому коміті в результуючому репозиторії.

`--revision=<оборот>`::
	Створіть новий репозиторій та отримайте історію, що веде до заданої ревізії _<rev>_ (і нічого більше), без створення жодної гілки для віддаленого відстеження та без створення жодної локальної гілки, та від’єднайте `HEAD` від _<rev>_. Аргументом може бути ім’я посилання (наприклад, `refs/heads/main` або `refs/tags/v1.0`), яке зводиться до коміту, або шістнадцяткове ім’я об’єкта. Цей параметр несумісний з `--branch` та `--mirror`.

`-u` _<upload-pack>_::
`--upload-pack` _<завантажувальний пакет>_::
	Якщо вказано, і доступ до репозиторію для клонування здійснюється через ssh, це вказує на шлях, відмінний від стандартного, для команди, що виконується на іншому кінці.

`--template=<каталог-шаблонів>`::
	Вкажіть каталог, з якого будуть використовуватися шаблони; (Див. розділ "КАТАЛОГ ШАБЛОНІВ" у linkgit:git-init[1].)

`-c` `<ключ>=<значення>`::
`--config` `<ключ>=<значення>`::
	Встановіть змінну конфігурації у щойно створеному репозиторії; це набуде чинності одразу після ініціалізації репозиторію, але до отримання історії віддаленого репозиторію або отримання будь-яких файлів. _<key>_ має той самий формат, що й очікується linkgit:git-config[1] (наприклад, `core.eol=true`). Якщо для одного ключа задано кілька значень, кожне значення буде записано у файл конфігурації. Це робить безпечним, наприклад, додавання додаткових специфікацій fetch refspecs до вихідного віддаленого репозиторію.
+
Через обмеження поточної реалізації деякі змінні конфігурації не набувають чинності до початкового отримання та перевірки. Відомо, що змінні конфігурації не набувають чинності: `remote.<name>.mirror` та `remote.<name>.tagOpt`. Натомість використовуйте відповідні опції `--mirror` та `--no-tags`.

`--depth <глибина>`::
	Створити «неглибокий» клон з історією, скороченою до вказаної кількості комітів. Має на увазі `--single-branch`, якщо не вказано `--no-single-branch` для отримання історій поблизу кінчиків усіх гілок. Якщо ви хочете клонувати підмодулі неглибоко, також передайте `--shallow-submodules`.

`--shallow-since=<дата>`::
	Створити поверхневий клон з історією після зазначеного часу.

`--shallow-exclude=<посилання>`::
	Створити поверхневий клон з історією, виключаючи коміти, доступні з вказаної віддаленої гілки або тегу. Цей параметр можна вказати кілька разів.

`--[no-]single-branch`::
	Клонувати лише історію, що веде до кінчика однієї гілки, або зазначеної опцією `--branch`, або віддаленою гілкою, на яку вказує `HEAD` первинної гілки. Подальші вибірки до результуючого репозиторію оновлюватимуть лише гілку віддаленого відстеження для тієї гілки, для якої ця опція використовувалася для початкового клонування. Якщо `HEAD` на віддаленій гілці не вказував на жодну гілку під час створення клону `--single-branch`, гілка віддаленого відстеження не створюється.

`--[no-]tags`::
	Контролюйте, чи будуть клоновані теги. Якщо задано параметр `--no-tags`, цей параметр стане постійним шляхом встановлення конфігурації `remote.<remote>.tagOpt=--no-tags`. Це гарантує, що майбутні операції `git pull` та `git fetch` не йтимуть за жодними тегами. Наступні явні вибірки тегів все одно працюватимуть (див. linkgit:git-fetch[1]).
+
За замовчуванням теги клонуються, і передача `--tags` зазвичай є забороненою, якщо тільки вона не скасовує попередню передачу `--no-tags`.
+
Може використовуватися разом з `--single-branch` для клонування та підтримки гілки без посилань, окрім однієї клонованої гілки. Це корисно, наприклад, для підтримки мінімальних клонів гілки за замовчуванням деякого репозиторію для індексації пошуку.

`--recurse-submodules[=<специфікація шляху>]`::
	Після створення клону, ініціалізуйте та клонуйте підмодулі всередині нього на основі наданої специфікації шляху (_<pathspec>_). Якщо не вказано параметр `=<pathspec>`, усі підмодулі ініціалізуються та клонуються. Цей параметр можна використовувати кілька разів для специфікацій шляху, що складаються з кількох записів. У результуючому клоні `submodule.active` встановлено на надану специфікацію шляху або "`.`" (тобто всі підмодулі), якщо специфікація шляху не вказана.
+
Підмодулі ініціалізуються та клонуються з використанням їхніх налаштувань за замовчуванням. Це еквівалентно запуску `git submodule update --init --recursive <pathspec>` одразу після завершення клонування. Цей параметр ігнорується, якщо клонований репозиторій не має робочого дерева/видачі (тобто, якщо вказано будь-який з параметрів `--no-checkout`/`-n`, `--bare` або `--mirror`)

`--[no-]shallow-submodules`::
	Усі клоновані підмодулі будуть поверхневими з глибиною 1.

`--[no-]remote-submodules`::
	Усі клоновані підмодулі використовуватимуть статус гілки віддаленого відстеження підмодуля для оновлення підмодуля, а не записаний SHA-1 суперпроекту. Еквівалентно передачі `--remote` до `git submodule update`.

`--separate-git-dir=<git-dir>`::
	Замість того, щоб розміщувати клонований репозиторій там, де він має бути, розмістіть його у вказаному каталозі, а потім створіть символічне посилання Git, незалежно від файлової системи. В результаті репозиторій Git можна відокремити від робочого дерева.

`--ref-format=<формат посилання>`::

Вкажіть заданий формат зберігання посилань для репозиторію. Допустимі значення:
+
include::ref-storage-format.adoc[]

`-j` _<n>_::
`--jobs` _<n>_::
	Кількість підмодулів, отриманих одночасно. За замовчуванням використовується опція `submodule.fetchJobs`.

_<репозиторій>_::
	(Можливо, віддалений) _<репозиторій>_, з якого потрібно клонувати. Див. розділ <<URLS, GIT URLs>> нижче для отримання додаткової інформації про визначення репозиторіїв.

_<католог>_::
	Назва нового каталогу для клонування. Частина "humanish" вихідного репозиторію використовується, якщо явно не вказано _<каталог>_ (`repo` для `/шлях/до/repo.git` та `foo` для `host.xz:foo/.git`). Клонування в існуючий каталог дозволено, лише якщо каталог порожній.

`--bundle-uri=<uri>`::
	Перед отриманням даних з віддаленого репозиторію, отримайте пакет з заданого _<uri>_ та розпакуйте дані в локальному репозиторії. Посилання в пакеті будуть зберігатися в прихованому просторі імен `refs/bundle/*`. Цей параметр несумісний з `--depth`, `--shallow-since` та `--shallow-exclude`.

:git-clone: 1
include::urls.adoc[]

ПРИКЛАДИ
--------

* Клон з основної черги:
+
------------
$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux
$ cd my-linux
$ make
------------


* Створіть локальний клон, який запозичує дані з поточного каталогу, не перевіряючи їх:
+
------------
$ git clone -l -s -n . ../copy
$ cd ../copy
$ git show-branch
------------


* Клонувати з основного каталогу, запозичуючи з існуючого локального каталогу:
+
------------
$ git clone --reference /git/linux.git \
	git://git.kernel.org/pub/scm/.../linux.git \
	my-linux
$ cd my-linux
------------


* Створіть голий репозиторій для публікації ваших змін для публіки:
+
------------
$ git clone --bare -l /home/proj/.git /pub/scm/proj.git
------------

* Клонуйте локальний репозиторій від іншого користувача:
+
------------
$ git clone --no-local /home/otheruser/proj.git /pub/scm/proj.git
------------

КОНФІГУРАЦІЯ
------------

include::includes/cmd-config-section-all.adoc[]

include::config/init.adoc[]

include::config/clone.adoc[]


GIT
---
Частина набору linkgit:git[1]
