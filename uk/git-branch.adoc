git-branch(1)
=============

НАЗВА
-----
git-branch - Список, створення або видалення гілок

СИНОПСИС
--------
[synopsis]
git branch [--color[=<when>] | --no-color] [--show-current]
	   [-v [--abbrev=<n> | --no-abbrev]]
	   [--column[=<options>] | --no-column] [--sort=<key>]
	   [--merged [<commit>]] [--no-merged [<commit>]]
	   [--contains [<commit>]] [--no-contains [<commit>]]
	   [--points-at <object>] [--format=<format>]
	   [(-r|--remotes) | (-a|--all)]
	   [--list] [<pattern>...]
git branch [--track[=(direct|inherit)] | --no-track] [-f]
	   [--recurse-submodules] <branch-name> [<start-point>]
git branch (--set-upstream-to=<upstream>|-u <upstream>) [<branch-name>]
git branch --unset-upstream [<branch-name>]
git branch (-m|-M) [<old-branch>] <new-branch>
git branch (-c|-C) [<old-branch>] <new-branch>
git branch (-d|-D) [-r] <branch-name>...
git branch --edit-description [<branch-name>]

ОПИС
----

Якщо вказано `--list`, або якщо немає аргументів, що не є опціями, буде перераховано існуючі гілки; поточна гілка буде виділена зеленим кольором та позначена зірочкою. Будь-які гілки, витягнуті у зв'язаних робочих деревах, будуть виділені блакитним кольором та позначені знаком плюс. Опція `-r` призведе до відображення списку гілок віддаленого відстеження, а опція `-a` покаже як локальні, так і віддалені гілки.

Якщо задано `<шаблон>`, він використовується як шаблон оболонки для обмеження виводу до відповідних гілок. Якщо задано кілька шаблонів, гілка відображається, якщо вона відповідає будь-якому з шаблонів.

Зверніть увагу, що під час надання `<шаблон>` необхідно використовувати `--list`; інакше команда може бути інтерпретована як створення гілки.

З параметром `--contains` відображаються лише гілки, що містять іменований коміт (іншими словами, гілки, кінчики комітів яких є нащадками іменованого коміту), `--no-contains` інвертує його. З параметром `--merged` будуть перелічені лише гілки, об'єднані з іменованим комітом (тобто гілки, кінчики комітів яких доступні з іменованого коміту). З параметром `--no-merged` будуть перелічені лише гілки, не об'єднані з іменованим комітом. Якщо аргумент _<commit>_ відсутній, він за замовчуванням має значення `HEAD` (тобто кінчик поточної гілки).

Друга форма команди створює новий заголовок гілки з назвою _<назва-гілки>_, який вказує на поточну `HEAD`, або _<початкову-точку>_, якщо задано. Як окремий випадок, для _<початкової-точки>_, ви можете використовувати `<rev-A>...<rev-B>` як скорочення для бази злиття _<rev-A>_ та _<rev-B>_, якщо існує лише одна база злиття. Ви можете пропустити щонайбільше один з _<rev-A>_ та _<rev-B>_, і в цьому випадку за замовчуванням використовується `HEAD`.

Зверніть увагу, що це створить нову гілку, але не переключить на неї робоче дерево; використовуйте `git switch <new-branch>` для перемикання на нову гілку.

Коли локальна гілка запускається з гілки віддаленого відстеження, Git налаштовує гілку (зокрема, записи конфігурації `branch.<name>.remote` та `branch.<name>.merge`) таким чином, щоб `git pull` належним чином зливався з гілкою віддаленого відстеження. Цю поведінку можна змінити за допомогою глобального прапорця конфігурації `branch.autoSetupMerge`. Цей параметр можна перевизначити за допомогою опцій `--track` та `--no-track`, а пізніше змінити за допомогою `git branch --set-upstream-to`.

З опцією `-m` або `-M`, _<old-branch>_ буде перейменовано на _<new-branch>_. Якщо _<old-branch>_ мала відповідний reflog, вона перейменовується відповідно до _<new-branch>_, і створюється запис reflog для запам'ятовування перейменування гілки. Якщо _<new-branch>_ існує, для примусового перейменування необхідно використовувати `-M`.

Опції `-c` та `-C` мають точно таку ж семантику, як `-m` та `-M`, за винятком того, що замість перейменування гілки вона буде скопійована під новою назвою разом з її конфігурацією та рефлогом.

З опцією `-d` або `-D`, _<назва-гілки>_ буде видалено. Ви можете вказати більше однієї гілки для видалення. Якщо гілка наразі має журнал перепису, то журнал перепису також буде видалено.

Використовуйте `-r` разом з `-d` для видалення гілок віддаленого відстеження. Зверніть увагу, що видаляти гілки віддаленого відстеження має сенс лише тоді, коли вони більше не існують у віддаленому репозиторії або якщо `git fetch` було налаштовано не отримувати їх знову. Дивіться також підкоманду `prune` команди linkgit:git-remote[1], щоб дізнатися, як очистити всі застарілі гілки віддаленого відстеження.


ОПЦІЇ
-----
`-d`::
`--delete`::
	Видалити гілку. Гілку необхідно повністю об'єднати з її гілкою upstream або з `HEAD`, якщо upstream не було встановлено за допомогою `--track` або `--set-upstream-to`.

`-D`::
	Скорочення для `--delete --force`.

`--create-reflog`::
	Створити журнал записів гілки. Це активує запис усіх змін, внесених до посилання гілки, що дозволяє використовувати sha1-вирази на основі дати, такі як `<назва-гілки>@{yesterday}`. Зверніть увагу, що в нечистих репозиторіях журнали записів зазвичай увімкнено за замовчуванням параметром конфігурації `core.logAllRefUpdates`. Заперечувана форма `--no-create-reflog` лише перевизначає попереднє `--create-reflog`, але наразі не скасовує налаштування `core.logAllRefUpdates`.

`-f`::
`--force`::
	Скинути _<назва-гілки>_ до _<початкова-точка>_, навіть якщо _<назва-гілки>_ вже існує. Без `-f`, `git branch` відмовляється змінювати існуючу гілку. У поєднанні з `-d` (або `--delete`) дозволяє видалення гілки незалежно від її статусу об'єднання, або від того, чи вказує вона на дійсний коміт. У поєднанні з `-m` (або `--move`) дозволяє перейменування гілки, навіть якщо нова назва гілки вже існує, те саме стосується `-c` (або `--copy`).
+
Зверніть увагу, що `git branch -f <назва-гілки> [<початкова-точка>]`, навіть з `-f`, відмовляється змінювати існуючу гілку _<назва-гілки>_, яка витягнута з іншого робочого дерева, пов'язаного з тим самим репозиторієм.

`-m`::
`--move`::
	Перемістити/перейменувати гілку разом з її конфігурацією та перефлогом.

`-M`::
	Скорочення для `--move --force`.

`-c`::
`--copy`::
	Скопіюйте гілку разом з її конфігурацією та рефлогом.

`-C`::
	Скорочення для `--copy --force`.

`--color[=<when>]`::
	Виділіть поточні, локальні та віддалено відстежувані гілки кольором. Значення має бути `always` (за замовчуванням), `never` або `auto`.

`--no-color`::
	Вимкнути кольори гілок, навіть якщо у файлі конфігурації задано кольоровий вивід за замовчуванням. Те саме, що й `--color=never`.

`-i`::
`--ignore-case`::
	Сортування та фільтрація гілок не враховують регістр.

`--omit-empty`::
	Не друкуйте новий рядок після відформатованих посилань, де формат розгортається до порожнього рядка.

`--column[=<опція>]`::
`--no-column`::
	Відображати список гілок у стовпцях. Синтаксис опцій дивіться у змінній конфігурації `column.branch`. `--column` та `--no-column` без опцій еквівалентні `always` та `never` відповідно.
+
Цей параметр застосовується лише в недетальному режимі.

`--sort=<ключ>`::
	Сортування на основі _<ключ>_. Додайте префікс `-` для сортування у порядку спадання значення. Ви можете використовувати опцію `--sort=<ключ>` кілька разів, і в цьому випадку останній ключ стає первинним ключем. Підтримувані ключі такі ж, як у linkgit:git-for-each-ref[1]. Порядок сортування за замовчуванням встановлюється на значення, налаштоване для змінної `branch.sort`, якщо вона існує, або на основі повного імені посилання (включаючи префікс `refs/...`). Спочатку відображаються відокремлені `HEAD` (якщо є), потім локальні гілки і, нарешті, гілки з віддаленим відстеженням. Див. linkgit:git-config[1].

`-r`::
`--remotes`::
	Перерахувати або видалити (якщо використовується з `-d`) гілки віддаленого відстеження. Поєднайте з `--list` для відповідності необов'язковим шаблонам.

`-a`::
`--all`::
	Перелічіть як гілки віддаленого відстеження, так і локальні гілки. Поєднуйте з `--list` для відповідності необов'язковим шаблонам.

`-l`::
`--list`::
	Список гілок. З необов'язковим параметром `<шаблон>...`, наприклад, `git branch --list 'maint-*'`, список лише тих гілок, що відповідають шаблону(ам).

`--show-current`::
	Вивести назву поточної гілки. У відокремленому стані `HEAD` нічого не виводиться.

`-v`::
`-vv`::
`--verbose`::
	У режимі списку, виведіть sha1 та рядок теми коміта для кожного head, разом із зв'язком з гілкою вище за тегом (якщо така є). Якщо вказано двічі, виведіть шлях до пов'язаного робочого дерева (якщо таке є) та назву гілки вище за тегом (див. також `git remote show <remote>`). Зверніть увагу, що шлях до `HEAD` поточного робочого дерева не буде виведено (це завжди буде ваш поточний каталог).

`-q`::
`--quiet`::
	Бути тихішим під час створення або видалення гілки, пригнічуючи повідомлення, що не пов'язані з помилками.

`--abbrev=<n>`::
	У детальному списку, що показує назву об'єкта коміту, покажіть найкоротший префікс довжиною щонайменше _<n>_ шістнадцяткових цифр, який унікально посилається на об'єкт. Значення за замовчуванням — 7, його можна змінити за допомогою опції конфігурації `core.abbrev`.

`--no-abbrev`::
	Відображати повні sha1 у вихідному списку, а не скорочувати їх.

`-t`::
`--track[=(direct|inherit)]`::
	Під час створення нової гілки налаштуйте записи конфігурації `branch.<name>.remote` та `branch.<name>.merge`, щоб встановити конфігурацію відстеження "upstream" для нової гілки. Ця конфігурація вкаже git відображати зв'язок між двома гілками в `git status` та `git branch -v`. Крім того, вона направляє `git pull` без аргументів на витягування з upstream, коли нова гілка буде виведена.
+
Точна гілка початкової точки вибирається залежно від необов'язкового аргументу: `-t`, `--track` або `--track=direct` означає використовувати саму гілку початкової точки як гілку початкової точки; `--track=inherit` означає копіювати конфігурацію гілки початкової точки початкової точки.
+
Змінна конфігурації `branch.autoSetupMerge` визначає, як повинні поводитися `git switch`, `git checkout` та `git branch`, коли не вказано ні `--track`, ні `--no-track`:
+
Параметр за замовчуванням, `true`, поводиться так, ніби `--track=direct` було задано щоразу, коли початкова точка є гілкою віддаленого відстеження. `false` поводиться так, ніби `--no-track`. `always` поводиться так, ніби `--track=direct`. `inherit` поводиться так, ніби `--track=inherit`. `simple` поводиться так, ніби `--track=direct` було задано лише тоді, коли _<початкова точка>_ є гілкою віддаленого відстеження, а нова гілка має таку ж назву, як і віддалена гілка.
+
Дивіться linkgit:git-pull[1] та linkgit:git-config[1] для додаткового обговорення використання опцій `branch.<name>.remote` та `branch.<name>.merge`.

`--no-track`::
	Не налаштовуйте конфігурацію "upstream", навіть якщо встановлено змінну конфігурації `branch.autoSetupMerge`.

`--recurse-submodules`::
	ЦЕЙ ОПЦІЯ ЕКСПЕРИМЕНТАЛЬНА! Змушує поточну команду рекурсивно перетворюватися на підмодулі, якщо увімкнено `submodule.propagateBranches`. Див. `submodule.propagateBranches` у linkgit:git-config[1]. Наразі підтримується лише створення гілок.
+
При використанні у створенні гілки, нова гілка _<назва-гілки>_ буде створена в суперпроекті та всіх підмодулях у _<початковій-точці>_ суперпроекту. У підмодулях гілка вказуватиме на коміт підмодуля в _<початковій-точці>_ суперпроекту, але інформація про відстеження гілки буде налаштована на основі гілок та віддалених гілок підмодуля, наприклад, `git branch --recurse-submodules topic origin/main` створить гілку підмодуля "topic", яка вказує на коміт підмодуля в "origin/main" суперпроекту, але відстежує "origin/main" підмодуля.

`--set-upstream`::
	Оскільки цей параметр мав заплутаний синтаксис, він більше не підтримується. Будь ласка, використовуйте замість нього `--track` або `--set-upstream-to`.

`-u <вище за течією>`::
`--set-upstream-to=<вище за течією>`::
	Налаштуйте інформацію відстеження _<назва-гілки>_ таким чином, щоб _<вищепотокова>_ вважалася гілкою вищого рівня _<назва-гілки>_. Якщо _<назва-гілки>_ не вказано, то за замовчуванням використовується поточна гілка.

`--unset-upstream`::
	Видалити інформацію про початковий рівень для _<назва-гілки>_. Якщо гілка не вказана, за замовчуванням використовується поточна гілка.

`--edit-description`::
	Відкрийте редактор і відредагуйте текст, щоб пояснити, для чого призначена гілка, щоб її використовували різні інші команди (наприклад, `format-patch`, `request-pull` та `merge` (якщо увімкнено)). Можна використовувати багаторядкові пояснення.

`--contains [<коміт>]`::
	Перераховувати лише гілки, що містять _<commit>_ (`HEAD`, якщо не вказано). Має на увазі `--list`.

`--no-contains [<коміт>]`::
	Перелічувати лише гілки, що не містять _<commit>_ (`HEAD`, якщо не вказано). Має на увазі `--list`.

`--merged [<коміт>]`::
	Перелічувати лише гілки, підказки яких доступні з _<commit>_ (`HEAD`, якщо не вказано). Має на увазі `--list`.

`--no-merged [<коміт>]`::
	Перелічувати лише гілки, поради яких недоступні з _<commit>_ (`HEAD`, якщо не вказано). Має на увазі `--list`.

`--points-at <об'єкт>`::
	Перелічувати лише гілки _<об'єкта>_.

`--format <формат>`::
	Рядок, який інтерполює `%(ім'я поля)` з посилання на гілку, що відображається, та об'єкта, на який воно вказує. _<формат>_ такий самий, як і у linkgit:git-for-each-ref[1].

_<назва-гілки>_::
	Назва гілки для створення або видалення. Нова назва гілки має пройти всі перевірки, визначені в linkgit:git-check-ref-format[1]. Деякі з цих перевірок можуть обмежувати кількість символів, дозволених у назві гілки.

_<start-point>_::
	Новий заголовок гілки вказуватиме на цей коміт. Його можна вказати як назву гілки, ідентифікатор коміту або тег. Якщо цей параметр пропущено, замість нього буде використано поточний `HEAD`.

_<стара гілка>_::
	Назва існуючої гілки. Якщо цей параметр пропущено, замість нього буде використано назву поточної гілки.

_<нова гілка>_::
	Нова назва існуючої гілки. Застосовуються ті ж обмеження, що й для _<назва-гілки>_.

КОНФІГУРАЦІЯ
------------
`pager.branch` враховується лише під час перерахування гілок, тобто коли використовується або мається на увазі `--list`. За замовчуванням використовується пейджер. Див. linkgit:git-config[1].

include::includes/cmd-config-section-rest.adoc[]

include::config/branch.adoc[]

ПРИКЛАДИ
--------

Почати розробку з відомого тегу::
+
------------
$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6
$ cd my2.6
$ git branch my2.6.14 v2.6.14   <1>
$ git switch my2.6.14
------------
+
<1> Цей крок та наступний можна об'єднати в один за допомогою "checkout -b my2.6.14 v2.6.14".

Видалити непотрібну гілку::
+
------------
$ git clone git://git.kernel.org/.../git.git my.git
$ cd my.git
$ git branch -d -r origin/todo origin/html origin/man   <1>
$ git branch -D test                                    <2>
------------
+
<1> Видаліть гілки віддаленого відстеження "todo", "html" та "man". Наступні команди `git fetch` або `git pull` знову їх створить, якщо ви не налаштуєте їх інакше. Див. linkgit:git-fetch[1].
<2> Видалити гілку "test", навіть якщо гілка "master" (або будь-яка гілка, що наразі вивантажена) не містить усіх комітів з гілки test.

Перелік гілок з певного віддаленого сервера::
+
------------
$ git branch -r -l '<remote>/<pattern>'                 <1>
$ git for-each-ref 'refs/remotes/<remote>/<pattern>'    <2>
------------
+
<1> Використання `-a` призведе до об'єднання _<remote>_ з будь-якими локальними гілками, до яких випадково додано префікс з тим самим шаблоном _<remote>_.
<2> `for-each-ref` може приймати широкий спектр опцій. Див. linkgit:git-for-each-ref[1]

Зазвичай шаблони потребують цитування.

НОТАТКИ
-------

Якщо ви створюєте гілку, на яку хочете негайно перейти, простіше використовувати команду `git switch` з її опцією `-c`, щоб зробити те саме за допомогою однієї команди.

Опції `--contains`, `--no-contains`, `--merged` та `--no-merged` виконують чотири пов'язані, але різні функції:

- `--contains <commit>` використовується для пошуку всіх гілок, яким потрібно буде приділити особливу увагу, якщо _<commit>_ буде перебазовано або змінено, оскільки ці гілки містять вказаний _<commit>_.

- `--no-contains <commit>` є інверсією цього, тобто гілки, які не містять зазначеного _<commit>_.

- `--merged` використовується для пошуку всіх гілок, які можна безпечно видалити, оскільки ці гілки повністю містяться в `HEAD`.

- `--no-merged` використовується для пошуку гілок, які є кандидатами для об'єднання з `HEAD`, оскільки ці гілки не повністю містяться в `HEAD`.

include::ref-reachability-filters.adoc[]

ДИВ. ТАКОЖ
----------
linkgit:git-check-ref-format[1], linkgit:git-fetch[1], linkgit:git-remote[1], link:user-manual.html#what-is-a-branch["Розуміння історії: Що таке гілка?"] у Посібнику користувача Git.

GIT
---
Частина набору linkgit:git[1]
