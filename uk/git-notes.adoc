git-notes(1)
============

НАЗВА
-----
git-notes - Додавання або перевірка нотаток до об'єктів

СИНОПСИС
--------
[synopsis]
git notes [list [<object>]]
git notes add [-f] [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [-e] [<object>]
git notes copy [-f] ( --stdin | <from-object> [<to-object>] )
git notes append [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [-e] [<object>]
git notes edit [--allow-empty] [<object>] [--[no-]stripspace]
git notes show [<object>]
git notes merge [-v | -q] [-s <strategy> ] <notes-ref>
git notes merge --commit [-v | -q]
git notes merge --abort [-v | -q]
git notes remove [--ignore-missing] [--stdin] [<object>...]
git notes prune [-n] [-v]
git notes get-ref


ОПИС
----
Додає, видаляє або читає нотатки, прикріплені до об'єктів, не торкаючись самих об'єктів.

За замовчуванням нотатки зберігаються та зчитуються з `refs/notes/commits`, але це значення за замовчуванням можна змінити. Дивіться розділи ПАРАМЕТРІ, КОНФІГУРАЦІЯ та СЕРЕДОВИЩЕ нижче. Якщо це посилання не існує, воно буде непомітно створено, коли вперше знадобиться для зберігання нотатки.

Типове використання нотаток — доповнити повідомлення коміту без зміни самого коміту. Нотатки можна відобразити за допомогою `git log` разом з оригінальним повідомленням коміту. Щоб відрізнити ці нотатки від повідомлення, що зберігається в об'єкті коміту, нотатки мають відступ, як і повідомлення, після рядка без відступу "Notes (_<refname>_):" (або "Notes:" для `refs/notes/commits`).

Нотатки також можна додавати до патчів, підготовлених за допомогою `git format-patch`, використовуючи опцію `--notes`. Такі нотатки додаються як коментар до патча після роздільника у три тире.

Щоб змінити, які нотатки відображаються `git log`, дивіться обговорення `notes.displayRef` у <<CONFIGURATION,КОНФІГУРАЦІЯ>>.

Дивіться конфігурацію `notes.rewrite.<command>` для способу перенесення нотаток між командами, які перезаписують коміти.


ПІДКОМАНДИ
----------

`list`::
	Вивести список об'єктів нотаток для заданого об'єкта. Якщо об'єкт не вказано, показати список усіх об'єктів нотаток та об'єктів, які вони анотують (у форматі "`<об'єкт-нотатки> <анотований-об'єкт>`"). Це підкоманда за замовчуванням, якщо підкоманда не вказано.

`add`::
	Додати нотатки для заданого об'єкта (за замовчуванням `HEAD`). Перервати, якщо об'єкт вже має нотатки (використати `-f` для перезапису існуючих нотаток). Однак, якщо ви використовуєте `add` інтерактивно (використовуючи редактор для надання вмісту нотаток), то замість переривання існуючі нотатки будуть відкриті в редакторі (як підкоманда `edit`). Якщо ви вкажете кілька `-m` та `-F`, між повідомленнями буде вставлено порожній рядок. Використовуйте опцію `--separator` для вставки інших роздільників. Ви можете використовувати `-e` для інтерактивного редагування та точного налаштування повідомлення(й), наданих з опцій `-m` та `-F`, перед додаванням нотатки.

`copy`::
	Скопіюйте нотатки для першого об'єкта на другий об'єкт (за замовчуванням `HEAD`). Перервіть, якщо другий об'єкт вже має нотатки, або якщо перший об'єкт їх не має (використовуйте `-f`, щоб перезаписати існуючі нотатки на другий об'єкт). Ця підкоманда еквівалентна: `git notes add [-f] -C $(git notes list <з-об'єкта>) <до-об'єкта>`
+
У режимі `--stdin` приймати рядки у форматі
+
----------
<from-object> SP <to-object> [ SP <rest> ] LF
----------
+
на стандартному вводі та копіювати нотатки з кожного _<from-object>_ до відповідного _<to-object>_. (Необов'язковий _<rest>_ ігнорується, щоб команда могла прочитати вхідні дані, передані гачку `post-rewrite`.)
+
`--stdin` не можна поєднувати з іменами об'єктів, заданими в командному рядку.

`append`::
	Додати нове(і) повідомлення(а), задане(і) опціями `-m` або `-F`, до існуючої нотатки, або додати їх як нову нотатку, якщо такої не існує, для об'єкта (за замовчуванням `HEAD`). Під час додавання до існуючої нотатки перед кожним новим повідомленням додається порожній рядок як роздільник між абзацами. Роздільник можна налаштувати за допомогою опції `--separator`. Редагуйте нотатки, які потрібно додавати, задані опціями `-m` та `-F`, за допомогою `-e` інтерактивно (за допомогою редактора) перед додаванням нотатки.

`edit`::
	Редагувати нотатки для заданого об'єкта (за замовчуванням `HEAD`).

`show`::
	Показати нотатки для заданого об'єкта (за замовчуванням `HEAD`).

`merge`::
	Об'єднати задане посилання на нотатки з поточним посиланням на нотатки. Це спробує об'єднати зміни, внесені заданим посиланням на нотатки (так званим "віддаленим") з моменту злиття (якщо такі є), з поточним посиланням на нотатки (так званим "локальним").
+
Якщо виникають конфлікти, а стратегія автоматичного вирішення конфліктуючих нотаток (див. розділ "СТРАТЕГІЇ ЗЛИТТЯ НОТАТОК") не вказана, використовується `manual` resolver. Цей resolver перевіряє конфліктуючі нотатки у спеціальному робочому дереві (`.git/NOTES_MERGE_WORKTREE`) та доручає користувачеві вручну вирішити конфлікти там. Після завершення користувач може або завершити злиття за допомогою `git notes merge --commit`, або перервати злиття за допомогою `git notes merge --abort`.

`remove`::
	Видалити нотатки для заданих об'єктів (за замовчуванням `HEAD`). Якщо в командному рядку вказано нуль або один об'єкт, це еквівалентно вказівці порожнього повідомлення нотатки для підкоманди `edit`.
+
У режимі `--stdin` також видаляти імена об'єктів, що надаються у стандартному вводі. Іншими словами, `--stdin` можна поєднувати з іменами об'єктів з командного рядка.

`prune`::
	Видалити всі нотатки для неіснуючих/недоступних об'єктів.

`get-ref`::
	Вивести поточне посилання на нотатки. Це забезпечує простий спосіб отримання поточного посилання на нотатки (наприклад, зі скриптів).

ОПЦІЇ
-----
`-f`::
`--force`::
	Під час додавання нотаток до об'єкта, який уже має нотатки, перезапишіть існуючі нотатки (замість переривання).

`-m <msg>`::
`--message=<повідомлення>`::
	Використовувати надане повідомлення примітки (замість запиту). Якщо задано кілька опцій `-m`, їхні значення об'єднуються в окремі абзаци.

`-F <файл>`::
`--file=<файл>`::
	Візьміть повідомлення примітки з заданого файлу. Використайте `-`, щоб прочитати повідомлення примітки зі стандартного вводу.

`-C <об'єкт>`::
`--reuse-message=<об'єкт>`::
	Візьміть заданий blob-об'єкт (наприклад, іншу нотатку) як повідомлення нотатки. (Використовуйте `git notes copy <object>` для копіювання нотаток між об'єктами.) Має на увазі `--no-stripspace`, оскільки поведінка за замовчуванням полягає в дослівному копіюванні повідомлення.

`-c <об'єкт>`::
`--reedit-message=<object>`::
	Подібно до `-C`, але з `-c` викликається редактор, щоб користувач міг додатково редагувати повідомлення нотатки.

`--allow-empty`::
	Дозволити збереження порожнього об'єкта нотатки. Поведінка за замовчуванням — автоматичне видалення порожніх нотаток.

`--separator=<paragraph-break>`::
`--separator`::
`--no-separator`::
	Вкажіть рядок, який використовуватиметься як власний роздільник між абзацами (за потреби в кінці додається символ нового рядка). Якщо `--no-separator`, роздільники між абзацами не додаватимуться. За замовчуванням використовується порожній рядок.

`--stripspace`::
`--no-stripspace`::
	Очистити пробіли. Зокрема (див. linkgit:git-stripspace[1]):
+
--
- видалити пробіли в кінці всіх рядків
- згорнути кілька послідовних порожніх рядків в один порожній рядок
- видалити порожні рядки з початку та кінця вхідних даних
- за потреби додайте відсутній символ `\n` до останнього рядка.
--
+
`--stripspace` використовується за замовчуванням, за винятком `-C`/`--reuse-message`. Однак майте на увазі, що це залежить від порядку подібних опцій. Наприклад, для `-C <об'єкт> -m<повідомлення>` буде використано `--stripspace`, оскільки значення за замовчуванням для `-m` замінює попереднє `-C`. Це відоме обмеження, яке може бути виправлено в майбутньому.

`--ref=<ref>`::
	Керування деревом нотаток у _<ref>_. Це замінює `GIT_NOTES_REF` та конфігурацію `core.notesRef`. Посилання вказує повну назву посилання, якщо воно починається з `refs/notes/`; якщо воно починається з `notes/`, то `refs/`, а в іншому випадку, для формування повної назви посилання додається префікс `refs/notes/`.

`--ignore-missing`::
	Не вважайте помилкою запит на видалення нотаток з об'єкта, до якого не додано нотаток.

`--stdin`::
	Дійсно лише для `remove` та `copy`. Див. відповідні підкоманди.

`-n`::
`--dry-run`::
	Не видаляйте нічого; просто повідомте назви об'єктів, нотатки яких потрібно видалити.

`-s <стратегія>`::
`--strategy=<стратегія>`::
	Під час об’єднання нотаток вирішуйте конфлікти нотаток, використовуючи задану стратегію. Розпізнаються такі стратегії: `manual` (за замовчуванням), `ours`, `theirs`, `union` та `cat_sort_uniq`. Цей параметр замінює налаштування конфігурації `notes.mergeStrategy`. Див. розділ «СТРАТЕГІЇ ОБ’ЄДНАННЯ НОТАТОК» нижче для отримання додаткової інформації про кожну стратегію об’єднання нотаток.

`--commit`::
	Завершити поточне злиття `git notes merge`. Використовуйте цю опцію, коли ви вирішили конфлікти, які `git notes merge` зберігаються в `.git/NOTES_MERGE_WORKTREE`. Це виправляє коміт часткового злиття, створений `git notes merge` (зберігається в `.git/NOTES_MERGE_PARTIAL`), додаючи нотатки в `.git/NOTES_MERGE_WORKTREE`. Посилання на нотатки, що зберігається в symref `.git/NOTES_MERGE_REF`, оновлюється до результуючого коміту.

`--abort`::
	Перервати/скинути поточне `git notes merge`, тобто злиття нотаток з конфліктами. Це просто видаляє всі файли, пов'язані зі злиттям нотаток.

`-q`::
`--quiet`::
	Під час об'єднання нотаток працюйте тихо.

`-v`::
`--verbose`::
	Під час об’єднання нотаток будьте докладнішими. Під час видалення нотаток повідомляйте про всі назви об’єктів, нотатки яких видалено.


ОБГОВОРЕННЯ
-----------

Нотатки коміту – це блоби, що містять додаткову інформацію про об'єкт (зазвичай інформацію, що доповнює повідомлення коміту). Ці блоби беруться з посилань на нотатки. Посилання на нотатки зазвичай є гілкою, яка містить «файли», шляхи до яких є іменами об'єктів, які вони описують, з деякими роздільниками каталогів, включеними з міркувань продуктивності (примітка: [Дозволені шляхи мають вигляд 'bf'`/`'fe'`/`'30'`/`'...'`/`'680d5a...': послідовність імен каталогів з двох шістнадцяткових цифр кожна, за якими йде ім'я файлу з рештою ідентифікатора об'єкта.].

Кожна зміна нотаток створює новий коміт за вказаним посиланням на нотатки. Таким чином, ви можете перевірити історію нотаток, викликавши, наприклад, `git log -p notes/commits`. Наразі повідомлення про коміт записує лише те, яка операція викликала оновлення, а авторство коміта визначається відповідно до звичайних правил (див. linkgit:git-commit[1]). Ці деталі можуть змінитися в майбутньому.

Також дозволено, щоб посилання на нотатки вказувало безпосередньо на об'єкт дерева, і в цьому випадку історію нотаток можна прочитати за допомогою `git log -p -g <refname>`.


СТРАТЕГІЇ ОБ'ЄДНАННЯ НОТАТОК
----------------------------

Стратегія об'єднання нотаток за замовчуванням — `manual`, яка перевіряє конфліктуючі нотатки у спеціальному робочому дереві для вирішення конфліктів нотаток (`.git/NOTES_MERGE_WORKTREE`) та дає користувачеві інструкції щодо вирішення конфліктів у цьому робочому дереві. Після завершення користувач може або завершити об'єднання за допомогою `git notes merge --commit`, або перервати його за допомогою `git notes merge --abort`.

Користувачі можуть вибрати стратегію автоматичного об'єднання з наступних, використовуючи опцію `-s`/`--strategy` або налаштувавши `notes.mergeStrategy` відповідно:

`ours` автоматично вирішує конфліктні нотатки на користь локальної версії (тобто поточного посилання на нотатки).

`theirs` автоматично вирішує конфлікти нотаток на користь віддаленої версії (тобто задане посилання на нотатки об'єднується з поточним посиланням на нотатки).

`union` автоматично вирішує конфлікти нотаток шляхом об'єднання локальної та віддаленої версій.

`cat_sort_uniq` схожа на `union`, але окрім об'єднання локальної та віддаленої версій, ця стратегія також сортує результуючі рядки та видаляє дублікати рядків з результату. Це еквівалентно застосуванню конвеєра оболонки "cat | sort | uniq" до локальної та віддаленої версій. Ця стратегія корисна, якщо нотатки дотримуються формату на основі рядків, де потрібно уникнути дублікатів рядків у результаті злиття. Зверніть увагу, що якщо локальна або віддалена версія містять дублікати рядків до злиття, вони також будуть видалені цією стратегією злиття нотаток.


ПРИКЛАДИ
--------

Ви можете використовувати нотатки, щоб додавати анотації з інформацією, яка не була доступна на момент написання коміту.

------------
$ git notes add -m 'Tested-by: Johannes Sixt <j6t@kdbg.org>' 72a144e2
$ git show -s 72a144e
[...]
    Підписав: Хуніо К. Хамано <gitster@pobox.com>

Примітки:
    Перевірено: Johannes Sixt <j6t@kdbg.org>
------------

В принципі, нотатка — це звичайний Git-блоб, і приймається будь-який (не)формат. Ви можете безпечно створювати нотатки з довільних файлів у бінарному коді за допомогою `git hash-object`:

------------
$ cc *.c
$ blob=$(git hash-object -w a.out)
$ git notes --ref=built add --allow-empty -C "$blob" HEAD
------------

(Ви не можете просто використовувати `git notes --ref=built add -F a.out HEAD`, оскільки це небезпечно для двійкового коду.) Звичайно, немає сенсу відображати нотатки у нетекстовому форматі за допомогою `git log`, тому, якщо ви використовуєте такі нотатки, вам, ймовірно, доведеться написати спеціальні інструменти, щоб зробити з ними щось корисне.


[[CONFIGURATION]]
КОНФІГУРАЦІЯ
------------

`core.notesRef`::
	Посилання на нотатки для читання та маніпулювання замість `refs/notes/commits`. Має бути нескорочене ім'я посилання. Цей параметр можна змінити через середовище та командний рядок.

include::includes/cmd-config-section-rest.adoc[]

include::config/notes.adoc[]


НАВКОЛИШНЄ СЕРЕДОВИЩЕ
---------------------

`GIT_NOTES_REF`::
	З якого посилання маніпулювати нотатками, замість `refs/notes/commits`. Це замінює налаштування `core.notesRef`.

`GIT_NOTES_DISPLAY_REF`::
	Список посилань або глобальних елементів, розділених двокрапками, що вказує, з яких посилань, окрім значення за замовчуванням `core.notesRef` або `GIT_NOTES_REF`, зчитувати нотатки під час відображення повідомлень комітів. Це замінює налаштування `notes.displayRef`.
+
Для неіснуючих посилань буде видано попередження, але глобальний об'єкт, який не відповідає жодному посиланню, буде ігноровано.

`GIT_NOTES_REWRITE_MODE`::
	Що робити, якщо цільовий коміт вже має нотатку під час копіювання нотаток під час перезапису? Має бути одне з налаштувань `overwrite`, `concatenate`, `cat_sort_uniq` або `ignore`. Це замінює налаштування `core.rewriteMode`.

`GIT_NOTES_REWRITE_REF`::
	Під час переписування комітів, які нотатки копіювати з оригіналу до переписаного коміту. Має бути список посилань або глобів, розділених двокрапками.
+
Якщо не встановлено в середовищі, список нотаток для копіювання залежить від налаштувань `notes.rewrite.<команда>` та `notes.rewriteRef`.

GIT
---
Частина набору linkgit:git[1]
