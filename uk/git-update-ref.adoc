git-update-ref(1)
=================

НАЗВА
-----
git-update-ref - Безпечно оновити ім'я об'єкта, що зберігається в посиланні

СИНОПСИС
--------
[synopsis]
git update-ref [-m <reason>] [--no-deref] -d <ref> [<old-oid>]
git update-ref [-m <reason>] [--no-deref] [--create-reflog] <ref> <new-oid> [<old-oid>]
git update-ref [-m <reason>] [--no-deref] --stdin [-z] [--batch-updates]

ОПИС
----
За наявності двох аргументів зберігає <new-oid> у <ref>, можливо, розіменуючи символічні посилання. Наприклад, `git update-ref HEAD <new-oid>` оновлює поточний заголовок гілки до нового об'єкта.

За наявності трьох аргументів зберігає <new-oid> у <ref>, можливо, розіменовуючи символічні посилання, після перевірки, що поточне значення <ref> відповідає <old-oid>. Наприклад, `git update-ref refs/heads/master <new-oid> <old-oid>` оновлює заголовок гілки master до <new-oid>, лише якщо його поточне значення дорівнює <old-oid>. Ви можете вказати 40 "0" або порожній рядок як <old-oid>, щоб переконатися, що посилання, яке ви створюєте, не існує.

Останніми аргументами є імена об'єктів; ця команда без будь-яких опцій не підтримує оновлення символічного посилання, щоб воно вказувало на інше посилання (див. linkgit:git-symbolic-ref[1]). Але `git update-ref --stdin` має команди `symref-*`, щоб звичайні та символічні посилання могли бути зафіксовані в одній транзакції.

Якщо задано --no-deref, перезаписується сам <ref>, а не результат виконання символічних вказівників.

З опцією `-d` видаляється іменований <ref> після перевірки, що він все ще містить <old-oid>.

З `--stdin`, update-ref зчитує інструкції зі стандартного вводу та виконує всі зміни разом. Вкажіть команди виду:

	update SP <ref> SP <new-oid> [SP <old-oid>] LF
	create SP <ref> SP <new-oid> LF
	delete SP <ref> [SP <old-oid>] LF
	verify SP <ref> [SP <old-oid>] LF
	symref-update SP <ref> SP <new-target> [SP (ref SP <old-target> | oid SP <old-oid>)] LF
	symref-create SP <ref> SP <new-target> LF
	symref-delete SP <ref> [SP <old-target>] LF
	symref-verify SP <ref> [SP <old-target>] LF
	option SP <opt> LF
	start LF
	prepare LF
	commit LF
	abort LF

З опцією `--create-reflog`, update-ref створить reflog для кожного посилання, навіть якщо зазвичай він не створюється.

З параметром `--batch-updates`, update-ref виконує оновлення пакетом, але дозволяє окремим оновленням завершуватися невдало через недійсні або неправильні дані користувача, застосовуючи лише успішні оновлення. Однак системні помилки, такі як збої вводу/виводу або проблеми з пам'яттю, призведуть до повного збою всіх пакетних оновлень. Будь-які невдалі оновлення будуть повідомлені в такому форматі:

	rejected SP (<old-oid> | <old-target>) SP (<new-oid> | <new-target>) SP <rejection-reason> LF

Поля, що містять пробіли, беріть у лапки так, ніби це рядки у вихідному коді C, тобто оточені подвійними лапками та екранованими зворотною скісну рискою. Використовуйте 40 символів "0" або порожній рядок, щоб вказати нульове значення. Щоб вказати відсутнє значення, повністю пропустіть значення та попередній йому пробіл.

Або ж використовуйте `-z` для вказівки у форматі, що завершується NUL, без лапок:

	update SP <ref> NUL <new-oid> NUL [<old-oid>] NUL
	create SP <ref> NUL <new-oid> NUL
	delete SP <ref> NUL [<old-oid>] NUL
	verify SP <ref> NUL [<old-oid>] NUL
	symref-update SP <ref> NUL <new-target> [NUL (ref NUL <old-target> | oid NUL <old-oid>)] NUL
	symref-create SP <ref> NUL <new-target> NUL
	symref-delete SP <ref> [NUL <old-target>] NUL
	symref-verify SP <ref> [NUL <old-target>] NUL
	option SP <opt> NUL
	start NUL
	prepare NUL
	commit NUL
	abort NUL

У цьому форматі використовуйте 40 "0" для позначення нульового значення та порожній рядок для позначення відсутнього значення.

В будь-якому форматі значення можна вказувати в будь-якій формі, яку Git розпізнає як ім'я об'єкта. Команди в будь-якому іншому форматі або повторюваний <ref> призводять до помилки. Значення команд:

update::
	Встановіть <ref> на <new-oid> після перевірки <old-oid>, якщо він заданий. Вкажіть нульовий <new-oid>, щоб переконатися, що посилання не існує після оновлення, та/або нульовий <old-oid>, щоб переконатися, що посилання не існує до оновлення.

create::
	Створити <ref> з <new-oid> після перевірки його неіснування. Вказаний <new-oid> може не дорівнювати нулю.

delete::
	Видалити <ref> після перевірки його існування з <old-oid>, якщо його вказано. Якщо його вказано, <old-oid> може не дорівнювати нулю.

symref-update::
	Встановіть <ref> на <new-target> після перевірки <old-target> або <old-oid>, якщо вказано. Вкажіть нульовий <old-oid>, щоб переконатися, що посилання не існує до оновлення.

verify::
	Перевірте <ref> відносно <old-oid>, але не змінюйте його. Якщо <old-oid> дорівнює нулю або відсутній, посилання не повинно існувати.

symref-create:
	Створити символічне посилання <ref> з <new-target> після
	перевірки того, що воно не існує.

symref-delete::
	Видалити <ref> після перевірки його існування з <old-target>, якщо його вказано.

symref-verify::
	Перевірте символічний <ref> відносно <old-target>, але не змінюйте його. Якщо <old-target> відсутній, посилання не повинно існувати. Можна використовувати лише в режимі `no-deref`.

option::
	Змініть поведінку наступної команди, яка іменує <ref>. Єдиний допустимий параметр — `no-deref`, щоб уникнути розіменування символічного посилання.

старт::
	Розпочати транзакцію. На відміну від нетранзакційного сеансу, транзакція автоматично перерветься, якщо сеанс завершиться без явного підтвердження (commit). Ця команда може створити нову порожню транзакцію, якщо поточну вже зафіксовано або перервано.

підготувати::
	Підготуйтеся до фіксації транзакції. Це створить файли блокування для всіх оновлень посилань у черзі. Якщо одне посилання не вдалося заблокувати, транзакцію буде перервано.

коміт::
	Зафіксувати всі оновлення посилань, що знаходяться в черзі для транзакції, завершуючи транзакцію.

перервати::
	Перервати транзакцію, знявши всі блокування, якщо транзакція перебуває у стані підготовки.

Якщо всі <ref> можна одночасно заблокувати відповідними <old-oid>, усі зміни виконуються. В іншому випадку жодні зміни не виконуються. Зверніть увагу, що хоча кожен окремий <ref> оновлюється або видаляється атомарно, одночасний читач все ще може бачити підмножину змін.

ОНОВЛЕННЯ РЕЄСТРАЦІЇ
--------------------
Якщо параметр конфігурації "core.logAllRefUpdates" має значення true, а посилання знаходиться в "refs/heads/", "refs/remotes/", "refs/notes/" або псевдопосиланні, такому як HEAD чи ORIG_HEAD; або файл "$GIT_DIR/logs/<ref>" існує, тоді `git update-ref` додасть рядок до файлу журналу "$GIT_DIR/logs/<ref>" (розіменування всіх символічних посилань перед створенням назви журналу), що описує зміну значення посилання. Рядки журналу форматуються так:

    oldsha1 SP newsha1 SP committer LF

Де "oldsha1" — це 40-символьне шістнадцяткове значення, яке раніше зберігалося в <ref>, "newsha1" — це 40-символьне шістнадцяткове значення <new-oid>, а "committer" — це ім'я, адреса електронної пошти та дата комітера у стандартному форматі ідентифікатора комітера Git.

За потреби з -m:

    oldsha1 SP newsha1 SP комітер TAB-повідомлення LF

Де всі поля такі, як описано вище, а "message" – це значення, передане опції -m.

Оновлення завершиться невдачею (без зміни <ref>), якщо поточний користувач не може створити новий файл журналу, додати зміни до існуючого файлу журналу або не має доступної інформації про комітер.

НОТАТКИ
-------

Символічні посилання спочатку були реалізовані за допомогою символічних посилань. Зараз це застаріло, оскільки не всі файлові системи підтримують символічні посилання.

Ця команда слідує за *справжніми* символічними посиланнями, лише якщо вони починаються з "refs/": інакше вона просто спробує прочитати їх та оновити як звичайний файл (тобто дозволить файловій системі слідувати за ними, але перезапише таке символічне посилання на інше місце зі звичайною назвою файлу).

ДИВ. ТАКОЖ
----------
linkgit:git-symbolic-ref[1]

GIT
---
Частина набору linkgit:git[1]
