ВКАЗАННЯ РЕВІЗІЙ
----------------

Параметр ревізії '<rev>' зазвичай, але не обов'язково, іменує об'єкт коміту. Він використовує так званий синтаксис «розширеного SHA-1». Ось різні способи написання імен об'єктів. Ті, що перелічені ближче до кінця цього списку, іменують дерева та блоби, що містяться в коміті.

NOTE: У цьому документі показано "сирий" синтаксис, як його бачить git. Оболонка та інші інтерфейси можуть вимагати додаткових лапок для захисту спеціальних символів та уникнення розбиття слів.

'<sha1>', e.g. 'dae86e1950b1277e545cee180551750029cfe735', 'dae86e'::
  Повна назва об'єкта SHA-1 (40-байтовий шістнадцятковий рядок) або початковий підрядок, унікальний у репозиторії. Наприклад, dae86e1950b1277e545cee180551750029cfe735 та dae86e обидва називають один і той самий об'єкт коміту, якщо у вашому репозиторії немає іншого об'єкта, назва якого починається з dae86e.

'<describeOutput>', e.g. 'v1.7.4.2-679-g3bee7fb'::
  Вивід з `git describe`; тобто найближчий тег, за яким необов'язково слідує тире та кількість комітів, а потім тире, 'g' та скорочена назва об'єкта.

'<refname>', e.g. 'master', 'heads/master', 'refs/heads/master'::
  Символічне ім'я посилання. Наприклад, «master» зазвичай означає об'єкт коміту, на який посилається «refs/heads/master». Якщо у вас є і «heads/master», і «tags/master», ви можете явно вказати «heads/master», щоб вказати Git, який з них ви маєте на увазі. У разі неоднозначності, «<refname>» усувається шляхом вибору першого збігу в наступних правилах:
+
  . Якщо '$GIT_DIR/<refname>' існує, саме це ви маєте на увазі (зазвичай це корисно лише для `HEAD`, `FETCH_HEAD`, `ORIG_HEAD`, `MERGE_HEAD`, `REBASE_HEAD`, `REVERT_HEAD`, `CHERRY_PICK_HEAD`, `BISECT_HEAD` та `AUTO_MERGE`);

  . інакше, 'refs/<refname>', якщо існує;

  . інакше, 'refs/tags/<refname>', якщо існує;

  . інакше, 'refs/heads/<refname>', якщо існує;

  . інакше, 'refs/remotes/<refname>', якщо існує;

  . інакше, 'refs/remotes/<refname>/HEAD', якщо існує.

+
  `HEAD`:::
    називає коміт, на якому базуються зміни в робочому дереві.
  `FETCH_HEAD`:::
    записує гілку, яку ви отримали з віддаленого репозиторію 
    під час вашого останнього виклику `git fetch`.
  `ORIG_HEAD`:::
    створюється командами, які кардинально переміщують вашу `HEAD` (`git
    am`, `git merge`, `git rebase`, `git reset`), щоб записати позицію
    `HEAD` перед їх виконанням, щоб ви могли легко змінити
    кінчик гілки назад до стану до їх запуску.
  `MERGE_HEAD`:::
    записує коміти, які ви зливаєте у свою гілку, коли ви
    запускали `git merge`.
  `REBASE_HEAD`:::
    під час перебазування записує коміт, на якому виконується операція
    наразі зупинено, або через конфлікти, або через команду `edit` у
    інтерактивне перебазування.
  `REVERT_HEAD`:::
    записує коміт, який ви повертаєте, під час виконання команди `git revert`.
  `CHERRY_PICK_HEAD`:::
    записує коміт, який ви вибираєте, коли запускаєте `git
    cherry-pick`.
  `BISECT_HEAD`:::
    записує поточний коміт для перевірки під час запуску `git bisect
    --no-checkout`.
  `AUTO_MERGE`:::
    записує об'єкт дерева, що відповідає стану
    'ort' стратегія злиття записувала дані до робочого дерева під час операції злиття
    призвело до конфліктів.

+
Зверніть увагу, що будь-який із наведених вище випадків 'refs/*' може походити або з каталогу `$GIT_DIR/refs`, або з файлу `$GIT_DIR/packed-refs`. Хоча кодування назв посилань не вказано, перевага надається UTF-8, оскільки деякі процеси обробки виводу можуть передбачати назви посилань у форматі UTF-8.

'@'::
  '@' один — це скорочений шлях для `HEAD`.

'[<refname>]@{<date>}', e.g. 'master@\{yesterday\}', 'HEAD@{5 minutes ago}'::
  Посилання, за яким стоїть суфікс '@' та дата, укладена у дужки (наприклад, '\{yesterday\}', '{1 місяць 2 тижні 3 дні 1 година 1 секунда тому}' або '{1979-02-26 18:30:00}'), вказує значення посилання на попередній момент часу. Цей суфікс можна використовувати лише одразу після назви посилання, і посилання повинно мати існуючий журнал ('$GIT_DIR/logs/<ref>'). Зверніть увагу, що це шукає стан вашого *локального* посилання на заданий момент часу; наприклад, що було у вашій локальній гілці 'master' минулого тижня. Якщо ви хочете переглянути коміти, зроблені протягом певного часу, дивіться `--since` та `--until`.

'<refname>@{<n>}', e.g. 'master@\{1\}'::
  Посилання, за яким стоїть суфікс '@' з порядковим номером, укладеним у дужки (наприклад, '\{1\}', '\{15\}'), вказує n-те попереднє значення цього посилання. Наприклад, 'master@\{1\}' – це безпосереднє попереднє значення 'master', тоді як 'master@\{5\}' – це 5-те попереднє значення 'master'. Цей суфікс можна використовувати лише безпосередньо після назви посилання, і посилання повинно мати існуючий журнал ('$GIT_DIR/logs/<refname>').

'@{<n>}', e.g. '@\{1\}'::
  Ви можете використовувати конструкцію '@' з порожньою частиною ref, щоб отримати запис reflog поточної гілки. Наприклад, якщо ви знаходитесь на гілці 'blabla', то '@\{1\}' означає те саме, що й 'blabla@\{1\}'.

'@{-<n>}', e.g. '@{-1}'::
  Конструкція '@{-<n>}' означає, що <n>-та гілка/коміт була вивантажена перед поточною.

'[<branchname>]@\{upstream\}', e.g. 'master@\{upstream\}', '@\{u\}'::
  Гілку B можна налаштувати для створення поверх гілки X (налаштованої за допомогою `branch.<name>.merge`) на віддаленому R (налаштованому за допомогою `branch.<name>.remote`). B@{u} посилається на гілку віддаленого відстеження для гілки X, взятої з віддаленого R, яка зазвичай знаходиться за адресою `refs/remotes/R/X`.

'[<branchname>]@\{push\}', e.g. 'master@\{push\}', '@\{push\}'::
  Суфікс '@\{push}' повідомляє гілку, "куди ми надішлемо зміни", якщо `git push` було виконано під час отримання `branchname` (або поточний `HEAD`, якщо branchname не вказано). Як і для '@\{upstream\}', ми повідомляємо гілку віддаленого відстеження, яка відповідає цій гілці на віддаленому сервері.
+
Ось приклад, щоб було зрозуміліше:
+
------------------------------
$ git config push.default current
$ git config remote.pushdefault myfork
$ git switch -c mybranch origin/master

$ git rev-parse --symbolic-full-name @{upstream}
refs/remotes/origin/master

$ git rev-parse --symbolic-full-name @{push}
refs/remotes/myfork/mybranch
------------------------------
+
Зверніть увагу, що в прикладі ми налаштували трикутний робочий процес, де ми витягуємо дані з одного місця та надсилаємо їх до іншого. У нетрикутному робочому процесі '@\{push}' те саме, що й '@\{upstream}', і в цьому немає потреби.
+
Цей суфікс також приймається, коли пишеться великими літерами, і означає те саме незалежно від регістру.

'<rev>{caret}[<n>]', e.g. 'HEAD{caret}, v1.5.1{caret}0'::
  Суфікс '{caret}' до параметра ревізії означає першого батька цього об'єкта коміту. '{caret}<n>' означає <n>-го батька (тобто '<rev>{caret}' еквівалентно '<rev>{caret}1'). Як спеціальне правило, '<rev>{caret}0' означає сам коміт і використовується, коли '<rev>' є назвою об'єкта тегу, який посилається на об'єкт коміту.

'<rev>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'::
  Суфікс '{tilde}' до параметра ревізії означає першого батька цього об'єкта коміту. Суфікс '{tilde}<n>' до параметра ревізії означає об'єкт коміту, який є предком <n>-го покоління іменованого об'єкта коміту, наступного лише за першими батьками. Тобто '<rev>{tilde}3' еквівалентно '<rev>{caret}{caret}{caret}', що еквівалентно '<rev>{caret}1{caret}1{caret}1'. Дивіться нижче ілюстрацію використання цієї форми.

'<rev>{caret}{<type>}', e.g. 'v0.99.8{caret}\{commit\}'::
  Суфікс '{caret}', за яким слідує ім'я типу об'єкта, укладене у фігурні дужки, означає рекурсивне розіменування об'єкта з '<rev>', доки не буде знайдено об'єкт типу '<type>' або доки об'єкт більше не буде неможливо розіменувати (у такому випадку відбувається barf). Наприклад, якщо '<rev>' має тип commit, '<rev>{caret}\{commit\}' описує відповідний об'єкт commit. Аналогічно, якщо '<rev>' має тип деревоподібний вигляд, '<rev>{caret}\{tree\}' описує відповідний об'єкт дерева. '<rev>{caret}0' – це скорочення від '<rev>{caret}\{commit\}'.
+
'<rev>{caret}\{object\}' можна використовувати, щоб переконатися, що '<rev>' називає існуючий об'єкт, без необхідності, щоб '<rev>' був тегом, і без розіменування '<rev>'; оскільки тег вже є об'єктом, його не потрібно розіменувати жодного разу, щоб дістатися до об'єкта.
+
'<rev>{caret}\{tag\}' можна використовувати, щоб переконатися, що '<rev>' ідентифікує існуючий об'єкт тегу.

'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'::
  Суфікс '{caret}', за яким йде порожня пара дужок, означає, що об'єкт може бути тегом, і тег може бути розіменований рекурсивно, доки не буде знайдено об'єкт, який не є тегом.

'<rev>{caret}{/<text>}', e.g. 'HEAD^{/fix nasty bug}'::
  Суфікс '{caret}' до параметра ревізії, за яким йде пара фігурних дужок, що містить текст, що починається зі слеш-риси, такий самий, як і синтаксис ':/fix nasty bug' нижче, за винятком того, що він повертає наймолодший відповідний коміт, який можна досягти з '<rev>' перед '{caret}'.

':/<text>', e.g. ':/виправити неприємну помилку::
  Двокрапка, за якою йде склес, а потім текст, іменує коміт, повідомлення якого відповідає заданому регулярному виразу. Це ім'я повертає наймолодший відповідний коміт, який доступний з будь-якого посилання, включаючи HEAD. Регулярний вираз може відповідати будь-якій частині повідомлення коміту. Щоб знайти повідомлення, що починаються з рядка, можна використовувати, наприклад, ':/^foo'. Спеціальна послідовність ':/!' зарезервована для модифікаторів того, що відповідає. ':/!-foo' виконує негативне збігання, тоді як ':/!!foo' відповідає буквальному символу '!', за яким йде 'foo'. Будь-яка інша послідовність, що починається з ':/!', наразі зарезервована. Залежно від заданого тексту, правила розділення слів оболонки можуть вимагати додаткових лапок.

'<rev>:<path>', e.g. 'HEAD:README', 'master:./README'::
  Суфікс ':', за яким слідує шлях, вказує назву блобу або дерева за заданим шляхом в деревоподібному об'єкті, назва якого позначена частиною перед двокрапкою. Шлях, що починається з './' або '../', є відносним до поточного робочого каталогу. Вказаний шлях буде перетворено на шлях, що відповідає кореневому каталогу робочого дерева. Це найбільш корисно для звернення до блобу або дерева з коміту або дерева, яке має таку ж деревоподібну структуру, як і робоче дерево.

':[<n>:]<path>', e.g. ':0:README', ':README'::
  Двокрапка, за якою необов'язково слідує номер етапу (від 0 до 3) та двокрапка, а потім шлях, іменує блоб-об'єкт в індексі за заданим шляхом. Відсутній номер етапу (і двокрапка, що йде після нього) іменує запис етапу 0. Під час злиття етап 1 є спільним предком, етап 2 — версією цільової гілки (зазвичай поточної гілки), а етап 3 — версією з гілки, яка об'єднується.

Ось ілюстрація Джона Лоелігера. Обидва вузли комітів B та C є батьківськими для вузла коміта A. Батьківські коміти впорядковані зліва направо.

........................................
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
........................................

    A =      = A^0
    B = A^   = A^1     = A~1
    C =      = A^2
    D = A^^  = A^1^1   = A~2
    E = B^2  = A^^2
    F = B^3  = A^^3
    G = A^^^ = A^1^1^1 = A~3
    H = D^2  = B^^2    = A^^^2  = A~2^2
    I = F^   = B^3^    = A^^3^
    J = F^2  = B^3^2   = A^^3^2


ВИЗНАЧЕННЯ ДІАПАЗОНІВ
---------------------

Команди перегляду історії, такі як `git log`, працюють з набором комітів, а не лише з одним комітом.

Для цих команд, вказівка однієї ревізії, використовуючи позначення, описані в попередньому розділі, означає набір комітів, «досяжних» з даного коміту.

Вказівка кількох ревізій означає набір комітів, досяжних з будь-якого з заданих комітів.

Досяжна множина коміта — це сам коміт та коміти в його ланцюжку предків.

Існує кілька позначень для позначення набору пов'язаних комітів (так званого "діапазону редакцій"), проілюстрованих нижче.


Винятки комітів
~~~~~~~~~~~~~~~

'{caret}<rev>' (caret) Notation::
 Щоб виключити коміти, досяжні з коміту, використовується префіксна нотація '{caret}'. Наприклад, '{caret}r1 r2' означає коміти, досяжні з 'r2', але виключає ті, досяжні з 'r1' (тобто 'r1' та його предків).

Крапковими позначеннями діапазону
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Нотація діапазону '..' (двокрапка)::
 Операція встановлення '{caret}r1 r2' зустрічається так часто, що для неї існує скорочений запис. Коли у вас є два коміти 'r1' та 'r2' (названі відповідно до синтаксису, поясненого у розділі ВИЗНАЧЕННЯ РЕВІЗІЙ вище), ви можете запитувати коміти, досяжні з r2, за винятком тих, досяжних з r1 за допомогою '{caret}r1 r2', і це можна записати як 'r1..r2'.

Симетрична різницева нотація '\...' (три крапки)::
 Подібне позначення 'r1\...r2' називається симетричною різницею 'r1' та 'r2' та визначається як 'r1 r2 --not $(git merge-base --all r1 r2)'. Це набір комітів, які доступні з одного з 'r1' (ліва сторона) або 'r2' (права сторона), але не з обох.

У цих двох скорочених записах можна пропустити один кінець і дозволити йому використовувати за замовчуванням HEAD. Наприклад, 'origin..' – це скорочення від 'origin..HEAD' і запитує: "Що я зробив після того, як відгалужився від гілки origin?". Аналогічно, '..origin' – це скорочення від 'HEAD..origin' і запитує: "Що зробила гілка origin після того, як я відгалужився від неї?". Зверніть увагу, що '..' означатиме 'HEAD..HEAD', який є порожнім діапазоном, досяжним і недосяжним з HEAD.

Команди, спеціально розроблені для використання двох різних діапазонів (наприклад, "git range-diff R1 R2" для порівняння двох діапазонів), існують, але вони є винятками. Якщо не зазначено інше, усі команди "git", які працюють з набором комітів, працюють з одним діапазоном версій. Іншими словами, запис двох "двокрапкових позначень діапазону" поруч один з одним, наприклад.

    $ git log A..B C..D

*не* визначає два діапазони версій для більшості команд. Натомість він називатиме один зв'язаний набір комітів, тобто тих, які досяжні з B або D, але недосяжні ні з A, ні з C. У лінійній історії, як ця:

    ---A---B---o---o---C---D

Оскільки A та B досяжні з C, діапазон версій, визначений цими двома крапковими діапазонами, є одним комітом D.


Інші скорочені позначення батьківських елементів <rev>{caret}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Існують три інші скорочення, особливо корисні для комітів злиття, для найменування набору, утвореного комітом та його батьківськими комітами.

Нотація 'r1{caret}@' означає всіх батьківських елементів 'r1'.

Нотація 'r1{caret}!' включає коміт 'r1', але виключає всіх його батьківських коммітів. Сама по собі ця нотація позначає єдиний коміт 'r1'.

Нотація '<rev>{caret}-[<n>]' включає '<rev>', але виключає <n>-й батьківський елемент (тобто скорочення для '<rev>{caret}<n>..<rev>'), де '<n>' = 1, якщо не вказано. Зазвичай це корисно для комітів злиття, де ви можете просто передати '<commit>{caret}-', щоб отримати всі коміти у гілці, яка була об'єднана в комміті злиття '<commit>' (включаючи сам '<commit>').

Хоча '<rev>{caret}<n>' стосувалося визначення одного батьківського елемента коміта, ці три позначення також враховують його батьківські елементи. Наприклад, ви можете сказати 'HEAD{caret}2{caret}@', проте ви не можете сказати 'HEAD{caret}@{caret}2'.

Зведення діапазону редакцій
---------------------------

'<rev>'::
	Включіть коміти, доступні з <rev> (тобто <rev> та його предків).

'{caret}<rev>'::
	Виключити коміти, досяжні з <rev> (тобто <rev> та його предків).

'<rev1>..<rev2>'::
	Включити коміти, доступні з <rev2>, але виключити ті, доступні з <rev1>. Якщо <rev1> або <rev2> пропущено, за замовчуванням використовується значення `HEAD`.

'<rev1>\...<rev2>'::
	Включити коміти, доступні з <rev1> або <rev2>, але виключити ті, доступні з обох. Якщо <rev1> або <rev2> пропущено, за замовчуванням використовується значення `HEAD`.

'<rev>{caret}@', e.g. 'HEAD{caret}@'::
  Суфікс '{caret}', після якого стоїть знак at, те саме, що й перелік усіх батьківських об'єктів '<rev>' (тобто, включено все, що доступно з батьківських об'єктів, але не сам коміт).

'<rev>{caret}!', e.g. 'HEAD{caret}!'::
  Суфікс '{caret}', за яким стоїть знак оклику, те саме, що додати комміт '<rev>' та всі його батьківські елементи з префіксом '{caret}', щоб виключити їх (та їхніх предків).

'<rev>{caret}-<n>', e.g. 'HEAD{caret}-, HEAD{caret}-2'::
	Еквівалентно '<rev>{caret}<n>..<rev>', де '<n>' = 1, якщо не вказано.

Ось кілька прикладів з використанням наведеної вище ілюстрації Лелігера, де кожен крок у розкладанні та виборі нотації ретельно прописаний:

....
   Аргументи  Розширені аргументи  Вибрані коміти
   D                            G H D
   D F                          G H I J D F
   ^G D                         H D
   ^D B                         E I J F B
   ^D B C                       E I J F B C
   C                            I J F C
   B..C   = ^B C                C
   B...C  = B ^F C              G H D E B C
   B^-    = B^..B
	  = ^B^1 B              E I J F B
   C^@    = C^1
	  = F                   I J F
   B^@    = B^1 B^2 B^3
	  = D E F               D G H E F I J
   C^!    = C ^C^@
	  = C ^C^1
	  = C ^F                C
   B^!    = B ^B^@
	  = B ^B^1 ^B^2 ^B^3
	  = B ^D ^E ^F          B
   F^! D  = F ^I ^J D           G H D F
....
