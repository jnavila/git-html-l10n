git-merge(1)
============

НАЗВА
-----
git-merge - Об'єднайте дві або більше історій розробки


СИНОПСИС
--------
[synopsis]
git merge [-n] [--stat] [--compact-summary] [--no-commit] [--squash] [--[no-]edit]
	[--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]]
	[--[no-]allow-unrelated-histories]
	[--[no-]rerere-autoupdate] [-m <msg>] [-F <file>]
	[--into-name <branch>] [<commit>...]
git merge (--continue | --abort | --quit)

ОПИС
----
Включає зміни з іменованих комітів (з моменту, коли їхня історія розійшлася з поточної гілки) до поточної гілки. Ця команда використовується командою `git pull` для включення змін з іншого репозиторію та може бути використана вручну для об'єднання змін з однієї гілки в іншу.

Припустимо, що існує наступна історія, а поточна гілка є `master`:

------------
          A---B---C topic
         /
    D---E---F---G master
------------

Потім `git merge topic` відтворить зміни, внесені до гілки `topic` з моменту її відхилення від `master` (тобто `E`), доки її поточний коміт (`C`) не буде розміщено поверх `master`, та запише результат у новий коміт разом з іменами двох батьківських комітів та повідомленням журналу від користувача, що описує зміни. Перед операцією `ORIG_HEAD` встановлюється на кінчик поточної гілки (`G`).

------------
          A---B---C topic
         /         \
    D---E---F---G---H master
------------

Злиття зупиняється, якщо виникає конфлікт, який неможливо вирішити автоматично, або якщо під час ініціювання злиття було вказано параметр `--no-commit`. У цей момент ви можете виконати `git merge --abort` або `git merge --continue`.

`git merge --abort` перерве процес злиття та спробує відновити стан до злиття. Однак, якщо на початку злиття були незафіксовані зміни (і особливо якщо ці зміни були додатково змінені після початку злиття), `git merge --abort` у деяких випадках не зможе відновити оригінальні (до злиття) зміни. Тому:

WARNING: Запуск `git merge` з нетривіальними незакоміченими змінами не рекомендується: хоча це можливо, це може призвести до стану, з якого буде важко вийти у разі конфлікту.

ОПЦІЇ
-----
:git-merge: 1

include::merge-options.adoc[]

`-m <msg>`::
	Встановіть повідомлення коміту, яке буде використовуватися для коміту злиття (якщо такий створено).
+
Якщо вказано `--log`, до вказаного повідомлення буде додано короткий журнал комітів, що об'єднуються.
+
Команду `git fmt-merge-msg` можна використовувати для встановлення гарного значення за замовчуванням для автоматичних викликів `git merge`. Автоматизоване повідомлення може містити опис гілки.

`--into-name <branch>`::
	Підготувати повідомлення про злиття за замовчуванням так, ніби злиття виконується з гілкою _<гілка>_, замість назви реальної гілки, з якою виконується злиття.

`-F <файл>`::
`--file=<файл>`::
	Прочитайте повідомлення коміту, яке буде використано для коміту злиття (якщо такий створено).
+
Якщо вказано `--log`, до вказаного повідомлення буде додано короткий журнал комітів, що об'єднуються.

include::rerere-options.adoc[]

`--overwrite-ignore`::
`--no-overwrite-ignore`::
	Тихо перезаписувати ігноровані файли з результату об'єднання. Це поведінка за замовчуванням. Використовуйте `--no-overwrite-ignore` для переривання.

`--abort`::
	Перервати поточний процес вирішення конфліктів та спробувати відновити стан до об'єднання. Якщо запис автосховища присутній, застосувати його до робочого дерева.
+
Якщо на початку злиття були присутні незафіксовані зміни в робочому дереві, `git merge --abort` у деяких випадках не зможе їх реконструювати. Тому рекомендується завжди зафіксувати або зберегти зміни перед запуском `git merge`.
+
`git merge --abort` еквівалентно `git reset --merge`, коли присутній `MERGE_HEAD`, окрім випадків, коли також присутній `MERGE_AUTOSTASH`, у цьому випадку `git merge --abort` застосовує запис stash до робочого дерева, тоді як `git reset --merge` збереже збережені зміни у списку stash.

`--quit`::
	Забудьте про поточне злиття, що виконується. Залиште індекс та робоче дерево як є. Якщо присутній `MERGE_AUTOSTASH`, запис stash буде збережено до списку stash.

`--continue`::
	Після того, як `git merge` зупиниться через конфлікти, ви можете завершити злиття, виконавши `git merge --continue` (див. розділ "ЯК ВИРІШИТИ КОНФЛІКТИ" нижче).

`<commit>...`::
	Коміти, зазвичай інші заголовки гілок, для злиття з нашою гілкою. Вказівка більше одного коміту створить злиття з більш ніж двома батьківськими елементами (ласково називається злиттям Octopus).
+
Якщо з командного рядка не надано жодного коміту, об'єднайте гілки віддаленого відстеження, які поточна гілка налаштована використовувати як свою початкову. Дивіться також розділ налаштування цієї сторінки підручника.
+
Коли вказано `FETCH_HEAD` (і жодного іншого коміту), гілки, записані у файлі `.git/FETCH_HEAD` попереднім викликом `git fetch` для об'єднання, об'єднуються з поточною гілкою.


ПЕРЕВІРКИ ПЕРЕД ЗЛИТТЯМ
-----------------------

Перш ніж застосовувати зовнішні зміни, вам слід привести власну роботу у належний стан та закомітити її локально, щоб вона не була знищена у разі конфліктів. Див. також linkgit:git-stash[1]. `git pull` та `git merge` зупиняться без жодних дій, коли локальні незакомічені зміни перетинаються з файлами, які `git pull`/`git merge` може потребувати оновлення.

Щоб уникнути запису непов'язаних змін у коміті злиття, `git pull` та `git merge` також перервуть виконання, якщо в індексі відносно коміту `HEAD` будуть зареєстровані будь-які зміни. (Можуть існувати спеціальні вузькі винятки з цього правила залежно від того, яка стратегія злиття використовується, але загалом індекс має відповідати `HEAD`.)

Якщо всі іменовані коміти вже є предками `HEAD`, `git merge` завершить роботу раніше терміну з повідомленням "Вже оновлено".

ШВИДКЕ ЗЛИТТЯ
-------------

Часто поточна гілка head є предком іменованого коміту. Це найпоширеніший випадок, особливо коли викликається з `git pull`: ви відстежуєте репозиторій основної ланки, не закомітили жодних локальних змін, а тепер хочете оновити його до новішої версії основної ланки. У цьому випадку новий коміт не потрібен для зберігання об'єднаної історії; натомість `HEAD` (разом з індексом) оновлюється, щоб вказувати на іменований коміт, без створення додаткового коміту злиття.

Цю поведінку можна придушити за допомогою опції `--no-ff`.

СПРАВЖНЄ ЗЛИТТЯ
---------------

За винятком випадків швидкого злиття (див. вище), гілки, що об'єднуються, повинні бути пов'язані разом комітом злиття, в якому обидві гілки є їхніми батьками.

Об'єднана версія, що узгоджує зміни з усіх гілок, що об'єднуються, зберігається, і ваші `HEAD`, індекс та робоче дерево оновлюються відповідно до неї. Ви можете мати зміни в робочому дереві, якщо вони не перетинаються; оновлення їх збереже.

Коли незрозуміло, як узгодити зміни, відбувається таке:

1. Вказівник `HEAD` залишається незмінним.
2. Посилання `MERGE_HEAD` встановлено так, щоб воно вказувало на заголовок іншої гілки.
3. Шляхи, які було об'єднано без зайвих зусиль, оновлюються як у файлі індексу, так і у вашому робочому дереві.
4. Для конфліктуючих шляхів індексний файл записує до трьох версій: етап 1 зберігає версію від спільного предка, етап 2 з `HEAD`, а етап 3 з `MERGE_HEAD` (ви можете перевірити етапи за допомогою `git ls-files -u`). Робочі файли дерева містять результат операції злиття, тобто результати 3-стороннього злиття зі знайомими маркерами конфлікту +<<<+ `===` +>>>+.
5. Записується посилання з назвою `AUTO_MERGE`, яке вказує на дерево, що відповідає поточному вмісту робочого дерева (включаючи маркери конфліктів для текстових конфліктів). Зверніть увагу, що це посилання записується лише тоді, коли використовується стратегія злиття `ort` (за замовчуванням).
6. Жодних інших змін не вноситься. Зокрема, локальні зміни, які ви мали до початку злиття, залишаться незмінними, а записи індексу для них залишаться такими, якими вони були, тобто збігатимуться з `HEAD`.

Якщо ви спробували злиття, яке призвело до складних конфліктів, і хочете почати спочатку, ви можете відновити його за допомогою `git merge --abort`.

ТЕГ ОБ'ЄДНАННЯ
--------------

Під час об'єднання анотованого (і, можливо, підписаного) тегу, Git завжди створює коміт злиття, навіть якщо можливе прискорене злиття, а шаблон повідомлення коміта готується разом із повідомленням тегу. Крім того, якщо тег підписаний, перевірка підпису повідомляється як коментар у шаблоні повідомлення. Див. також linkgit:git-tag[1].

Коли ви хочете просто інтегруватися з роботою, що веде до коміту, який випадково позначено тегом, наприклад, синхронізуючи з точкою випуску основної версії, ви можете не захотіти створювати непотрібний коміт злиття.

У такому випадку ви можете самостійно "розгорнути" тег перед тим, як передати його до `git merge`, або передати `--ff-only`, коли у вас немає власної роботи. Наприклад.

----
git fetch origin
git merge v1.2.3^0
git merge --ff-only v1.2.3
----

ЯК ПРЕДСТАВЛЯЮТЬСЯ КОНФЛІКТИ
----------------------------

Під час злиття файли робочого дерева оновлюються, щоб відобразити результат злиття. Серед змін, внесених до версії спільного предка, ті, що не перекриваються (тобто ви змінили область файлу, а інша сторона залишила цю область недоторканою, або навпаки), дослівно включаються до кінцевого результату. Однак, коли обидві сторони внесли зміни в одну й ту саму область, Git не може випадковим чином вибрати одну сторону замість іншої та просить вас вирішити це, залишивши те, що обидві сторони зробили, в цій області.

За замовчуванням Git використовує той самий стиль, що й програма "merge" з набору RCS, для представлення такого конфліктного фрагмента, ось так:

------------
Ось рядки, які або не змінилися від спільного
предка, або чисто вирішені, оскільки змінилася лише одна сторона,
або чисто вирішені, оскільки обидві сторони змінилися однаково.
<<<<<<< ваш:sample.txt
Вирішення конфліктів складне; 
Давайте підемо за покупками.
=======
Git спрощує вирішення конфліктів.
>>>>>>> їхній:sample.txt
А ось ще один рядок, який чисто вирішено або не змінено.
------------

Область, де відбулася пара конфліктуючих змін, позначена маркерами +<<<<<<<+, `=======` та +>>>>>>>+. Частина перед `=======` зазвичай відповідає вашій стороні, а частина після неї — їхній стороні.

Формат за замовчуванням не відображає, що було написано в оригіналі в конфліктній області. Ви не можете сказати, скільки рядків видалено та замінено зауваженням Барбі з вашого боку. Єдине, що ви можете сказати, це те, що ваша сторона хоче сказати, що це важко, і ви б воліли піти на шопінг, тоді як інша сторона хоче стверджувати, що це легко.

Альтернативний стиль можна використовувати, встановивши змінну конфігурації `merge.conflictStyle` на `diff3` або `zdiff3`. У стилі `diff3` вищезгаданий конфлікт може виглядати так:

------------
Ось рядки, які або не змінилися від спільного
предка, або чисто вирішені, оскільки змінилася лише одна сторона,
<<<<<<< yours:sample.txt
або чисто вирішені, оскільки обидві сторони змінилися однаково.
Вирішення конфліктів складне;
давайте підемо за покупками.
||||||| base:sample.txt
або чисто вирішені, оскільки обидві сторони змінилися однаково.
Вирішення конфліктів складне.
=======
або чисто вирішені, оскільки обидві сторони змінилися однаково.
Git спрощує вирішення конфліктів.
>>>>>>> theirs:sample.txt
А ось ще один рядок, який чисто вирішений або незмінений.
------------

у стилі `zdiff3` це може виглядати так:

------------
Ось рядки, які або не змінилися від спільного
предка, або чисто вирішені, оскільки змінилася лише одна сторона,
або чисто вирішені, оскільки обидві сторони змінилися однаково.
<<<<<<< yours:sample.txt
Вирішення конфліктів складне;
давайте підемо за покупками.
||||||| base:sample.txt
або чисто вирішені, оскільки обидві сторони змінилися однаково.
Вирішення конфліктів складне.
=======
Git спрощує вирішення конфліктів.
>>>>>>> theirs:sample.txt
А ось ще один рядок, який чисто вирішений або незмінений.
------------

Окрім маркерів +<<<<<<<+, `=======` та +>>>>>>>+, використовується ще один маркер +||||||||+, за яким йде оригінальний текст. Ви можете зрозуміти, що в оригіналі просто було сказано факт, а ваша сторона просто погодилася з цим твердженням і здалася, тоді як інша сторона намагалася мати більш позитивний настрій. Іноді ви можете знайти краще рішення, переглянувши оригінал.


ЯК ВИРІШУВАТИ КОНФЛІКТИ
-----------------------

Після виявлення конфлікту ви можете зробити дві речі:

 * Вирішіть не зливати. Єдине, що вам потрібно зробити, це скинути індексний файл до коміту `HEAD` для скасування коміту 2 та очистити зміни робочого дерева, внесені комітами 2 та 3; для цього можна використовувати `git merge --abort`.

 * Вирішіть конфлікти. Git позначить конфлікти в робочому дереві. Відредагуйте файли у відповідній формі та `git add` додайте їх до індексу. Використовуйте `git commit` або `git merge --continue` для завершення угоди. Остання команда перевіряє, чи виконується (перерване) злиття, перш ніж викликати `git commit`.

Ви можете вирішити конфлікт за допомогою кількох інструментів:

 * Використайте mergetool. `git mergetool` для запуску графічного mergetool, який працюватиме разом з вами під час злиття.

 * Перегляньте різниці. `git diff` покаже тристоронню різницю, виділяючи зміни з обох версій, `HEAD` та `MERGE_HEAD`. `git diff AUTO_MERGE` покаже, які зміни ви внесли на даний момент для вирішення текстових конфліктів.

 * Перегляньте відмінності з кожної гілки. `git log --merge -p <шлях>` спочатку покаже відмінності для версії `HEAD`, а потім для версії `MERGE_HEAD`.

 * Подивіться на оригінали. `git show :1:filename` показує спільного предка, `git show :2:filename` показує версію `HEAD`, а `git show :3:filename` показує версію `MERGE_HEAD`.


ПРИКЛАДИ
--------

* Об'єднати гілки `виправлення` та `покращення` поверх поточної гілки, створивши злиття типу "осьминог":
+
------------------------------------------------
$ git merge fixes enhancements
------------------------------------------------

* Об'єднати гілку `obsolete` з поточною гілкою, використовуючи стратегію злиття `ours`:
+
------------------------------------------------
$ git merge -s ours obsolete
------------------------------------------------

* Об'єднати гілку `maint` з поточною гілкою, але не створювати новий коміт автоматично:
+
------------------------------------------------
$ git merge --no-commit maint
------------------------------------------------
+
Це можна використовувати, коли ви хочете включити подальші зміни до злиття або хочете написати власне повідомлення коміту злиття.
+
Вам слід утримуватися від зловживання цією опцією для внесення суттєвих змін у коміт злиття. Невеликі виправлення, такі як зміна назви релізу/версії, будуть прийнятними.


include::merge-strategies.adoc[]

КОНФІГУРАЦІЯ
------------

`branch.<name>.mergeOptions`::
	Встановлює параметри за замовчуванням для злиття у гілку _<назва>_. Синтаксис та підтримувані параметри такі ж, як і у `git merge`, але значення параметрів, що містять пробіли, наразі не підтримуються.

include::includes/cmd-config-section-rest.adoc[]

include::config/merge.adoc[]

ДИВ. ТАКОЖ
----------
linkgit:git-fmt-merge-msg[1], linkgit:git-pull[1], linkgit:gitattributes[5], linkgit:git-reset[1], linkgit:git-diff[1], linkgit:git-ls-files[1], linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mergetool[1]

GIT
---
Частина набору linkgit:git[1]
