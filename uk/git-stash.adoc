git-stash(1)
============

НАЗВА
-----
git-stash - Збережіть зміни в брудному робочому каталозі

СИНОПСИС
--------
[synopsis]
'git stash' list [<log-options>]
'git stash' show [-u | --include-untracked | --only-untracked] [<diff-options>] [<stash>]
'git stash' drop [-q | --quiet] [<stash>]
'git stash' pop [--index] [-q | --quiet] [<stash>]
'git stash' apply [--index] [-q | --quiet] [<stash>]
'git stash' branch <branchname> [<stash>]
'git stash' [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]
	     [-u | --include-untracked] [-a | --all] [(-m | --message) <message>]
	     [--pathspec-from-file=<file> [--pathspec-file-nul]]
	     [--] [<pathspec>...]]
'git stash' save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]
          [-u | --include-untracked] [-a | --all] [<message>]
git stash clear
git stash create [<message>]
git stash store [(-m | --message) <message>] [-q | --quiet] <commit>
git stash export (--print | --to-ref <ref>) [<stash>...]
git stash import <commit>

ОПИС
----

Використовуйте `git stash`, коли хочете записати поточний стан робочого каталогу та індексу, але хочете повернутися до чистого робочого каталогу. Команда зберігає ваші локальні зміни та повертає робочий каталог до стану, що відповідає коміту `HEAD`.

Зміни, збережені цією командою, можна переглянути за допомогою `git stash list`, перевірити за допомогою `git stash show` та відновити (можливо, поверх іншого коміту) за допомогою `git stash apply`. Виклик `git stash` без будь-яких аргументів еквівалентний `git stash push`. За замовчуванням stash відображається як "WIP on '<branchname>' ...", але ви можете надати більш детальне повідомлення в командному рядку під час створення.

Останній створений вами хованку зберігається в `refs/stash`; старіші хованки знаходяться в reflog цього посилання та можуть бути названі за допомогою звичайного синтаксису reflog (наприклад, `stash@{0}` — це останній створений хованку, `stash@{1}` — той, що перед ним, також можливий `stash@{2.hours.ago}`). На хованки також можна посилатися, вказуючи лише індекс хованки (наприклад, ціле число `<n>` еквівалентне `stash@{<n>}`).

КОМАНДИ
-------

`push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-u | --include-untracked] [ -a | --all] [-q | --quiet] [(-m|--message) <message>] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>...]`::

	Збережіть ваші локальні зміни в новому «записі stash» та поверніть їх до `HEAD` (у робочому дереві та в індексі). Частина _<message>_ є необов'язковою та містить опис разом зі станом stash.
+
Для швидкого створення знімка можна пропустити "push". У цьому режимі аргументи, що не є опціями, не дозволені, щоб запобігти створенню небажаного запису в сховищі з помилкою підкоманди. Двома винятками є `stash -p`, який діє як псевдонім для `stash push -p`, та елементи pathspec, які дозволені після подвійного дефісу `--` для усунення неоднозначності.

`save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-u | --include-untracked] [-a | --all] [-q | --quiet] [<message>]`::

	Цей параметр застарів на користь «git stash push». Він відрізняється від «stash push» тим, що не може приймати pathspec. Натомість усі аргументи, що не є параметрами, об'єднуються для формування повідомлення stash.

`list [<log-options>]`::

	Перелічіть записи stash, які у вас є на даний момент. Кожен «запис stash» перелічено з його назвою (наприклад, `stash@{0}` – це останній запис, `stash@{1}` – попередній тощо), назвою гілки, яка була поточною на момент створення запису, та коротким описом коміту, на якому базувався запис.
+
----------------------------------------------------------------
stash@{0}: Незавершене виконання при надсиланні: 6ebd0e2... Оновити документацію git-stash
stash@{1}: На головному файлі: 9cc0589... Додати git-stash
----------------------------------------------------------------
+
Команда використовує опції, що застосовуються до команди «git log», щоб контролювати, що і як відображається. Див. linkgit:git-log[1].

`show [-u | --include-untracked | --only-untracked] [<diff-options>] [<stash>]`::

	Показати зміни, записані в записі stash, як різницю між вмістом stash та комітом, збереженим під час першого створення запису stash. За замовчуванням команда показує diffstat, але прийматиме будь-який формат, відомий 'git diff' (наприклад, `git stash show -p stash@{1}` для перегляду другого за останнім запису у формі патча). Якщо _<diff-option>_ не вказано, поведінка за замовчуванням буде задана змінними конфігурації `stash.showStat` та `stash.showPatch`. Ви також можете використовувати `stash.showIncludeUntracked`, щоб встановити, чи ввімкнено `--include-untracked` за замовчуванням.

`pop [--index] [-q | --quiet] [<stash>]`::

	Видалити один сховищений стан зі списку сховищ та застосувати його поверх поточного робочого стану дерева, тобто виконати операцію, зворотну до `git stash push`. Робочий каталог має відповідати індексу.
+
Застосування стану може призвести до невдачі через конфлікти; у цьому випадку він не видаляється зі списку stash. Вам потрібно вирішити конфлікти вручну та після цього вручну викликати `git stash drop`.

`apply [--index] [-q | --quiet] [<stash>]`::

	Як і `pop`, але не видаляти стан зі списку stash. На відміну від `pop`, `<stash>` може бути будь-яким комітом, який виглядає як коміт, створений за допомогою `stash push` або `stash create`.

`branch <branchname> [<stash>]`::

	Створює та витягує нову гілку з іменем _<назвагілки>_, починаючи з коміту, в якому _<stash>_ було спочатку створено, застосовує зміни, записані в _<stash>_, до нового робочого дерева та індексу. Якщо це вдається, і _<stash>_ є посиланням у формі `stash@{<ревізія>}`, то _<stash>_ видаляється.
+
Це корисно, якщо гілка, на якій ви виконали `git stash push`, змінилася настільки, що `git stash apply` не вдається виконати через конфлікти. Оскільки запис stash застосовується поверх коміту, який був HEAD на момент запуску `git stash`, він відновлює початковий стан stash без конфліктів.

`clear`::
	Видаліть усі записи зі сховища. Зверніть увагу, що ці записи потім будуть видалені, і їх може бути неможливо відновити (див. «ПРИКЛАДИ» нижче для можливої стратегії).

`drop [-q | --quiet] [<stash>]`::
	Видалити один запис stash зі списку записів stash.

`create`::
	Створіть запис stash (який є звичайним об'єктом commit) та поверніть його назву об'єкта, не зберігаючи її ніде в просторі імен ref. Це призначено для використання у скриптах. Ймовірно, це не та команда, яку ви хочете використовувати; див. "push" вище.

`store`::

	Зберегти заданий stash, створений за допомогою 'git stash create' (що є завислим комітом злиття), у stash ref, оновлюючи stash reflog. Це призначено для використання скриптами. Ймовірно, це не та команда, яку ви хочете використовувати; див. "push" вище.

`export ( --print | --to-ref <ref> ) [<stash>...]`::

	Експортувати зазначені сховища, або всі, якщо жодного не вказано, до ланцюжка комітів, які можна передати за допомогою звичайних механізмів fetch та push, а потім імпортувати за допомогою підкоманди `import`.

`import <commit>`::
	Імпортуйте вказані сховища з вказаного коміту, який мав бути створений за допомогою `export`, та додайте їх до списку сховищ. Щоб замінити існуючі сховища, спочатку скористайтеся `clear`.

ОПЦІЇ
-----
`-a`::
`--all`::
	Ця опція дійсна лише для команд `push` та `save`.
+
Усі ігноровані та невідстежувані файли також зберігаються, а потім очищаються за допомогою `git clean`.

`-u`::
`--include-untracked`::
`--no-include-untracked`::
	При використанні з командами `push` та `save`, усі невідстежувані файли також зберігаються, а потім очищаються за допомогою `git clean`.
+
При використанні з командою `show`, відображати невідстежувані файли у записі stash як частину різниці.

`--only-untracked`::
	Ця опція дійсна лише для команди `show`.
+
Показувати лише невідстежувані файли у записі stash як частину різниці.

`--index`::
	Цей параметр дійсний лише для команд `pop` та `apply`.
+
Намагається відновити не лише зміни робочого дерева, а й зміни індексу. Однак це може призвести до невдачі, якщо у вас є конфлікти (які зберігаються в індексі, де ви, отже, більше не можете застосувати зміни в початковому вигляді).

`-k`::
`--keep-index`::
`--no-keep-index`::
	Ця опція дійсна лише для команд `push` та `save`.
+
Усі зміни, вже додані до індексу, залишаються незмінними.

`-p`::
`--patch`::
	Ця опція дійсна лише для команд `push` та `save`.
+
Інтерактивно вибирайте фрагменти з різниці між HEAD та робочим деревом для зберігання. Запис stash побудовано таким чином, що його індексний стан збігається зі станом індексу вашого репозиторію, а його робоче дерево містить лише зміни, вибрані вами інтерактивно. Потім вибрані зміни скасовуються з вашого робочого дерева. Дивіться розділ ``Інтерактивний режим'' у linkgit:git-add[1], щоб дізнатися, як керувати режимом `--patch`.
+
Опція `--patch` передбачає `--keep-index`. Ви можете скористатися `--no-keep-index`, щоб перевизначити це.

include::diff-context-options.adoc[]

`-S`::
`--staged`::
	Ця опція дійсна лише для команд `push` та `save`.
+
Зберігає лише ті зміни, які зараз перебувають у індексі. Це схоже на базовий `git commit`, за винятком того, що стан зберігається у сховищі, а не в поточній гілці.
+
Опція `--patch` має пріоритет над цією.

`--pathspec-from-file=<файл>`::
	Ця опція дійсна лише для команди `push`.
+
Специфікація шляху передається у _<файл>_ замість аргументів командного рядка. Якщо _<файл>_ дорівнює саме `-`, то використовується стандартний ввід. Елементи Pathspec розділяються символами LF або CR/LF. Елементи Pathspec можна брати в лапки, як пояснено для змінної конфігурації `core.quotePath` (див. linkgit:git-config[1]). Див. також `--pathspec-file-nul` та глобальну змінну `--literal-pathspecs`.

`--pathspec-file-nul`::
	Ця опція дійсна лише для команди `push`.
+
Має значення лише з `--pathspec-from-file`. Елементи Pathspec розділяються символом NUL, а всі інші символи (включно з символами нового рядка та лапками) сприймаються буквально.

`-q`::
`--quiet`::
	Ця опція дійсна лише для команд `apply`, `drop`, `pop`, `push`, `save`, `store`.
+
Тихі, придушені повідомлення зворотного зв'язку.

`--print`::
	Цей параметр дійсний лише для команди `export`.
+
Створіть ланцюжок комітів, що представляють експортовані схованки, без їх збереження в просторі імен ref, та виведіть ідентифікатор об'єкта у стандартний вивід. Це розроблено для скриптів.

`--to-ref`::
	Цей параметр дійсний лише для команди `export`.
+
Створіть ланцюжок комітів, що представляють експортовані схованки, та збережіть його у вказаному посиланні.

`--`::
	Ця опція дійсна лише для команди `push`.
+
Відокремлює pathspec від опцій для усунення неоднозначності.

`<pathspec>...`::
	Ця опція дійсна лише для команди `push`.
+
Новий запис stash записує змінені стани лише для файлів, які відповідають специфікації шляху. Записи індексу та файли робочого дерева потім повертаються до стану, зазначеного в HEAD лише для цих файлів, залишаючи файли, які не відповідають специфікації шляху, недоторканими.
+
Для отримання додаткової інформації див. запис «pathspec» у linkgit:gitglossary[7].

_<stash>_::
	Цей параметр дійсний лише для команд `apply`, `branch`, `drop`, `pop`, `show` та `export`.
+
Посилання у форматі `stash@{<версія>}`. Якщо _<stash>_ не вказано, передбачається, що це найновіший stash (тобто `stash@{0}`).

ОБГОВОРЕННЯ
-----------

Запис stash представлений як коміт, дерево якого записує стан робочого каталогу, а його перший батько – це коміт з `HEAD` на момент створення запису. Дерево другого батька записує стан індексу на момент створення запису та стає дочірнім для коміту `HEAD`. Граф предків виглядає так:

            .----W
           /    /
     -----H----I

де `H` — це коміт `HEAD`, `I` — це коміт, який записує стан індексу, а `W` — це коміт, який записує стан робочого дерева.


ПРИКЛАДИ
--------

В'їжджаєш у брудне дерево::

Коли ви перебуваєте посеред чогось, ви дізнаєтеся, що є зміни в апстрімі, які, можливо, мають відношення до того, що ви робите. Коли ваші локальні зміни не конфліктують зі змінами в апстрімі, простий `git pull` дозволить вам рухатися далі.
+
Однак, бувають випадки, коли ваші локальні зміни конфліктують зі змінами, що були в основній базі даних, і `git pull` відмовляється перезаписувати ваші зміни. У такому випадку ви можете зберегти свої зміни, виконати їх вилучення, а потім розпакувати їх, ось так:
+
----------------------------------------------------------------
$ git pull
 ...
Файл foobar не оновлений, об'єднання неможливе.
$ git stash
$ git pull
$ git stash pop
----------------------------------------------------------------

Перерваний робочий процес::

Коли ви посеред якоїсь справи, ваш начальник вимагає негайно щось виправити. Традиційно ви робите коміт у тимчасову гілку для зберігання змін і повертаєтеся до початкової гілки, щоб зробити екстрене виправлення, ось так:
+
----------------------------------------------------------------
# ... зламати зламати зламати ...
$ git switch -c my_wip
$ git commit -a -m "WIP"
$ git switch master
$ edit emergency fix
$ git commit -a -m "Fix in a hurry"
$ git switch my_wip
$ git reset --soft HEAD^
# ... продовжуйте хакінг ...
----------------------------------------------------------------
+
Ви можете скористатися 'git stash' для спрощення вищезазначеного, ось так:
+
----------------------------------------------------------------
# ... зламати, зламати, зламати...
$ git stash
$ edit emergency fix
$ git commit -a -m "Fix in a hurry"
$ git stash pop
# ... продовжуйте хакінг...
----------------------------------------------------------------

Тестування часткових комітів::

Ви можете використовувати `git stash push --keep-index`, коли хочете зробити два або більше комітів зі змін у робочому дереві, і хочете перевірити кожну зміну перед комітом:
+
----------------------------------------------------------------
# ... зламати, зламати, зламати...
$ git add --patch foo            # додати лише першу частину до індексу
$ git stash push --keep-index    # зберегти всі інші зміни до сховища
$ edit/build/test first part
$ git commit -m 'First part'     # зафіксувати повністю перевірені зміни
$ git stash pop                  # підготуватися до роботи над усіма іншими змінами
# ... повторюйте вищезазначені п'ять кроків, поки не залишиться один коміт ...
$ edit/build/test remaining parts
$ git commit foo -m 'Remaining parts'
----------------------------------------------------------------

Збереження непов’язаних змін для подальшого використання::

Коли ви перебуваєте посеред масштабних змін і знаходите якусь непов'язану проблему, яку не хочете забути виправити, ви можете внести зміни, проіндексувати їх та використати `git stash push --staged`, щоб зберегти їх для подальшого використання. Це схоже на комміт проіндексованих змін, тільки коміт потрапляє до сховища, а не до поточної гілки.
+
----------------------------------------------------------------
# ... зламати, зламати, зламати...
$ git add --patch foo           # додати непов'язані зміни до індексу
$ git stash push --staged       # зберегти ці зміни у сховищі
# ... зламати, зламати, зламати, завершити поточні зміни ...
$ git commit -m 'Massive'       # зафіксувати повністю перевірені зміни
$ git switch fixup-branch       # перейти до іншого відділення
$ git stash pop                 # завершити роботу над збереженими змінами
----------------------------------------------------------------

Відновлення записів зі сховища, які були помилково очищені/видалені::

Якщо ви помилково видалите або очистите записи зі сховища, їх не можна буде відновити за допомогою звичайних механізмів безпеки. Однак, ви можете спробувати наступне заклинання, щоб отримати список записів зі сховища, які все ще знаходяться у вашому репозиторії, але більше недоступні:
+
----------------------------------------------------------------
git fsck --unreachable |
grep commit | cut -d\  -f3 |
xargs git log --merges --no-walk --grep=WIP
----------------------------------------------------------------

КОНФІГУРАЦІЯ
------------

include::includes/cmd-config-section-all.adoc[]

:git-stash: 1
include::config/stash.adoc[]


ДИВ. ТАКОЖ
----------
linkgit:git-checkout[1], linkgit:git-commit[1], linkgit:git-reflog[1], linkgit:git-reset[1], linkgit:git-switch[1]

GIT
---
Частина набору linkgit:git[1]
