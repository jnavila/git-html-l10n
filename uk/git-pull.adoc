git-pull(1)
===========

НАЗВА
-----
git-pull - Отримання даних з іншого репозиторію або локальної гілки та інтеграція з ними


СИНОПСИС
--------
[verse]
'git pull' [<options>] [<repository> [<refspec>...]]


ОПИС
----

Включає зміни з віддаленого репозиторію до поточної гілки. Якщо поточна гілка знаходиться за віддаленою, то за замовчуванням буде перемотувано поточну гілку вперед, щоб вона відповідала віддаленій. Якщо поточна гілка та віддалена розійшлися, користувачеві потрібно вказати, як узгодити розбіжні гілки за допомогою `--rebase` або `--no-rebase` (або відповідного параметра конфігурації в `pull.rebase`).

Точніше, `git pull` запускає `git fetch` із заданими параметрами, а потім, залежно від опцій конфігурації або прапорців командного рядка, викликає `git rebase` або `git merge` для узгодження розбіжних гілок.

<repository> має бути назвою віддаленого репозиторію, як передається до linkgit:git-fetch[1]. <refspec> може називати довільне віддалене посилання (наприклад, назву тегу) або навіть колекцію посилань з відповідними гілками віддаленого відстеження (наприклад, refs/heads/{asterisk}:refs/remotes/origin/{asterisk}), але зазвичай це назва гілки у віддаленому репозиторії.

Значення за замовчуванням для <repository> та <branch> зчитуються з конфігурації "remote" та "merge" для поточної гілки, як встановлено параметром linkgit:git-branch[1] `--track`.

Припустимо, що існує наступна історія, а поточна гілка є "`master`":

------------
	  A---B---C майстер походження
	 /
    D---E---F---G master
	^
	origin/master у вашому репозиторії
------------

Потім "`git pull`" отримає та відтворить зміни з віддаленої гілки `master` з моменту її відхилення від локальної `master` (тобто `E`) до її поточного коміту (`C`) поверх `master` та запише результат у новий коміт разом з іменами двох батьківських комітів та повідомленням журналу від користувача, що описує зміни.

------------
	  A---B---C origin/master
	 /         \
    D---E---F---G---H master
------------

Див. linkgit:git-merge[1] для отримання детальної інформації, зокрема про те, як представлені та оброблені конфлікти.

У Git 1.7.0 або пізнішої версії, щоб скасувати конфліктуюче злиття, використовуйте `git reset --merge`. *Попередження*: У старіших версіях Git не рекомендується запускати 'git pull' з незакоміченими змінами: хоча це можливо, це залишає вас у стані, з якого може бути важко вийти у разі конфлікту.

Якщо будь-які віддалені зміни перетинаються з локальними незафіксованими змінами, злиття буде автоматично скасовано, а дерево робіт залишиться недоторканим. Зазвичай найкраще привести будь-які локальні зміни до робочого стану, перш ніж витягувати або зберігати їх за допомогою linkgit:git-stash[1].

ОПЦІЇ
-----

-q::
--quiet::
	Це передається як базовому git-fetch для приглушення звітів під час передачі, так і базовому git-merge для приглушення виводу під час злиття.

-v::
--verbose::
	Передати --verbose до git-fetch та git-merge.

--[no-]recurse-submodules[=(yes|on-demand|no)]::
	Цей параметр контролює, чи слід отримувати нові коміти заповнених підмодулів, а також чи слід оновлювати робочі дерева активних підмодулів (див. linkgit:git-fetch[1], linkgit:git-config[1] та linkgit:gitmodules[5]).
+
Якщо отримання виконується через перебазування, локальні коміти підмодулів також перебазуються.
+
Якщо оновлення виконується через злиття, конфлікти підмодулів вирішуються та перевіряються.

Варіанти, пов'язані з об'єднанням
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:git-pull: 1

include::merge-options.adoc[]

-r::
--rebase[=(false|true|merges|interactive)]::
	Якщо значення true, перебазувати поточну гілку поверх гілки вище за течією після отримання даних. Якщо існує гілка віддаленого відстеження, що відповідає гілці вище за течією, і гілка вище за течією була перебазована з моменту останньої отримання даних, перебазування використовує цю інформацію, щоб уникнути перебазування нелокальних змін.
+
Якщо встановлено значення `merges`, перебазуйте за допомогою `git rebase --rebase-merges`, щоб локальні коміти злиття були включені до перебазування (див. linkgit:git-rebase[1] для отримання детальнішої інформації).
+
Якщо значення false, об'єднати гілку вище за течією з поточною гілкою.
+
Коли встановлено значення `interactive`, увімкнути інтерактивний режим перебазування.
+
Дивіться `pull.rebase`, `branch.<name>.rebase` та `branch.autoSetupRebase` у linkgit:git-config[1], якщо ви хочете, щоб `git pull` завжди використовував `--rebase` замість злиття.
+
[NOTE]
Це потенційно _небезпечний_ режим роботи. Він переписує історію, що не віщує нічого доброго, враховуючи, що ви вже опублікували цю історію. *Не* використовуйте цю опцію, якщо ви уважно не прочитали linkgit:git-rebase[1].

--no-rebase::
	Це скорочення від --rebase=false.

Параметри, пов'язані з вилученням
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

include::fetch-options.adoc[]

include::pull-fetch-param.adoc[]

include::urls-remotes.adoc[]

include::merge-strategies.adoc[]

ПОВЕДІНКА ЗА ЗАМОВЧАННЯМ
------------------------

Часто люди використовують `git pull` без надання жодних параметрів. Традиційно це було еквівалентно використанню `git pull origin`. Однак, коли конфігурація `branch.<name>.remote` присутня на гілці `<name>`, це значення використовується замість `origin`.

Щоб визначити, з якої URL-адреси отримувати дані, використовується значення конфігурації `remote.<origin>.url`, і якщо такої змінної немає, використовується значення з рядка `URL:` у `$GIT_DIR/remotes/<origin>`.

Щоб визначити, які віддалені гілки потрібно отримати (і, за бажанням, зберегти у гілках віддаленого відстеження), коли команда виконується без будь-яких параметрів refspec у командному рядку, перевіряються значення змінної конфігурації `remote.<origin>.fetch`, а якщо таких немає, перевіряється `$GIT_DIR/remotes/<origin>` та використовуються її рядки `Pull:`. На додаток до форматів refspec, описаних у розділі OPTIONS, ви можете мати глобальну refspec, яка виглядає так:

------------
refs/heads/*:refs/remotes/origin/*
------------

Глобальна специфікація посилань повинна мати непорожній правий зріз (тобто повинна зберігати дані, отримані у гілках віддаленого відстеження), а його лівий зріз та правий зріз повинні закінчуватися на `/*`. Вищезазначене вказує, що всі віддалені гілки відстежуються за допомогою гілок віддаленого відстеження в ієрархії `refs/remotes/origin/` під однаковою назвою.

Правило визначення віддаленої гілки для об'єднання після отримання даних дещо складне, щоб не порушувати зворотну сумісність.

Якщо в командному рядку `git pull` було задано явні специфікації посилань, усі вони об'єднуються.

Якщо в командному рядку не було вказано специфікацію посилання (refspec), тоді `git pull` використовує специфікацію посилання з конфігурації або `$GIT_DIR/remotes/<origin>`. У таких випадках застосовуються такі правила:

. Якщо конфігурація `branch.<name>.merge` для поточної гілки `<name>` існує, це назва гілки на віддаленому сайті, яка об'єднується.

. Якщо специфікація посилань є глобальною, нічого не об'єднується.

. В іншому випадку віддалена гілка першої специфікації посилань об'єднується.


ПРИКЛАДИ
--------

* Оновіть гілки віддаленого відстеження для репозиторію, з якого ви клонували, а потім об'єднайте одну з них з вашою поточною гілкою:
+
------------------------------------------------
$ git pull
$ git pull origin
------------------------------------------------
+
Зазвичай гілка, в яку здійснюється об'єднання, є HEAD віддаленого репозиторію, але вибір визначається опціями branch.<name>.remote та branch.<name>.merge; див. linkgit:git-config[1] для отримання детальної інформації.

* Об'єднати з поточною гілкою віддалену гілку `next`:
+
------------------------------------------------
$ git pull origin next
------------------------------------------------
+
Це тимчасово залишає копію `next` у FETCH_HEAD та оновлює гілку віддаленого відстеження `origin/next`. Те саме можна зробити, викликавши fetch та merge:
+
------------------------------------------------
$ git fetch origin
$ git merge origin/next
------------------------------------------------


Якщо ви спробували витягнути дані, що призвело до складних конфліктів, і хочете почати спочатку, ви можете відновити їх за допомогою 'git reset'.


include::transfer-data-leaks.adoc[]

ПОМИЛКИ
-------
Використання --recurse-submodules може отримувати нові коміти лише у вже отриманих підмодулях на даний момент. Наприклад, коли основний розробник додає новий підмодуль у щойно отримані коміти суперпроекту, сам підмодуль не може бути отриманий, що унеможливлює отримання цього підмодуля пізніше без необхідності повторного виконання отримання. Очікується, що це буде виправлено в майбутній версії Git.

ДИВ. ТАКОЖ
----------
linkgit:git-fetch[1], linkgit:git-merge[1], linkgit:git-config[1]

GIT
---
Частина набору linkgit:git[1]
