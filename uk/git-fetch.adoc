git-fetch(1)
============

НАЗВА
-----
git-fetch - Завантаження об'єктів та посилань з іншого репозиторію


СИНОПСИС
--------
[synopsis]
git fetch [<options>] [<repository> [<refspec>...]]
git fetch [<options>] <group>
git fetch --multiple [<options>] [(<repository>|<group>)...]
git fetch --all [<options>]


ОПИС
----
Отримувати гілки та/або теги (разом – «посилання») з одного або кількох інших репозиторіїв разом з об’єктами, необхідними для завершення їхньої історії. Гілки з віддаленим відстеженням оновлюються (див. опис _<refspec>_ нижче для способів керування цією поведінкою).

За замовчуванням будь-який тег, що вказує на історії, що витягуються, також витягується; ефект полягає в тому, щоб витягнути теги, які вказують на гілки, які вас цікавлять. Цю поведінку за замовчуванням можна змінити, використовуючи опції `--tags` або `--no-tags`, або налаштувавши `remote.<name>.tagOpt`. Використовуючи специфікацію посилань, яка явно витягує теги, ви також можете витягувати теги, які не вказують на гілки, які вас цікавлять.

`git fetch` може отримувати дані як з одного іменованого репозиторію чи URL-адреси, так і з кількох репозиторіїв одночасно, якщо вказано _<group>_ та є запис `remotes.<group>` у файлі конфігурації. (Див. linkgit:git-config[1]).

Якщо віддалений сервер не вказано, за замовчуванням використовуватиметься віддалений сервер `origin`, якщо для поточної гілки не налаштовано гілку upstream.

Імена вибраних посилань разом з іменами об'єктів, на які вони вказують, записуються до `.git/FETCH_HEAD`. Ця інформація може використовуватися скриптами або іншими командами git, такими як linkgit:git-pull[1].

ОПЦІЇ
-----
include::fetch-options.adoc[]

include::pull-fetch-param.adoc[]

`--stdin`::
	Зчитує специфікації посилань, по одній на рядок, зі stdin на додаток до тих, що надані як аргументи. Формат "tag _<назва>_" не підтримується.

include::urls-remotes.adoc[]

[[CRTB]]
НАЛАШТУВАНІ ВІДДІЛЕННЯ ДИСТАНЦІЙНОГО ВІДСТЕЖЕННЯ
------------------------------------------------

Ви часто взаємодієте з одним і тим самим віддаленим репозиторієм, регулярно та неодноразово витягуючи з нього дані. Щоб відстежувати прогрес такого віддаленого репозиторію, `git fetch` дозволяє налаштувати змінні конфігурації `remote.<repository>.fetch`.

Зазвичай така змінна може виглядати так:

------------------------------------------------
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*
------------------------------------------------

Ця конфігурація використовується двома способами:

* Коли `git fetch` виконується без вказівки, які гілки та/або теги отримувати в командному рядку, наприклад, `git fetch origin` або `git fetch`, значення `remote.<repository>.fetch` використовуються як специфікації посилань – вони вказують, які посилання отримувати та які локальні посилання оновлювати. У наведеному вище прикладі буде отримано всі гілки, що існують в `origin` (тобто будь-яке посилання, що відповідає лівій частині значення `refs/heads/*`), та оновлено відповідні гілки віддаленого відстеження в ієрархії `refs/remotes/origin/*`.

* Коли `git fetch` запускається з явними гілками та/або тегами для вибірки в командному рядку, наприклад, `git fetch origin master`, _<refspec>_, задані в командному рядку, визначають, що потрібно вибрати (наприклад, `master` у прикладі, що є скороченням від `master:`, що, у свою чергу, означає "отримати гілку `master`, але я не вказую явно, яку гілку віддаленого відстеження оновлювати нею з командного рядка"), і команда прикладу отримає _лише_ гілку `master`. Значення `remote.<repository>.fetch` визначають, яка гілка віддаленого відстеження, якщо така є, оновлюється. При такому використанні значення `remote.<repository>.fetch` не мають жодного впливу на визначення того, _що_ потрібно вибрати (тобто значення не використовуються як специфікації посилань, коли командний рядок перераховує специфікації посилань); вони використовуються лише для визначення _де_ зберігаються вибрані посилання, діючи як відображення.

Останнє використання значень `remote.<repository>.fetch` можна перевизначити, надавши параметр(и) `--refmap=<refspec>` у командному рядку.

Обрізка
-------

Git має типове налаштування для зберігання даних, якщо вони не видалені явно; це поширюється на зберігання локальних посилань на гілки на віддалених комп'ютерах, які самі видалили ці гілки.

Якщо залишити ці застарілі посилання накопичуватися, вони можуть погіршити продуктивність у великих та завантажених репозиторіях з великою кількістю змін у гілках, і, наприклад, зробити вивід команд типу `git branch -a --contains <commit>` непотрібно багатослівним, а також вплинути на все інше, що працюватиме з повним набором відомих посилань.

Ці посилання на дистанційне відстеження можна видалити одноразово одним із таких способів:

------------------------------------------------
# While fetching
$ git fetch --prune <name>

# Тільки чорнослив, не апортуй
$ git remote prune <name>
------------------------------------------------

Щоб скорочувати посилання як частину вашого звичайного робочого процесу, не пам'ятаючи про це, встановіть `fetch.prune` глобально або `remote.<назва>.prune` для кожного віддаленого компонента в конфігурації. Див. linkgit:git-config[1].

Ось тут-то все стає складнішим і більш специфічним. Функція обрізання насправді не звертає уваги на гілки, натомість вона обрізатиме локальні <--> віддалені посилання як функцію специфікації віддаленого об'єкта (див. `<refspec>` та <<CRTB,CONFIGURED REMOTE-TRACKING BRANCHES>> вище).

Тому, якщо специфікація посилань для віддаленого комп'ютера містить, наприклад, `refs/tags/*:refs/tags/*`, або ви вручну виконуєте, наприклад, `git fetch --prune <назва> "refs/tags/*:refs/tags/*"`, то видалятимуться не застарілі гілки відстеження віддаленого комп'ютера, а будь-який локальний тег, якого не існує на віддаленому комп'ютері.

Це може бути не те, чого ви очікуєте, тобто ви хочете обрізати віддалений _<name>_, але також явно отримувати з нього теги, тому під час отримання з нього ви видаляєте всі свої локальні теги, більшість з яких могли взагалі не надходити з віддаленого _<name>_.

Тож будьте обережні, використовуючи це зі специфікацією посилань, такою як `refs/tags/*:refs/tags/*`, або будь-якою іншою специфікацією посилань, яка може відображати посилання з кількох віддалених серверів на один локальний простір імен.

Оскільки оновлення як гілок, так і тегів на віддаленому сервері є поширеним випадком використання, опцію `--prune-tags` можна використовувати разом з `--prune` для видалення локальних тегів, яких немає на віддаленому сервері, та примусового оновлення тих тегів, які відрізняються. Обрізання тегів також можна ввімкнути за допомогою `fetch.pruneTags` або `remote.<name>.pruneTags` у конфігурації. Див. linkgit:git-config[1].

Опція `--prune-tags` еквівалентна оголошенню `refs/tags/*:refs/tags/*` у специфікаціях refs віддаленого сервера. Це може призвести до деяких, здавалося б, дивних взаємодій:

------------------------------------------------
# Ці обидва теги вилучення
$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'
$ git fetch --no-tags --prune-tags origin
------------------------------------------------

Причина, чому не виникає помилка, якщо параметр надано без `--prune` або його версій конфігурації, полягає в гнучкості налаштованих версій та підтримці відповідності 1=1 між тим, що роблять прапорці командного рядка, і тим, що роблять версії конфігурації.

Наприклад, доцільно налаштувати `fetch.pruneTags=true` у `~/.gitconfig`, щоб теги видалялися щоразу під час виконання `git fetch --prune`, без того, щоб кожен виклик `git fetch` без `--prune` викликав помилку.

Обрізання тегів за допомогою `--prune-tags` також працює під час отримання URL-адреси замість іменованого віддаленого об'єкта. Це призведе до обрізання всіх тегів, які не знайдено на оригіналі:

------------------------------------------------
$ git fetch origin --prune --prune-tags
$ git fetch origin --prune 'refs/tags/*:refs/tags/*'
$ git fetch <url-of-origin> --prune --prune-tags
$ git fetch <url-of-origin> --prune 'refs/tags/*:refs/tags/*'
------------------------------------------------

ВИХІД
-----

Вивід команди "git fetch" залежить від використаного методу транспортування; у цьому розділі описано вивід під час отримання даних через протокол Git (локально або через ssh) та протокол Smart HTTP.

Стан вибірки виводиться у табличній формі, де кожен рядок представляє стан окремого посилання. Кожен рядок має такий вигляд:

-------------------------------
 <flag> <summary> <from> -> <to> [<reason>]
-------------------------------

При використанні `--porcelain`, формат виводу призначений для машинного аналізу. На відміну від форматів виводу, зрозумілих для людини, він виводиться у стандартний вивід замість стандартного виводу помилок. Кожен рядок має такий вигляд:

-------------------------------
<flag> <old-object-id> <new-object-id> <local-reference>
-------------------------------

Статус актуальних посилань відображається лише за наявності опції `--verbose`.

У компактному режимі виводу, заданому за допомогою змінної конфігурації fetch.output, якщо в іншому рядку знайдено цілий рядок _<from>_ або _<to>_, він буде замінений на `*` в іншому рядку. Наприклад, `master -> origin/master` стає `master -> origin/*`.

прапор::
	Один символ, що вказує на статус посилання:
(простір);; для успішно отриманого швидкого перемотування вперед;
`+`;; для успішного примусового оновлення;
`-`;; для успішно обрізаного посилання;
`t`;; для успішного оновлення тегу;
`*`;; для успішно отриманого нового посилання;
`!`;; для посилання, яке було відхилено або не вдалося оновити; та
`=`;; для актуального посилання, яке не потребувало отримання.

короткий зміст::
	Для успішно отриманого посилання, зведення показує старі та нові значення посилання у формі, придатній для використання як аргумент `git log` (у більшості випадків це `<old>..<new>`, а `<old>...<new>` для примусових оновлень без перемотування вперед).

з::
	Ім'я віддаленого посилання, з якого вибирається посилання, мінус його префікс `refs/<тип>/`. У разі видалення ім'я віддаленого посилання — "(none)".

до::
	Назва локального посилання, що оновлюється, мінус його префікс `refs/<тип>/`.

причина::
	Пояснення, зрозуміле для людини. У випадку успішно отриманих посилань пояснення не потрібні. Для невдалого посилання описується причина невдачі.

ПРИКЛАДИ
--------

* Оновіть гілки віддаленого відстеження:
+
------------------------------------------------
$ git fetch origin
------------------------------------------------
+
Вищевказана команда копіює всі гілки з віддаленого простору імен `refs/heads/` та зберігає їх у локальному просторі імен `refs/remotes/origin/`, якщо тільки для визначення специфікації посилань, яка не є стандартною, не використовується параметр `remote.<repository>.fetch`.

* Явне використання refspecs:
+
------------------------------------------------
$ git fetch origin +seen:seen maint:tmp
------------------------------------------------
+
Це оновлює (або створює, за необхідності) гілки `seen` та `tmp` у локальному репозиторії шляхом отримання з гілок (відповідно) `seen` та `maint` з віддаленого репозиторію.
+
Гілка `seen` буде оновлена, навіть якщо вона не перемотується вперед, оскільки перед нею стоїть знак плюс; гілка `tmp` цього не робитиме.

* Перегляньте гілку віддаленого сервера, не налаштовуючи його у вашому локальному репозиторії:
+
------------------------------------------------
$ git fetch git://git.kernel.org/pub/scm/git/git.git maint
$ git log FETCH_HEAD
------------------------------------------------
+
Перша команда отримує гілку `maint` з репозиторію за адресою `git://git.kernel.org/pub/scm/git/git.git`, а друга команда використовує `FETCH_HEAD` для перевірки гілки за допомогою linkgit:git-log[1]. Отримані об'єкти зрештою будуть видалені вбудованою функцією обробки git (див. linkgit:git-gc[1]).

include::transfer-data-leaks.adoc[]

КОНФІГУРАЦІЯ
------------

include::includes/cmd-config-section-all.adoc[]

include::config/fetch.adoc[]

ПОМИЛКИ
-------
Використання `--recurse-submodules` може отримувати нові коміти лише в тих підмодулях, які присутні локально, наприклад, у `$GIT_DIR/modules/`. Якщо основний розробник додає новий підмодуль, цей підмодуль не може бути отриманий, доки його не буде клоновано, наприклад, за допомогою `git submodule update`. Очікується, що це буде виправлено в майбутній версії Git.

ДИВ. ТАКОЖ
----------
linkgit:git-pull[1]

GIT
---
Частина набору linkgit:git[1]
