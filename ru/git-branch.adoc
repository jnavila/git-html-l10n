git-branch(1)
=============

НАЗВАНИЕ
--------
git-branch - Вывод списка, создание или удаление веток

ОБЗОР
-----
[verse]
'git branch' [--color[=<когда>] | --no-color] [--show-current]
	[-v [--abbrev=<n> | --no-abbrev]]
	[--column[=<параметры>] | --no-column] [--sort=<ключ>]
	[--merged [<коммит>]] [--no-merged [<коммит>]]
	[--contains [<коммит>]] [--no-contains [<коммит>]]
	[--points-at <объект>] [--format=<формат>]
	[(-r | --remotes) | (-a | --all)]
	[--list] [<шаблон>...]
'git branch' [--track[=(direct|inherit)] | --no-track] [-f]
	[--recurse-submodules] <имя-ветки> [<начальная-точка>]
'git branch' (--set-upstream-to=<вышестоящая-ветка> | -u <вышестоящая-ветка>)
	[<имя-ветки>]
'git branch' --unset-upstream [<имя-ветки>]
'git branch' (-m | -M) [<старая-ветка>] <новая-ветка>
'git branch' (-c | -C) [<старая-ветка>] <новая-ветка>
'git branch' (-d | -D) [-r] <имя-ветки>...
'git branch' --edit-description [<имя-ветки>]

ОПИСАНИЕ
--------

Если передан параметр `--list` или нет аргументов, не являющихся параметрами, будет выведен список существующих веток; текущая ветка будет выделена зелёным цветом и помечена звёздочкой. Все ветки, извлечённые в связанных рабочих копиях, будут выделены голубым и помечены знаком плюс. Если задан параметр `-r`, то будут выведены отслеживаемые внешние ветки, а при указании `-a` будут выведены как локальные, так и внешние ветки.

Если задан `<шаблон>`, то будут выведены только те ветки, которые соответствуют данному glob-шаблону оболочки. Если задано несколько шаблонов, ветка будет выведена, если она соответствует любому из них.

Обратите внимание, что при указании `<шаблона>` необходимо использовать `--list`; в противном случае команда может быть интерпретирована как создание ветки.

С параметром `--contains`, отображаются только те ветки, которые содержат указанный коммит (иначе говоря, ветки, верхушки которых являются потомками указанного коммита); `--no-contains` делает обратное. При использовании `--merged` будут перечислены только ветки, слитые в указанный коммит (т.е. ветки, верхушки которых достижимы из указанного коммита). С параметром `--no-merged`, наоборот, будут перечислены только те ветки, которые не были слиты в указанный коммит. Если аргумент `<коммит>` отсутствует, то по умолчанию используется `HEAD` (т.е. верхушка текущей ветки).

В своей второй форме команда создаёт новую ветку с именем `<имя-ветки>`, которая указывает на текущий `HEAD` или на `<начальную-точку>`, если она задана. В качестве особого синтаксиса для `<начальной-точки>` вы можете использовать `"А...Б"`, что будет означать «базовый коммит для слияния `А` и `Б`» (подразумевая, что таковой существует ровно один). Вы также можете опустить указание одной из ревизий `А` либо `Б`, тогда вместо неё будет использоваться `HEAD`.

Обратите внимание, что это создаст новую ветку, но не переключит рабочую копию на неё; используйте "git switch <новая-ветка>", чтобы переключиться на новую ветку.

Когда локальная ветка создаётся на основе отслеживаемой вешней ветки, Git настраивает эту ветку (в частности, переменные конфигурации `branch.<имя>.remote` и `branch.<имя>.merge`) так, чтобы команда `git pull` могла корректно сливать изменения из этой отслеживаемой внешней ветки. Это поведение можно изменить с помощью глобального флага конфигурации `branch.autoSetupMerge`. Значение этого флога можно переопределять, используя параметры `--track` и `--no-track`. Изменить настроенную таким образом отслеживаемую вешнюю ветку можно позже с помощью команды `git branch --set-upstream-to`.

С параметрами `-m` или `-M` ветка `<старая-ветка>` будет переименована в `<новая-ветка>`. Если у `<старой-ветки>` был соответствующий журнал ссылок, он также переименовывается, чтобы соответствовать `<новой-ветке>`, а в сам журнал ссылок добавляется запись о переименовании ветки. Если `<новая-ветка>` уже существует, необходимо использовать `-M`, чтобы принудительно выполнить переименование.

Параметры `-c` и `-C` имеют точно такую же семантику, что и `-m` и `-M`, за исключением того, что вместо переименования ветки она будет скопирована с новым именем, вместе с её конфигурацией и журналом ссылок.

С помощью параметров `-d` или `-D` ветку `<имя-ветки>` можно удалить. Вы можете указать более одной ветки для удаления. Если у ветки в данный момент есть журнал ссылок, то этот журнал также будет удалён.

Используйте `-r` вместе с `-d`, чтобы удалить отслеживаемые внешние ветки. Обратите внимание, что их имеет смысл удалять только в том случае, если они уже были удалены во внешним репозитории или если команда `git fetch` была настроена так, чтобы не извлекать их снова. См. также подкоманду `prune` из linkgit:git-remote[1] для того, чтобы подчистить все устаревшие отслеживаемые внешние ветки.


ПАРАМЕТРЫ
---------
-d::
--delete::
	Удалить ветку. Ветка должна быть полностью слита в её вышестоящую ветку или в `HEAD`, если ни какая ветка не была назначена вышестоящей с помощью `--track` или `--set-upstream-to`.

-D::
	Краткая версия для `--delete --force`.

--create-reflog::
	Создать журнал ссылок для ветки. Это активирует запись всех изменений, внесённых в ссылку на это ветку, что позволяет использовать выражения sha1 на основе даты, такие как «<имя ветки>@\{yesterday}». Обратите внимание, что в не-голых репозиториях журналы ссылок обычно создаются по умолчанию (если флаг конфигурации `core.logAllRefUpdates` установлен). Отрицательная форма `--no-create-reflog` просто отменяет ранее установленный параметр `--create-reflog`, но в настоящее время не переопределяет значение `core.logAllRefUpdates`.

-f::
--force::
	Без других параметров позволяет сбросить ветку с именем <имя-ветки> на <начальную-точку>, даже если ветка с таким именем уже существует. Без `-f` команда `git branch` откажется создавать уже существующую ветку. В сочетании с `-d` (или `--delete`) позволяет удалить ветку независимо от того, была ли она объединена или даже если она указывает на недействительный коммит. В сочетании с `-m` (или `--move`) позволяет переименовать ветку, даже если ветка с таким новым именем уже существует; то же самое относится и к `-c` (или `--copy`).
+
Обратите внимание, что `git branch -f <имя-ветки> [<начальная-точка>]`, даже с `-f`, откажется изменять существующую ветку c именем `<имя-ветки>`, которая извлечена в другой рабочей копии, связанной с тем же репозиторием.

-m::
--move::
	Переместить/переименовать ветку вместе с её конфигурацией и журналом ссылок.

-M::
	Краткая версия для `--move --force`.

-c::
--copy::
	Скопировать ветку вместе с её конфигурацией и журналом ссылок.

-C::
	Краткая версия для `--copy --force`.

--color[=<когда>]::
	Раскрашивать вывод для выделения текущей, локальных и отслеживаемых внешних веток. Значением должно быть одно из: `always` (по умолчанию), `never` или `auto`.

--no-color::
	Отключить выделение веток цветом, даже если в файле конфигурации задано использовать вывод с цветом по умолчанию. То же самое, что и `--color=never`.

-i::
--ignore-case::
	Сортировка и фильтрация веток не учитывают регистр.

--omit-empty::
	Если после форматирования ссылки, согласно формату она расширяется до пустой строки, не выводить символ перехода на новую строку.

--column[=<параметры>]::
--no-column::
	Отображать список веток по столбцам. См. синтаксис <параметров> в описании переменной конфигурации `column.branch`. Передача `--column` (без <параметров>) и `--no-column` эквивалентны 'always' и 'never' соответственно.
+
Этот параметр не применим в подробном режиме.

-r::
--remotes::
	Показать список или удалить (если используется совместно с -d) отслеживаемые внешние ветки. Совместное использование с `--list` позволяет отфильтровать их по шаблону(ам).

-a::
--all::
	Показать список, включающий как отслеживаемые внешние ветки, так и локальные. Совместное использование с `--list` позволяет отфильтровать их по шаблону(ам).

-l::
--list::
	Вывести список веток. Возможно, ограничиваясь только теми, что соответствуют `<шаблонам>...`, например, `git branch --list 'maint-*'`, выведет список только тех веток, которые соответствуют этому шаблону.

--show-current::
	Вывести имя текущей ветки. В состоянии отсоединённого указателя HEAD не выводится ничего.

-v::
-vv::
--verbose::
	В режиме вывода списка показывать sha1 и строку заголовка последнего коммита для каждой ветки, а также состояние относительно вышестоящей ветки (если такая имеется). Если параметр указан дважды, вывести также путь связанного рабочего каталога (если есть) и имя вышестоящей ветки (см. также `git remote show <внешний-репозиторий>`). Обратите внимание, что путь к ветке, на которую ссылается HEAD текущей рабочей копии, не будет выведен (это будет просто путь к вашему текущему каталогу).

-q::
--quiet::
	Вести себя тише при создании или удалении ветки, подавляя сообщения, не относящиеся к ошибкам.

--abbrev=<n>::
	При выводе списка в подробном режиме, когда в вывод добавляется имя объекта-коммита, отображать сокращённый минимальный префикс хеша коммита, который всё ещё уникально идентифицирует этот объект, и длиной не менее '<n>' шестнадцатеричных цифр. Значение по умолчанию — 7 и может быть переопределено в переменной конфигурации `core.abbrev`.

--no-abbrev::
	Отображать полные sha1 в выходном списке вместо их сокращения.

-t::
--track[=(direct|inherit)]::
	При создании новой ветки установить параметры конфигурации `branch.<имя>.remote` и `branch.<имя>.merge`, чтобы настроить для неё отслеживание вышестоящей (или «upstream») ветки. Эта конфигурация скажет Git, что нужно показывать относительное состояние между этими ветками при выполнении `git status` и `git branch -v`. Кроме того, это указывает, чтобы когда вновь созданная ветка будет текущей, `git pull` (без аргументов), извлекал в неё изменения из вышестоящей.
+
Какая именно ветка будет вышестоящей зависит от необязательного аргумента: `-t`, `--track` или `--track=direct` означает использовать саму ветку, которая была задана как начальная точка, в качестве вышестоящей; `--track=inherit` означает скопировать настройки вышестоящей ветки из ветки, которая задана как начальная точка.
+
Переменная конфигурации `branch.autoSetupMerge` определяет, как должны вести себя команды `git switch`, `git checkout` и `git branch`, когда ни `--track`, ни `--no-track` не указаны:
+
Значением по умолчанию, `true`, означает вести себя так же, как будто был задан параметр `--track=direct`, когда начальная точка является отслеживаемой внешней веткой. `false` — как будто был задан `--no-track`. `always` — `--track=direct`. `inherit` — `--track=inherit`. `simple` — вести себя так, как будто параметр `--track=direct` задан только тогда, когда начальная точка является отслеживаемой внешней веткой и новая ветка имеет то же имя, что и внешняя.
+
См. linkgit:git-pull[1] и linkgit:git-config[1] для дополнительной информации о том, как используются переменные конфигурации `branch.<name>.remote` и `branch.<name>.merge`.

--no-track::
	Не настраивать конфигурацию вышестоящей ветки, даже если переменная конфигурации `branch.autoSetupMerge` того требует.

--recurse-submodules::
	ЭТА ОПЦИЯ ЯВЛЯЕТСЯ ЭКСПЕРИМЕНТАЛЬНОЙ! Выполнять текущую команду также и в подмодулях (рекурсивно), если это включено в переменной конфигурации `submodule.propagateBranches`. См. описание `submodule.propagateBranches` в linkgit:git-config[1]. В настоящее время поддерживается только создание веток.
+
При использовании во время создания ветки, новая ветка с именем <имя-ветки> будет создана как в основном проекте, так и во всех его подмодулях, которые есть в <начальной-точке> основного проекта. В подмодулях эта ветка будет указывать на тот коммит, который использовался в <начальной-точке> основного проекта, но информация об отслеживании этих веток будет настроена на основе внешних и локальных веток подмодулей. Например, команда `git branch --recurse-submodules topic origin/main` создаст в каждом подмодуле ветку «topic», которая указывает на коммит подмодуля, используемый в «origin/main» основного проекта, но которая отслеживает внешнюю ветку «origin/main» самого подмодуля.

--set-upstream::
	Поскольку у данного параметра был синтаксис, сбивающий с толку, он больше не поддерживается. Пожалуйста, используйте вместо этого `--track` или `--set-upstream-to`.

-u <вышестоящая-ветка>::
--set-upstream-to=<вышестоящая-ветка>::
	Изменить информацию об отслеживании ветки с именем <имя-ветки> так, чтобы она отслеживала <вышестоящую-ветку>. Если <имя-ветки> не указано, то по умолчанию изменения применяются к текущей ветке.

--unset-upstream::
	Удалить информацию о вышестоящей ветке из ветки с именем <имя-ветки>. Если ветка не указана, то по умолчанию изменения применяются к текущей ветке.

--edit-description::
	Открыть редактор и отредактировать текст, объясняющий назначение ветки, который будет использоваться другими различными командами (как например, `format-patch`, `request-pull` и `merge`, если включено). Этот текст может быть многострочным.

--contains [<коммит>]::
	Вывести список только тех веток, которые содержат указанный коммит (HEAD, если не указан). Подразумевает `--list`.

--no-contains [<коммит>]::
	Вывести список только тех веток, которые не содержат указанного коммита (HEAD, если не указан). Подразумевает `--list`.

--merged [<коммит>]::
	Вывести список только тех веток, чьи верхушки достижимы из указанного коммита (HEAD, если не указан). Подразумевает `--list`.

--no-merged [<коммит>]::
	Вывести список только тех веток, чьи верхушки не достижимы из указанного коммита (HEAD, если не указан). Подразумевает `--list`.

<имя-ветки>::
	Имя ветки для создания или удаления. Новое имя ветки должно проходить все проверки, определённые в linkgit:git-check-ref-format[1]. Некоторые из этих проверок могут ограничивать, какие символы, разрешены в именах веток.

<начальная-точка>::
	Верхушка новой ветки будет указывать на этот коммит. В качестве начальной точки могут быть заданы имя другой ветки, идентификатор коммита или метка. Если этот параметр опущен, будет использован текущий HEAD.

<старая-ветка>::
	Имя какой-либо существующей ветки. Если этот параметр опущен, будет использовано имя текущей ветки.

<новая-ветка>::
	Новое имя для существующей ветки. К нему применяются те же ограничения, что и к <имени-ветки>.

--sort=<ключ>::
	Сортировать по заданному ключу. Добавьте префикс `-`, чтобы отсортировать в порядке убывания значения. Вы можете использовать параметр `--sort=<ключ>` несколько раз, в таком случае последний ключ становится основным. Поддерживаются те же ключи, что и в `git for-each-ref`. Порядок сортировки по умолчанию соответствует значению переменной конфигурации `branch.sort`, если она задана, или сортировке по полному имени ссылки (включая префикс `refs/...`). Это означает, что сначала в списке будут идти отсоединённый указатель HEAD (если есть), затем локальные ветки и наконец отслеживаемые внешние ветки. См. linkgit:git-config[1].


--points-at <объект>::
	Перечислить только ветки данного объекта.

--format <формат>::
	Строка, которая описывает значение `%(fieldname)` на основе отображаемой ссылки на ветку и объекта, на который она указывает. Формат такой же, как и в linkgit:git-for-each-ref[1].

КОНФИГУРАЦИЯ
------------
`pager.branch` учитывается только при перечислении веток, т.е. когда используется или подразумевается `--list`. По умолчанию используется постраничный вывод. См. linkgit:git-config[1].

include::includes/cmd-config-section-rest.adoc[]

include::config/branch.adoc[]

ПРИМЕРЫ
-------

Начать разработку с известной метки::
+
------------
$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6
$ cd my2.6
$ git branch my2.6.14 v2.6.14   <1>
$ git switch my2.6.14
------------
+
<1> Этот шаг и следующий можно объединить в один: "checkout -b my2.6.14 v2.6.14".

Удалить ненужную ветку::
+
------------
$ git clone git://git.kernel.org/.../git.git my.git
$ cd my.git
$ git branch -d -r origin/todo origin/html origin/man   <1>
$ git branch -D test                                    <2>
------------
+
<1> Удалить отслеживаемые внешние ветки "todo", "html" и "man". Следующий 'fetch' или 'pull' снова создаст их, если вы не измените это в конфигурации. См. linkgit:git-fetch[1].
<2> Удалить ветку "test", даже если ветка "master" (или другая ветка, которая в данный момент активна) не содержит всех коммитов из ветки "test".

Вывод списка веток из конкретного внешнего репозитория::
+
------------
$ git branch -r -l '<внешний-репозиторий>/<шаблон>'                 <1>
$ git for-each-ref 'refs/remotes/<внешний-репозиторий>/<шаблон>'    <2>
------------
+
<1> Использование `-a` могло бы привести к тому, что вместе с внешними отслеживаемыми ветками из <внешнего-репозитория> вывелись бы также и локальные ветки, имена которых начинаются с префикса, совпадающего с именем <внешним-репозиторием>.
<2> `for-each-ref` может принимать разнообразный набор параметров. См. linkgit:git-for-each-ref[1]

Шаблоны обычно требуется заключать в кавычки.

ЗАМЕТКИ
-------

Если вы создаёте ветку и хотите немедленно на неё переключиться, проще использовать команду "git switch" с параметром `-c`, чтобы сделать то же самое одной командой.

У параметров `--contains`, `--no-contains`, `--merged` и `--no-merged` четыре разных, хотя и связанных назначения:

- `--contains <коммит>` используется для поиска всех веток, которым потребуется особое внимание, если этот <коммит> будет перемещён на другую основу (`rebase`) или изменён (`amend`), ибо эти ветки включают в себя указанный <коммит>.

- `--no-contains <коммит>` является обратным к предыдущему параметре, т.е. перечисляет ветки, которые не содержат указанный <коммит>.

- `--merged` используется для поиска всех веток, которые можно безопасно удалить, поскольку эти ветки полностью включены в HEAD.

- `--no-merged` используется для поиска веток, которые являются кандидатами для слияния с HEAD, поскольку эти ветки могут содержать некоторые изменения отсутствующие в HEAD.

include::ref-reachability-filters.adoc[]

СМОТРИТЕ ТАКЖЕ
--------------
linkgit:git-check-ref-format[1], linkgit:git-fetch[1], linkgit:git-remote[1], глава link:user-manual.html#what-is-a-branch[Understanding history: What is a branch?»] («Понимание истории: Что такое ветка?») в пользовательское руководство Git.

GIT
---
Является частью пакета linkgit:git[1]
