合并战略
----

合并机制（`git merge`和`git pull`命令）允许用`s`选项来选择后端'合并策略'。 一些策略也可以采取自己的选项，可以通过给`git merge`和/或`git pull`的`-X<选项>`参数来传递。

ort::
	这是拉取或合并一个分支时的默认合并策略。 这个策略只能使用三方合并算法解决两个头。 当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并将其作为三方合并的参考树。 据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。 此外，这个策略可以检测并处理涉及重命名的合并。 它并不使用检测到的副本。 这个算法的名字是一个缩写（"Ostensibly Recursive's Twin"），来自于它是作为以前的默认算法`recursive`的替代而编写的。
+
'ort' 策略可以采取以下选项：

ours;;
	这个选项通过倾向于 "我们" 的版本，迫使冲突的猎物被自动解决。 另一棵目录树上与我们这边不冲突的变化会反映在合并结果中。 对于一个二进制文件，整个内容都来自我们这边。
+
这不应该与 "我们的" 合并策略相混淆，后者甚至根本不看另一棵目录树包含了什么。 它抛弃了其他树所做的一切，宣布 "我们的" 历史包含了其中所发生的一切。

theirs;;
	这与 "我们的" 相反；注意，与 "我们的" 不同，没有 "他们的" 合并策略来混淆这个合并选项。

ignore-space-change;;
ignore-all-space;;
ignore-space-at-eol;;
ignore-cr-at-eol;;
	为了进行三方合并，将具有指定类型的空白变化的行视为没有变化。 但混合了其他改动的行的空白改动不会被忽略。 参见linkgit:git-diff[1] `-b`, `-w`, `-ignore-space-at-eol`, 和 `-ignore-cr-at-eol`。
+
* 如果 "他们的" 版本只在一行中引入了空白的变化，则使用 "我们的" 版本；
* 如果 "我们的" 版本引入了空白的变化，但 "他们的" 版本包括一个实质性的变化，则使用 "他们的" 版本;
* 否则，合并将以常规方式进行。

renormalize;;
	在解决三方合并时，这将对一个文件的所有三个阶段运行虚拟检出和检入。 这个选项是为了在合并具有不同清洁过滤器或行末规范化规则的分支时使用。 详情见 linkgit:gitattributes[5] 中的 "合并具有不同检入/检出属性的分支"。

no-renormalize;;
	禁用 `renormalize` 选项。 这覆盖了 `merge.renormalize` 配置变量。

find-renames[=<n>];;
	开启重名检测，可选择设置相似度阈值。 这是默认的。这覆盖了 'merge.renames' 配置变量。 参见linkgit:git-diff[1] `--find-renames`。

rename-threshold=<n>;;
	废弃的，`find-renames=<n>` 的同义词。

subtree[=<路径>];;
	这个选项是 '子树' 策略的更高级形式，该策略对两棵树在合并时必须如何移位以相互匹配进行猜测。 相反，指定的路径是前缀（或从开始剥离），以使两棵树的形状相匹配。

recursive::
	这只能用三方合并算法解决两个头。 当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并使用它作为三方合并的参考树。 据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。 此外，它可以检测并处理涉及重命名的合并。 它并不使用检测到的副本。 从Git v0.99.9k到v2.33.0，这是解决双头的默认策略。
+
'recursive' 策略采用与 'ort' 相同的选项。 然而，有三个 'ort' 忽略的额外选项（上面没有记录），对 'recursive' 策略有潜在的作用：

patience;;
	废弃的，`diff-algorithm=patience` 的同义词。

diff-algorithm=[patience|minimal|histogram|myers];;
	在合并时使用不同的差异算法，这可以帮助避免由于不重要的匹配行（比如不同函数的大括号）而发生的错误合并。 参见linkgit:git-diff[1] `--diff-algorithm`。 注意，`ort` 特定 `diff-algorithm=histogram`，而`recursive`默认为`diff.algorithm`配置设置。

no-renames;;
	关闭重名检测。这覆盖了 `merge.renames` 的配置变量。 参见linkgit:git-diff[1] `--no-renames`。

resolve::
	这只能用三方合并算法解决两个头（即当前分支和你拉来的另一个分支）。 它试图仔细检测纵横交错的合并歧义。 它不处理重名。

octopus::
	这可以解决有两个以上头的情况，但拒绝做复杂的合并，需要手动解决。 它主要是用于将主题分支头捆绑在一起。 当拉动或合并一个以上的分支时，这是默认的合并策略。

ours::
	这可以解决任何数量的头，但合并的结果总是当前分支头的树，有效地忽略了所有其他分支的变化。 它是用来取代侧边分支的旧开发历史的。 注意，这与 'recursive' 合并策略的-Xours选项不同。

subtree::
	这是一个修正的 `ort` 策略。当合并树A和B时，如果B对应于A的子树，B首先被调整为与A的树结构相匹配，而不是在同一级别读取树。这种调整也是针对共同祖先树进行的。

对于使用三方合并的策略（包括默认的 'ort' 策略），如果在两个分支上都做了修改，但后来在其中一个分支上被撤销，那么这个修改就会出现在合并后的结果中；有些人觉得这种行为令人困惑。 出现这种情况是因为在执行合并时只考虑头部和合并基数，而不是单个提交。 因此，合并算法认为被恢复的修改根本就没有变化，而是用被修改的版本来代替。
