规定修订
----

修订参数 '<rev>' 通常（但不一定）命名一个提交对象。 它使用所谓的 ‘扩展 SHA-1’ 语法。 这里有多种对象名称的拼写方式。 本列表末尾列出的对象名称用于命名提交中包含的树和二进制对象。

NOTE: 本文档显示的是 git 所看到的 “原始” 语法。shell 和其他用户界面可能需要额外的引号来保护特殊字符和避免分词。

'<sha1>', e.g. 'dae86e1950b1277e545cee180551750029cfe735', 'dae86e'::
  完整的 SHA-1 对象名称（40 字节十六进制字符串），或在仓库中唯一的前导子串。 例如，如果仓库中没有其他对象名称以 dae86e 开头的对象，则 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都是同一个提交对象的名称。

'<describeOutput（描述输出）>'，例如 'v1.7.4.2-679-g3bee7fb'::
  来自 `git describe` 的输出；即一个最接近的标记，后面可选择一个破折号和提交次数，再后面是一个破折号、一个 'g' 和一个缩写的对象名称。

'<引用名>'， 例如 'master', 'heads/master', 'refs/heads/master'::
  符号引用名称。 例如，'master' 通常指 'refs/heads/master' 引用的提交对象。 如果你同时拥有 'heads/master' 和 'tags/master' ，你可以明确地说 'heads/master' 来告诉 Git 你指的是哪一个。 当 '<引用名>' 有歧义时，会根据以下规则取第一个匹配项来消除歧义：
+
  . 如果'$GIT_DIR/<引用名>' 存在，这就是你的意思（这通常只对 `HEAD`、`FETCH_HEAD`、`ORIG_HEAD`、`MERGE_HEAD`、`REBASE_HEAD`、`REVERT_HEAD`、`CHERRY_PICK_HEAD`、`BISECT_HEAD` 和 `AUTO_MERGE` 有用）;

  . 否则，如果存在，则使用 'refs/<引用名>';

  . 否则，如果存在 'refs/tags/<引用名>'，则使用 'refs/tags/<引用名>';

  . 否则，如果存在 'refs/heads/<引用名>'，则使用 'refs/heads/<引用名>';

  . 否则，如果存在 'refs/remotes/<引用名>'，则使用 'refs/remotes/<引用名>';

  . 否则，如果存在 'refs/remotes/<引用名>/HEAD'，则使用 'refs/remotes/<引用名>/HEAD'。

+
  `HEAD`:::
    命名工作区中的更改所基于的提交。
  `FETCH_HEAD`:::
    记录您上次调用 `git fetch` 时
    从远程仓库获取的分支。
  `ORIG_HEAD`:::
    命令（`git am`、`git merge`、`git rebase`、`git reset`）时创建的，
    用于记录这些命令执行前`HEAD`的位置，
    以便于将分支的顶端
    改回执行这些命令前的状态。
  `MERGE_HEAD`:::
    记录您在运行 `git merge` 时
    要合并到分支中的提交。
  `REBASE_HEAD`:::
    会记录当前停止操作的提交，
    原因可能是冲突或
    交互式变基中的 `edit` 命令。
  `REVERT_HEAD`:::
    记录您在运行 `git revert` 时要还原的提交。
  `CHERRY_PICK_HEAD`:::
    会记录您在运行 `git cherry-pick` 时
    要 cherry-pick 的提交。
  `BISECT_HEAD`:::
    记录运行 `git bisect --no-checkout` 时
    要测试的当前提交。
  `AUTO_MERGE`:::
    当合并操作导致冲突时，
    记录与 'ort' 合并策略写入工作树的状态
    相对应的树对象。

+
请注意，上述任何 'refs/*' 都可能来自 `$GIT_DIR/refs` 目录或 `$GIT_DIR/packed-refs` 文件。 虽然引用名称编码未指定，但 UTF-8 是首选，因为某些输出处理可能会假定引用名称为 UTF-8 编码。

'@'::
  '@' 本身就是 `HEAD` 的快捷方式。

'[<引用名>]@{<日期>}', 例如： 'master@\{yesterday\}', 'HEAD@{5 minutes ago}'::
  在后缀为'@' 的引用后，用一对括号括起来的日期说明（例如 '\{yesterday/}'、'{1 个月 2 周 3 天 1 小时 1 秒前}' 或 '{1979-02-26 18:30:00}'）指定了引用在之前某个时间点的值。 该后缀只能紧跟在引用名称之后使用，且引用必须有现存日志（'$GIT_DIR/logs/<ref>'）。需要注意的是，这个后缀查找的是*本地*引用在给定时间内的状态；例如，上周本地 'master' 分支中的情况。如果要查看特定时间内的提交，请参阅 `--since` 和 `--until`。

'<引用名>@{<n>}', e.g. 'master@\{1\}'::
  在后缀为 '@' 的引用后，用一对括号（如 '\{1\}'、'\{15\}'）括起来的序号说明指定了该引用的 n 次先验值。 例如，'master@\{1\}' 是 'master' 的直接先验值，而 'master@\{5\}' 是 'master' 的第 5 个先验值。该后缀只能紧跟在引用名称之后使用，并且引用必须有现存日志（'$GIT_DIR/logs/<引用名>'）。

'@{<n>}', e.g. '@\{1\}'::
  你可以使用带有空引用部分的"@"结构来获取当前分支的引用日志条目。例如，如果你在分支 'blabla' 上，那么 '@\{1\}' 与 'blabla@\{1\}' 的意思相同。

'@{-<n>}', e.g. '@{-1}'::
  结构体 '@{-<n>}' 表示在当前分支/提交之前签出的第 <n> 个分支/提交。

'[<分支名>]@\{upstream\}', e.g. 'master@\{upstream\}', '@\{u\}'::
  分支 B 可以设置为在远程 R 的分支 X（使用 `branch.<名称>.merge` 配置）（使用 `branch.<名称>.remote`配置）之上构建。B@{u} 指的是远程 R 分支 X 的远程跟踪分支，通常位于 `refs/remotes/R/X`。

'[<分支名>]@\{push\}', e.g. 'master@\{push\}', '@\{push\}'::
  后缀 '@\{push}' 报告的是在 `branchname` 签出时运行 `git push` 时 “我们会推送到哪里” 的分支（如果没有指定分支名，则报告当前的 `HEAD`）。就像 '@\{upstream\}' 一样，我们会报告与该分支相对应的远程跟踪分支。
+
这里有一个例子，可以更清楚地说明这一点:
+
------------------------------
$ git config push.default current
$ git config remote.pushdefault myfork
$ git switch -c mybranch origin/master

$ git rev-parse --symbolic-full-name @{upstream}
refs/remotes/origin/master

$ git rev-parse --symbolic-full-name @{push}
refs/remotes/myfork/mybranch
------------------------------
+
请注意，我们在示例中设置了一个三角工作流，即从一个位置提取数据，然后推送到另一个位置。在非三角工作流中，'@\{push}' 与 '@\{upstream}' 相同，没有必要使用。
+
这个后缀用大写字母拼写时也被接受，无论大小写，意思都一样。

'<修订号>{caret}[<n>]'，例如 'HEAD{caret}, v1.5.1{caret}0'::
  修订参数的后缀 '{caret}' 表示该提交对象的第一个父对象。 '{caret}<n>'表示第 <n> 个父提交（即 '<rev>{caret}' 等同于 '<rev>{caret}1'）。 作为一条特殊规则，'<rev>{caret}0' 表示提交本身，在 '<rev>' 是指向提交对象的标记对象的对象名时使用。

'<修订>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'::
  修订参数的后缀 '{tilde}' 表示该提交对象的第一代父对象。 修订参数的后缀 '{tilde}<n>' 表示该提交对象的 <n> 代祖先，仅次于第一代父对象。 例如，'<rev>{tilde}3' 等同于 '<rev>{caret}{caret}{caret}'，后者等同于 '<rev>{caret}1{caret}1{caret}1'。 请参阅下面的示例，了解这种形式的用法。

'<修订>{caret}{<类型>}', e.g. 'v0.99.8{caret}\{commit\}'::
  后缀 '{caret}' 后跟有一对括号的对象类型名称，表示在 '<修订>' 处递归引用该对象，直到找到 '<类型>' 类型的对象或该对象无法再被引用（在这种情况下，barf）。 例如，如果 '<修订>' 是一个提交对象，那么 '<修订>{caret}/{commit/}' 就描述了相应的提交对象。 同样，如果 '<修订>' 是一个树对象，那么 '<修订>{caret}/{tree/}' 就描述了相应的树对象。 '<修订>{caret}0' 是 '<rev>{caret}/{commit/}' 的简写。
+
'<修订>{caret}/{object/}' 可以用来确保 '<修订>' 命名了一个存在的对象，而不要求 '<修订>' 是一个标记，也不需要取消引用 '<修订>'；因为一个标记已经是一个对象，所以即使取消引用一次也不一定能找到一个对象。
+
可以使用 '<修订>{caret}/{tag\}' 来确保 '<修订>' 标识现有的标记对象。

'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'::
  后缀 '{caret}' 后跟一个空括号对，表示该对象可能是一个标记，并递归引用该标记，直到找到一个非标记对象。

'<修订>{caret}{/<文本>}'，例如 'HEAD^{/fix nasty bug（修复讨厌的 BUG）}'::
  版本参数的后缀 '{caret}'，后面是包含以斜线为首的文本的括号对，与下面的 ':/fix nasty bug' 语法相同，但它返回的是 '{caret}' 之前的 '<修订>' 中最年轻的匹配提交。

':/<文本>'，例如 ':/fix nasty bug'::
  冒号后的斜线和文本，用于命名提交信息与指定正则表达式匹配的提交。 该名称会返回可从任何引用（包括 HEAD）到达的最年轻的匹配提交。 正则表达式可以匹配提交信息的任何部分。要匹配以字符串开头的提交信息，可以使用 ':/^foo'。特殊序列 ':/!' 用于修饰匹配内容。':/!-foo' 执行负匹配，而 ':/!!foo' 则匹配字面意义上的 '!' 字符，后接 'foo'。以 ':/!' 开头的其他序列暂时保留。 根据给定的文本，shell 的分词规则可能需要额外的引号。

'<修订>:<路径>'，例如 'HEAD:README', 'master:./README'::
  后缀 ':' 和路径会在冒号前的树状对象中命名给定路径上的 blob 或树。 以'./' 或 '../' 开头的路径是相对于当前工作目录的。 给定路径将转换为相对于工作树根目录的路径。 这对于从与工作树具有相同树形结构的提交或树中查找 blob 或树最为有用。

':[<n>:]<路径>', e.g. ':0:README', ':README'::
  一个冒号（可选）后面跟一个阶段编号（0 至 3）和一个冒号，冒号后面跟一个路径，用于命名索引中位于给定路径的 Blob 对象。如果缺少阶段号（以及后面的冒号），则命名为阶段 0 条目。在合并过程中，阶段 1 是共同祖先，阶段 2 是目标分支的版本（通常是当前分支），阶段 3 是被合并分支的版本。

下面是 Jon Loeliger 绘制的一幅插图。 提交节点 B 和 C 都是提交节点 A 的父节点。 父提交从左到右排序。

........................................
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
........................................

    A =      = A^0
    B = A^   = A^1     = A~1
    C =      = A^2
    D = A^^  = A^1^1   = A~2
    E = B^2  = A^^2
    F = B^3  = A^^3
    G = A^^^ = A^1^1^1 = A~3
    H = D^2  = B^^2    = A^^^2  = A~2^2
    I = F^   = B^3^    = A^^3^
    J = F^2  = B^3^2   = A^^3^2


指定范围
----

历史记录遍历命令，如 `git log` 会对一组提交进行操作，而不仅仅是单个提交。

对于这些命令，使用上一节中描述的符号指定一个修订版本，意味着从给定的提交开始 `可达到` 的一组提交。

指定多个修订版本指的是可从任何给定的提交版本到达的提交版本集。

提交的可达集合是指提交本身及其祖先链中的提交。

有几种符号可以指定一组相连的提交（称为 “修订范围”），如下图所示。


排除提交
~~~~

'{caret}<修订号>'（catet）表示::
 要排除某个提交中可触及的提交，可使用前缀 '{caret}' 表示。 例如，'{caret}r1 r2' 表示可从 'r2' 到达的提交，但不包括可从 'r1' 到达的提交（即 'r1' 及其祖先）。

虚线范围符号
~~~~~~

'..'（双点）范围符号::
 由于 '{caret}r1 r2' 的设置操作经常出现，所以有了一种速记方法。 当你有两个提交 'r1' 和 'r2'（根据上文 “指定修订” 中解释的语法命名）时，你可以通过 '{caret}r1 r2' 请求从 r2 可以访问的提交，但不包括从 r1 可以访问的提交，可以写成 'r1...r2'。

'\...'（三点）对称差符号::
 类似的符号 'r1\...r2' 被称为 'r1' 和 'r2' 的对称差值，定义为 'r1 r2 --not $(git merge-base --all r1 r2)'。 它是可以从 'r1'（左侧）或 'r2'（右侧）之一到达，但不能同时从两处到达的提交的集合。

在这两种速记符号中，你可以省略一端，让它默认为 HEAD。 例如，'origin..' 是 'origin..HEAD' 的简写，问的是 “我从起源分支分叉后做了什么？” 同样，'..origin' 是 'HEAD..origin' 的简写，问的是 “我从起源分支分叉后做了什么？” 请注意，'..' 指的是 'HEAD..HEAD'，它是一个空范围，既可从 HEAD 访问，也不可从 HEAD 访问。

也有专门针对两个不同范围的命令（例如 "git range-diff R1 R2"，用于比较两个范围），但它们都是例外。 除非另有说明，否则所有对一组提交进行操作的 "git" 命令都是针对单一修订范围的。 换句话说，将两个 “双点范围符号” 写在一起，例如。

    $ git log A..B C..D

*不* 会为大多数命令指定两个修订范围。 取而代之的是，它将命名单个相连的提交集，即那些从 B 或 D 可以到达，但从 A 或 C 都不能到达的提交集：

    ---A---B---o---o---C---D

因为 A 和 B 可以从 C 处到达，所以这两个虚线范围指定的修订范围是单一的提交 D。


其他 <修订号>{caret}父级速记符号
~~~~~~~~~~~~~~~~~~~~~
还有其他三种简称，特别适用于合并提交，用于命名由提交及其父提交组成的集合。

'r1{caret}@' 表示 'r1' 的所有父代。

'r1{caret}!' 表示包含提交 'r1'，但不包括其所有父提交。 就其本身而言，该符号表示单个提交 'r1'。

'<修订号>{caret}-[<n>]' 符号包括 '<修订号>' ，但不包括第 <n> 次父提交（即 '<修订号>{caret}<n>..<修订号>' 的速记形式），如果没有给出，则 '<n>'= 1。这对合并提交非常有用，只需传递 '<提交号>{caret}-'，就能获得在合并提交 '<提交号>' 中被合并的分支的所有提交（包括 '<提交号>' 本身）。

虽然 '<修订号>{caret}<n>' 是指定单个提交的父提交，但这三种符号也会考虑其父提交。例如，你可以说 'HEAD{caret}2{caret}@'，但不能说 'HEAD{caret}@{caret}2'。

修订范围摘要
------

'<rev>'::
	包括可从 <修订号> 到达的提交（即 <修订号> 及其祖先）。

'{caret}<修订号>'::
	排除可从 <修订号> 到达的提交（即 <修订号> 及其祖先）。

'<rev1>..<rev2>'::
	包括可从 <修订号2> 进入的提交，但不包括可从 <修订号1> 进入的提交。 如果省略 <修订号1> 或 <修订号2>，则默认为 `HEAD`。

'<修订号1>\...<修订号2>'::
	包括 <修订号1> 或 <修订号2> 均可访问的提交，但不包括 <修订号1> 和 <修订号2> 均可访问的提交。 省略 <修订号1> 或 <修订号2> 时，默认为 `HEAD`。

'<修订>{caret}@', e.g. 'HEAD{caret}@'::
  后缀 '{caret}' 后跟一个 at(@) 符号，就等于列出了 '<修订号>' 的所有父提交（意思是，包括父提交中可触及的任何内容，但不包括提交本身）。

'<修订号>{caret}!'，例如 'HEAD{caret}!'::
  带感叹号的后缀 '{caret}' 与提交 '<修订号>' 及其所有前缀为 '{caret}' 的父节点相同，都是为了排除它们（及其祖先）。

'<修订号>{caret}-<n>'，例如 'HEAD{caret}-, HEAD{caret}-2'::
	等价于 '<修订号>{caret}<n>..<修订号>'，如果未给出，则 '<n>'= 1。

下面是一些使用上述 Loeliger 插图的示例，其中仔细说明了符号扩展和选择的每个步骤：

....
   参数   扩展参数    选定的提交
   D                            G H D
   D F                          G H I J D F
   ^G D                         H D
   ^D B                         E I J F B
   ^D B C                       E I J F B C
   C                            I J F C
   B..C   = ^B C                C
   B...C  = B ^F C              G H D E B C
   B^-    = B^..B
	  = ^B^1 B              E I J F B
   C^@    = C^1
	  = F                   I J F
   B^@    = B^1 B^2 B^3
	  = D E F               D G H E F I J
   C^!    = C ^C^@
	  = C ^C^1
	  = C ^F                C
   B^!    = B ^B^@
	  = B ^B^1 ^B^2 ^B^3
	  = B ^D ^E ^F          B
   F^! D  = F ^I ^J D           G H D F
....
