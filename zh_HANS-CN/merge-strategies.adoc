合并战略
----

合并机制（ `git merge` 和 `git pull` 命令）允许用 `-s` 选项来选择后端'合并策略'。 一些策略也可以采取自己的选项，可以通过给 `git merge` 和/或 `git pull` 的 `-X<选项>` 参数来传递。

ort 策略::
	这是拉取或合并一个分支时的默认合并策略。 这个策略只能使用三方合并算法解决两个头。 当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并将其作为三方合并的参考树。 据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。 此外，这个策略可以检测并处理涉及重命名的合并。 它并不使用检测到的副本。 这个算法的名字是一个缩写（"Ostensibly Recursive's Twin"），来自于它是作为以前的默认算法`recursive`的替代而编写的。
+
In the case where the path is a submodule, if the submodule commit used on one side of the merge is a descendant of the submodule commit used on the other side of the merge, Git attempts to fast-forward to the descendant. Otherwise, Git will treat this case as a conflict, suggesting as a resolution a submodule commit that is descendant of the conflicting ones, if one exists.
+
'ort' 策略可以采取以下选项：

ours;;
	这个选项通过倾向于 "我们" 的版本，迫使冲突的猎物被自动解决。 另一棵目录树上与我们这边不冲突的变化会反映在合并结果中。 对于一个二进制文件，整个内容都来自我们这边。
+
这不应该与 "我们的" 合并策略相混淆，后者甚至根本不看另一棵目录树包含了什么。 它抛弃了其他树所做的一切，宣布 "我们的" 历史包含了其中所发生的一切。

theirs;;
	这与 "我们的" 相反；注意，与 "我们的" 不同，没有 "他们的" 合并策略来混淆这个合并选项。

ignore-space-change;;
ignore-all-space;;
ignore-space-at-eol;;
ignore-cr-at-eol;;
	为了进行三方合并，将具有指定类型的空白变化的行视为没有变化。 但混合了其他改动的行的空白改动不会被忽略。 参见linkgit:git-diff[1] `-b`, `-w`, `--ignore-space-at-eol`, 和 `--ignore-cr-at-eol`。
+
* 如果 "他们的" 版本只在一行中引入了空白的变化，则使用 "我们的" 版本；
* 如果 "我们的" 版本引入了空白的变化，但 "他们的" 版本包括一个实质性的变化，则使用 "他们的" 版本;
* 否则，合并将以常规方式进行。

renormalize;;
	This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See "Merging branches with differing checkin/checkout attributes" in linkgit:gitattributes[5] for details.

no-renormalize;;
	禁用 `renormalize` 选项。 这覆盖了 `merge.renormalize` 配置变量。

find-renames[=<n>];;
	开启重名检测，可选择设置相似度阈值。 这是默认的。这覆盖了 'merge.renames' 配置变量。 参见linkgit:git-diff[1] `--find-renames`。

rename-threshold=<n>;;
	废弃的，`find-renames=<n>` 的同义词。

no-renames;;
	关闭重名检测。这覆盖了 `merge.renames` 的配置变量。 参见linkgit:git-diff[1] `--no-renames`。

histogram;;
	Deprecated synonym for `diff-algorithm=histogram`.

patience;;
	废弃的，`diff-algorithm=patience` 的同义词。

diff-algorithm=[histogram|minimal|myers|patience];;
	Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also linkgit:git-diff[1] `--diff-algorithm`. Note that `ort` defaults to `diff-algorithm=histogram`, while regular diffs currently default to the `diff.algorithm` config setting.

subtree[=<路径>];;
	这个选项是 '子树' 策略的更高级形式，该策略对两棵树在合并时必须如何移位以相互匹配进行猜测。 相反，指定的路径是前缀（或从开始剥离），以使两棵树的形状相匹配。

recursive::
	This is now a synonym for `ort`. It was an alternative implementation until v2.49.0, but was redirected to mean `ort` in v2.50.0. The previous recursive strategy was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0.

resolve::
	这只能用三方合并算法解决两个头（即当前分支和你拉来的另一个分支）。 它试图仔细检测纵横交错的合并歧义。 它不处理重名。

octopus::
	这可以解决有两个以上头的情况，但拒绝做复杂的合并，需要手动解决。 它主要是用于将主题分支头捆绑在一起。 当拉动或合并一个以上的分支时，这是默认的合并策略。

ours::
	This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the 'ort' merge strategy.

subtree::
	这是一个修正的 `ort` 策略。当合并树A和B时，如果B对应于A的子树，B首先被调整为与A的树结构相匹配，而不是在同一级别读取树。这种调整也是针对共同祖先树进行的。

对于使用三方合并的策略（包括默认的 'ort' 策略），如果在两个分支上都做了修改，但后来在其中一个分支上被撤销，那么这个修改就会出现在合并后的结果中；有些人觉得这种行为令人困惑。 出现这种情况是因为在执行合并时只考虑头部和合并基数，而不是单个提交。 因此，合并算法认为被恢复的修改根本就没有变化，而是用被修改的版本来代替。
