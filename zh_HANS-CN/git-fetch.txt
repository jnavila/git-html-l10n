git-fetch(1)
============

名称
--
git-fetch - 从另一个仓库下载对象和引用


概述
--
[verse]
'git fetch' [<选项>] [<仓库> [<引用规范>...]]
'git fetch' [<选项>] <组>
'git fetch' --multiple [<选项>] [(<仓库> | <组>)...]
'git fetch' --all [<选项>]


描述
--
从一个或多个其它仓库获取分支和/或标记（统称为 "refs"），以及完成其历史所需的对象。 远程跟踪的分支会被更新（关于控制这种行为的方法，请参见下面 <引用规范> 的描述）。

默认情况下，任何指向被获取的历史的标签也会被获取；其效果是获取指向你感兴趣的分支的标签。 这个默认行为可以通过使用 --tags 或 --no-tags 选项或者配置 remote.<远程仓库名称>.tagOpt 来改变。 通过使用明确获取标签的引用规范，你也可以获取那些没有指向你感兴趣的分支的标签。

'git fetch' 可以从一个命名的仓库或 URL 中获取，或者如果给定了 <组> 并且在配置文件中有 remotes.<组> 项，则可以同时从几个仓库获取。 (参见 linkgit:git-config[1]）。

当没有指定远程仓库时，默认情况下将使用 `origin` 远程仓库，除非有一个上游分支配置在当前分支上。

被获取的引用名称，以及它们所指向的对象名称，被写到 `.git/FETCH_HEAD`。 这些信息可以被脚本或其他 git 命令使用，比如linkgit:git-pull[1]。

选项
--
include::fetch-options.txt[]

include::pull-fetch-param.txt[]

--stdin::
	从stdin中读取引用规范，每行一个，除了作为参数提供的那些之外。不支持 "标签 <名称>" 格式。

include::urls-remotes.txt[]


配置的远程跟踪分支 [[CRTB]]
------------------

你通过经常定期和重复地从同一个远程仓库取东西来与之互动。 为了跟踪这种远程仓库的进度，`git fetch` 允许你配置 `remote.<仓库>.fetch` 配置变量。

一般来说，这种变量可能看起来像这样：

------------------------------------------------
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*
------------------------------------------------

这种配置有两种使用方式：

* 当 `git fetch` 运行时，没有在命令行中指定要取哪些分支和/或标记，例如 `git fetch origin` 或 `git fetch`，`remote.<仓库>.fetch` 值被用作引用规范——它们指定要取哪些引用和要更新哪些本地引用。 上面的例子将获取所有存在于 `origin` 中的分支（即任何与数值左边的`refs/heads/*`相匹配的引用），并更新 `refs/remotes/origin/*` 层次结构中相应的远程跟踪的分支。

* 当 `git fetch` 运行时，命令行上有明确的要取的分支和/或标记，例如 `git fetch origin master`，命令行上给出的所有 <引用规范> 决定了要取的是什么（例如例子中的 `master` 是 `master:` 的简称，意思是 "获取 'master' 分支，但我没有明确说要在命令行中更新哪个远程跟踪分支"），而这个例子的命令将「只」获取 'master' 分支。 `remote.<仓库>.fetch`值决定了哪个远程跟踪分支（如果有的话）被更新。 当以这种方式使用时，`remote.<仓库>.fetch` 值对决定获取什么没有任何影响（即当命令行列出引用规范时，这些值不会被用作引用规范）；它们只是通过作为一个映射来决定获取的引用被存储在哪里。

后者对 `remote.<仓库>.fetch` 值的使用可以通过在命令行中给出 `--refmap=<引用规范>` 参数去覆盖。

剪枝
--

Git默认保留数据，除非它被明确地扔掉；这延伸到保留对远程分支的本地引用，而这些分支本身已经被删除。

如果任其积累，这些陈旧的引用可能会使大型繁忙仓库的性能变差，例如，使 `git branch -a --contains <提交>` 等命令的输出不必要地冗长，以及影响其他任何与完整的已知引用有关的工作。

这些远程跟踪引用可以通过以下两种方式一次性删除：

------------------------------------------------
# 在获取的时候
$ git fetch --prune <名称>

# 只修剪，不获取
$ git remote prune <名称>
------------------------------------------------

要把修剪引用作为正常工作流程的一部分，而不需要记住运行该程序，可以在全局设置 `fetch.prune`，或者在配置中设置 `remote.<名称>.prune`，为每个远程仓库进行设置。见linkgit:git-config[1]。

这里是事情变得棘手和更具体的地方。修剪功能实际上并不关心分支，相反，它将修剪本地<-->远程引用，作为远程的引用规范的函数（见上面的`<引用规范>`和上面的<<CRTB,配置远程跟踪分支>>）。

因此，如果远程的引用规范包括例如 `refs/tags/*:refs/tags/*`这样的规范，或者你手动运行例如 `git fetch --prune <名称> "refs/tags/*:refs/tags/*"`，那么被删除的就不是过时的远程跟踪分支，而是远程上不存在的任何本地标签。

这可能不是你所期望的，即你想修剪远程的 `<名称>`，但也明确地从它那里获取标签，所以当你从它那里获取时，你会删除所有的本地标签，其中大部分可能首先不是来自远程的 `<名称>`。

因此，当与 `refs/tags/*:refs/tags/*` 这样的引用规范一起使用时要小心，或者任何其他可能将多个远程的引用映射到同一本地命名空间的引用规范。

由于在远程保持最新的分支和标签是一个常见的使用情况，`--prune-tags` 选项可以和 `--prune` 一起使用，以修剪在远程不存在的本地标签，并强制更新那些不同的标签。标签修剪也可以通过配置中的 `fetch.pruneTags` 或 `remote.<名称>.pruneTags` 启用。见linkgit:git-config[1]。

`--prune-tags` 选项相当于在远程的引用规范中声明 `refs/tags/*:refs/tags/*` 。这可能会导致一些看起来很奇怪的结果：

------------------------------------------------
# 这两个命令都可以用来获取标签
$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'
$ git fetch --no-tags --prune-tags origin
------------------------------------------------

在没有 `--prune` 或其配置的情况下，它不会出错的原因是为了配置的灵活性，以及在命令行标志和配置之间保持 1=1 的映射。

例如，在 `~/.gitconfig` 中配置 `fetch.pruneTags=true`，以便在运行 `git fetch --prune` 时修剪标签，这是很合理的，不会使每次调用 `git fetch` 而没有 `--prune` 时都出现错误。

使用 `--prune-tags` 修剪标签，在获取一个URL而不是一个命名的远程时也能发挥作用。这些都会修剪在原点没有发现的标签：

------------------------------------------------
$ git fetch origin --prune --prune-tags
$ git fetch origin --prune 'refs/tags/*:refs/tags/*'
$ git fetch <origin 的地址> --prune --prune-tags
$ git fetch <origin 的 地址> --prune 'refs/tags/*:refs/tags/*'
------------------------------------------------

输出
--

"git fetch" 的输出取决于所使用的传输方式；本节描述了通过 Git 协议（本地或通过 ssh）和智能 HTTP 协议获取时的输出。

获取的状态以表格的形式输出，每一行代表一个引用的状态。每一行的形式是：

-------------------------------
 <标志> <概述> <起始> -> <结束> [<原因>]
-------------------------------

当使用 `--porcelain` 时，输出格式的目的是让机器可以解析。与人类可读的输出格式不同，它将打印到标准输出而不是标准错误。每一行都是这样的形式：

-------------------------------
<标志> <旧对象ID> <新对象ID> <本地引用>
-------------------------------

只有在使用 --verbose 选项时，才会显示最新的引用状态。

在紧凑输出模式下，通过配置变量 fetch.output 指定，如果在另一个字符串中发现整个 `<起点>` 或 `<终点>`，它将被替换成另一个字符串中的 `*`。例如，`master -> origin/master` 变成 `master -> origin/*`。

标志::
	表示引用状态的单个字符：
（空格）;; 表示成功的快速合并；
`+`;; 表示一个成功的强制更新；
`-`;; 表示成功修剪引用；
`t`;; 表示成功更新标签；
`*`;; 表示成功获取新引用；
`!`;; 表示被拒绝或更新失败的引用；以及
`=`;; 表示一个最新的、不需要获取的引用。

概述::
	对于一个成功获取的引用，摘要以适合作为 `git log` 参数的形式显示该引用的新旧值（在大多数情况下是 `<旧>..<新>`，对于强制非快速合并是 `<旧>...<新>`）。

起始::
	被获取的远程引用的名称，减去其`refs/<类型>/`前缀。在删除的情况下，远程引用的名称是 "(none)"。

结束::
	被更新的本地引用的名称，去掉其 `refs/<类型>/` 前缀。

原因::
	一个人类可读的解释。如果是成功获取的引用，不需要解释。对于失败的引用，将描述失败的原因。

实例
--

* 更新远程追踪的分支：
+
------------------------------------------------
$ git fetch origin
------------------------------------------------
+
上述命令从远程的 `refs/heads/` 命名空间复制所有分支，并存储到本地的 `refs/remotes/origin/` 命名空间，除非使用 `remote.<仓库>.fetch` 选项来指定一个非默认的引用规范。

* 明确使用引用规范：
+
------------------------------------------------
$ git fetch origin +seen:seen maint:tmp
------------------------------------------------
+
这通过从远程存储库的分支（分别）获取 `seen` 和 `maint` 来更新（或根据需要创建）本地存储库中的分支 `seen` 和 `tmp`。
+
即使不快进，`seen` 分支也会被更新，因为它的前缀是加号；`tmp` 则不会。

* 窥视一个远程的分支，而不需要在你的本地版本库中配置远程：
+
------------------------------------------------
$ git fetch git://git.kernel.org/pub/scm/git/git.git maint
$ git log FETCH_HEAD
------------------------------------------------
+
第一条命令从 `git://git.kernel.org/pub/scm/git.git` 的存储库中获取 `maint` 分支，第二条命令使用 `FETCH_HEAD` 用 linkgit:git-log[1] 来检查该分支。 取出的对象最终会被 git 内置的内务管理删除（见 linkgit:git-gc[1]）。

include::transfer-data-leaks.txt[]

配置
--

include::includes/cmd-config-section-all.txt[]

include::config/fetch.txt[]

漏洞
--
使用 --recurse-submodules 只能获取本地存在的子模块中的新提交，例如在 `$GIT_DIR/modules/`。如果上游添加了一个新的子模块，该子模块不能被获取，直到它被克隆，例如，通过`git submodule update`。这个问题有望在未来的 Git 版本中被修复。

参见
--
linkgit:git-pull[1]

GIT
---
属于 linkgit:git[1] 文档
