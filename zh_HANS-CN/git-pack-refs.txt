git-pack-refs(1)
================

名称
--
git-pack-refs - 打包头和标签，以便有效地访问仓库

概述
--
[verse]
'git pack-refs' [--all] [--no-prune] [--include <pattern>] [--exclude <pattern>]

描述
--

传统上，分支和标签的提示（统称为 'refs'）是在 `$GIT_DIR/refs` 目录下的一个（子）目录中，为每个引用储存一个文件。 虽然许多分支的提示经常被更新，但大多数标签和一些分支的提示从未被更新。 当一个仓库库有成百上千的标签时，这种每个引用一个文件的格式既浪费了存储空间，又损害了性能。

这个命令是用来解决存储和性能问题的，将引用存储在一个文件中，`$GIT_DIR/packed-refs`。 当传统的 `$GIT_DIR/refs`目录层次中缺少一个引用时，就在这个文件中查找，如果找到就使用。

分支的后续更新总是在 `$GIT_DIR/refs` 目录层次下创建新文件。

处理一个有太多引用的仓库的推荐做法是，用 `--all` 来打包它的引用一次，然后偶尔运行 `git pack-refs` 。 根据定义，标签是固定的，不应该改变。 分支头会被初始的 `pack-refs --all` 打包，但只有当前活动的分支头会被解压，下一次 `pack-refs`（没有 `--all`）会让它们被解压。


选项
--

--all::

The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes all refs to be packed as well, with the exception of hidden refs, broken refs, and symbolic refs. Useful for a repository with many branches of historical interests.

--no-prune::

该命令通常在打包后删除 `$GIT_DIR/refs` 层次下的松散引用。 这个选项告诉它不要这样做。

--include <pattern>::

根据 `glob(7)` 模式打包引用。重复使用该选项会累积包含模式。如果一个引用同时包含在 `--include` 和 `--exclude` 中，则 `--exclude` 优先。使用 `--include` 会默认排除所有标记。符号引用和断开的引用将永远不会被打包。与 `--all` 一起使用时，它将是一个 空操作。使用 `--no-include` 清除并重置模式列表。

--排除<pattern>。::

不打包与给定的 `glob(7)` 模式匹配的引用。重复使用此选项会累积排除模式。使用 `--no-exclude` 可以清除并重置模式列表。如果一个引用已经打包，使用 `--exclude`不会将其解包。

与 `--all` 一起使用时，只打包与所提供的 `--exclude` 模式不匹配的松散引用。

当与 `--include` 一起使用时，提供给 `--include` 的引用减去提供给 `--exclude` 的引用将被打包。


漏洞
--

在引入 packed-refs 机制之前编写的旧文档可能仍然会说 ".git/refs/heads/<branch>文件存在" 这样的话，而它的意思是 "<branch> 分支存在"。


GIT
---
属于 linkgit:git[1] 文档
