git-pack-refs(1)
================

名称
--
git-pack-refs - 打包头和标签，以便有效地访问仓库

概述
--
[verse]
'git pack-refs' [--all] [--no-prune]

描述
--

传统上，分支和标签的提示（统称为 'refs'）是在 `$GIT_DIR/refs` 目录下的一个（子）目录中，为每个引用储存一个文件。 虽然许多分支的提示经常被更新，但大多数标签和一些分支的提示从未被更新。 当一个仓库库有成百上千的标签时，这种每个引用一个文件的格式既浪费了存储空间，又损害了性能。

这个命令是用来解决存储和性能问题的，将引用存储在一个文件中，`$GIT_DIR/packed-refs`。 当传统的 `$GIT_DIR/refs`目录层次中缺少一个引用时，就在这个文件中查找，如果找到就使用。

分支的后续更新总是在 `$GIT_DIR/refs` 目录层次下创建新文件。

处理一个有太多引用的仓库的推荐做法是，用 `--all` 来打包它的引用一次，然后偶尔运行 `git pack-refs` 。 根据定义，标签是固定的，不应该改变。 分支头会被初始的 `pack-refs --all` 打包，但只有当前活动的分支头会被解压，下一次 `pack-refs`（没有 `--all`）会让它们被解压。


选项
--

--all::

该命令默认打包所有已经打包的标签和引用，而对其他引用不作任何处理。 这是因为预计分支会被积极开发，打包它们的提示对性能没有帮助。 这个选项使分支的提示也被打包。 这对有许多具有历史意义的分支的仓库很有用。

--no-prune::

该命令通常在打包后删除 `$GIT_DIR/refs` 层次下的松散引用。 这个选项告诉它不要这样做。


漏洞
--

在引入 packed-refs 机制之前编写的旧文档可能仍然会说 ".git/refs/heads/<branch>文件存在" 这样的话，而它的意思是 "<branch> 分支存在"。


GIT
---
属于 linkgit:git[1] 文档
