git-checkout-index(1)
=====================

名称
--
git-checkout-index - 将文件从索引复制到工作目录树


概述
--
[verse]
'git checkout-index' [-u] [-q] [-a] [-f] [-n] [--prefix=<字符串>]
		   [--stage=<数字>|all]
		   [--temp]
		   [--ignore-skip-worktree-bits]
		   [-z] [--stdin]
		   [--] [<文件>...]

描述
--
将索引中列出的所有文件复制到工作目录（不会覆盖现有文件）。

选项
--
-u::
--index::
	更新索引文件中已签出条目的统计信息。

-q::
--quiet::
	如果文件存在或不在索引中，则保持安静

-f::
--force::
	强制覆盖现有文件

-a::
--all::
	检查索引中的所有文件，但设置了跳过工作树位的文件除外（参见 `--ignore-skip-worktree-bits`）。 不能与显式文件名一起使用。

-n::
--no-create::
	不签出新文件，只刷新已签出的文件。

--prefix=<字符串>::
	创建文件时，预输入 <字符串>（通常是目录，包括尾部的 /）

--stage=<数量>|all::
	不检查未合并的条目，而是从命名的阶段复制出文件。 <数字> 必须介于 1 和 3 之间。 注意：--stage=all 自动隐含 --temp。

--temp::
	与其将文件复制到工作目录，不如将内容写入临时文件。 临时名称关联将写入标准输出流。

--ignore-skip-worktree-bits::
	检查所有文件，包括设置了跳过工作树位的文件。

--stdin::
	不从命令行中获取路径列表，而是从标准输入中读取路径列表。 默认情况下，路径之间用 LF 分隔（即每行一个路径）。

-z::
	只对 `--stdin` 有意义；路径用 NUL 字符分隔，而不用 LF。

\--::
	不将之后的参数解释为选项。

标志的顺序曾经很重要，但现在已经不重要了。

只做 `git checkout-index`什么也做不了。你可能是指 `git checkout-index -a`。如果你想强制执行，就需要 `git checkout-index -f -a`。

直观性不是目的。可重复性才是。“没有参数就意味着没有工作” 这一行为的原因是，脚本应该能够实现以下功能：

----------------
$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --
----------------

会强制将所有现有的 `*.h` 文件替换为其缓存副本。如果空命令行意味着 "all"，那么这将强制刷新索引中的所有内容，而这并不是重点。 但由于 "git checkout-index" 接受 --stdin，因此使用起来会更快：

----------------
$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin
----------------

当你知道其余的都是文件名时，`--` 是一个好主意；它可以防止出现文件名为 `-a` 的问题。 在脚本中使用 `--` 可能是个好主意。


使用 --temp 或 --stage=all
-----------------------
当使用了 `--temp`（或由 `--stage=all`隐含）时，"git checkout-index" 将为每个被检出的索引条目创建一个临时文件。 索引不会更新统计信息。 如果调用者需要所有未合并条目的所有阶段，以便外部合并工具可以处理这些未合并文件，那么这些选项会很有用。

将向标准输出流写入一个列表，提供临时文件名与跟踪路径名之间的关联。 列表格式有两种：

    . 临时名称 TAB 路径 RS
+
语类型：纯文本 第一种格式是省略 `--stage` 或不使用 `--stage=all` 时使用的格式。字段临时名称是保存文件内容的临时文件名，路劲是索引中的跟踪路径名。 只输出所请求的条目。

    . 阶段一缓存 SP 阶段二缓存 SP 阶段三缓存 TAB 路径 RS
+
第二种格式是在 `--stage=all` 时使用的格式。 如果索引中有阶段条目，三个阶段临时字段（阶段一缓存、阶段二缓存、阶段三换粗）会列出临时文件的名称；如果没有阶段条目，则会列出 `.`。 只有阶段 0 条目的路径将始终从输出中省略。

在这两种格式中，RS（记录分隔符）默认都是换行符，但如果在命令行中输入了 -z，RS（记录分隔符）就会变成空字节。 临时文件名始终是安全字符串，绝不包含目录分隔符或空白字符。 路径字段始终相对于当前目录，临时文件名始终相对于顶层目录。

如果被复制到临时文件中的对象是一个符号链接，那么该链接的内容将被写入一个普通文件。 最终用户或 Porcelain 可自行决定是否使用这些信息。


实例
--
只更新和刷新已签出的文件::
+
----------------
$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh
----------------

使用 'git checkout-index' 来 “导出整棵目录树”::
	有了前缀功能，使用 'git checkout-index' 作为 “导出为目录树” 功能就变得易如反掌了。 只需将所需的目录树读入索引，然后执行即可：
+
----------------
$ git checkout-index --prefix=git-export-dir/ -a
----------------
+
`git checkout-index` 会将索引 “导出” 到指定目录。
+
最后的 "/" 很重要。导出的名称实际上只是指定字符串的前缀。 这与下面的示例形成鲜明对比。

导出带前缀的文件::
+
----------------
$ git checkout-index --prefix=.merged- Makefile
----------------
+
这将把当前缓存的 `Makefile` 副本签出到文件 `.merged-Makefile` 中。

GIT
---
属于 linkgit:git[1] 文档
