git-fetch(1)
============

名称
--
git-fetch - 从另一个仓库下载对象和引用


概述
--
[synopsis]
git fetch [<options>] [<repository> [<refspec>...]]
git fetch [<options>] <group>
git fetch --multiple [<options>] [(<repository>|<group>)...]
git fetch --all [<options>]


描述
--
Fetch branches and/or tags (collectively, "refs") from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of _<refspec>_ below for ways to control this behavior).

By default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in. This default behavior can be changed by using the `--tags` or `--no-tags` options or by configuring `remote.<name>.tagOpt`. By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well.

`git fetch` can fetch from either a single named repository or URL, or from several repositories at once if _<group>_ is given and there is a `remotes.<group>` entry in the configuration file. (See linkgit:git-config[1]).

当没有指定远程仓库时，默认情况下将使用 `origin` 远程仓库，除非有一个上游分支配置在当前分支上。

被获取的引用名称，以及它们所指向的对象名称，被写到 `.git/FETCH_HEAD`。 这些信息可以被脚本或其他 git 命令使用，比如linkgit:git-pull[1]。

选项
--
include::fetch-options.adoc[]

include::pull-fetch-param.adoc[]

`--stdin`::
	Read refspecs, one per line, from stdin in addition to those provided as arguments. The "tag _<name>_" format is not supported.

include::urls-remotes.adoc[]

[[CRTB]]
CONFIGURED REMOTE-TRACKING BRANCHES
-----------------------------------

你通过经常定期和重复地从同一个远程仓库取东西来与之互动。 为了跟踪这种远程仓库的进度，`git fetch` 允许你配置 `remote.<仓库>.fetch` 配置变量。

一般来说，这种变量可能看起来像这样：

------------------------------------------------
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*
------------------------------------------------

这种配置有两种使用方式：

* 当 `git fetch` 运行时，没有在命令行中指定要取哪些分支和/或标记，例如 `git fetch origin` 或 `git fetch`，`remote.<仓库>.fetch` 值被用作引用规范——它们指定要取哪些引用和要更新哪些本地引用。 上面的例子将获取所有存在于 `origin` 中的分支（即任何与数值左边的`refs/heads/*`相匹配的引用），并更新 `refs/remotes/origin/*` 层次结构中相应的远程跟踪的分支。

* When `git fetch` is run with explicit branches and/or tags to fetch on the command line, e.g. `git fetch origin master`, the _<refspec>s_ given on the command line determine what are to be fetched (e.g. `master` in the example, which is a short-hand for `master:`, which in turn means "fetch the `master` branch but I do not explicitly say what remote-tracking branch to update with it from the command line"), and the example command will fetch _only_ the `master` branch. The `remote.<repository>.fetch` values determine which remote-tracking branch, if any, is updated. When used in this way, the `remote.<repository>.fetch` values do not have any effect in deciding _what_ gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide _where_ the refs that are fetched are stored by acting as a mapping.

后者对 `remote.<仓库>.fetch` 值的使用可以通过在命令行中给出 `--refmap=<引用规范>` 参数去覆盖。

剪枝
--

Git默认保留数据，除非它被明确地扔掉；这延伸到保留对远程分支的本地引用，而这些分支本身已经被删除。

如果任其积累，这些陈旧的引用可能会使大型繁忙仓库的性能变差，例如，使 `git branch -a --contains <提交>` 等命令的输出不必要地冗长，以及影响其他任何与完整的已知引用有关的工作。

这些远程跟踪引用可以通过以下两种方式一次性删除：

------------------------------------------------
# 在获取的时候
$ git fetch --prune <名称>

# 只修剪，不获取
$ git remote prune <名称>
------------------------------------------------

要把修剪引用作为正常工作流程的一部分，而不需要记住运行该程序，可以在全局设置 `fetch.prune`，或者在配置中设置 `remote.<名称>.prune`，为每个远程仓库进行设置。见linkgit:git-config[1]。

这里是事情变得棘手和更具体的地方。修剪功能实际上并不关心分支，相反，它将修剪本地<-->远程引用，作为远程的引用规范的函数（见上面的`<引用规范>`和上面的<<CRTB,配置远程跟踪分支>>）。

因此，如果远程的引用规范包括例如 `refs/tags/*:refs/tags/*`这样的规范，或者你手动运行例如 `git fetch --prune <名称> "refs/tags/*:refs/tags/*"`，那么被删除的就不是过时的远程跟踪分支，而是远程上不存在的任何本地标签。

This might not be what you expect, i.e. you want to prune remote _<name>_, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the _<name>_ remote in the first place.

因此，当与 `refs/tags/*:refs/tags/*` 这样的引用规范一起使用时要小心，或者任何其他可能将多个远程的引用映射到同一本地命名空间的引用规范。

由于在远程保持最新的分支和标签是一个常见的使用情况，`--prune-tags` 选项可以和 `--prune` 一起使用，以修剪在远程不存在的本地标签，并强制更新那些不同的标签。标签修剪也可以通过配置中的 `fetch.pruneTags` 或 `remote.<名称>.pruneTags` 启用。见linkgit:git-config[1]。

`--prune-tags` 选项相当于在远程的引用规范中声明 `refs/tags/*:refs/tags/*` 。这可能会导致一些看起来很奇怪的结果：

------------------------------------------------
# 这两个命令都可以用来获取标签
$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'
$ git fetch --no-tags --prune-tags origin
------------------------------------------------

在没有 `--prune` 或其配置的情况下，它不会出错的原因是为了配置的灵活性，以及在命令行标志和配置之间保持 1=1 的映射。

例如，在 `~/.gitconfig` 中配置 `fetch.pruneTags=true`，以便在运行 `git fetch --prune` 时修剪标签，这是很合理的，不会使每次调用 `git fetch` 而没有 `--prune` 时都出现错误。

使用 `--prune-tags` 修剪标签，在获取一个URL而不是一个命名的远程时也能发挥作用。这些都会修剪在原点没有发现的标签：

------------------------------------------------
$ git fetch origin --prune --prune-tags
$ git fetch origin --prune 'refs/tags/*:refs/tags/*'
$ git fetch <origin 的地址> --prune --prune-tags
$ git fetch <origin 的 地址> --prune 'refs/tags/*:refs/tags/*'
------------------------------------------------

输出
--

"git fetch" 的输出取决于所使用的传输方式；本节描述了通过 Git 协议（本地或通过 ssh）和智能 HTTP 协议获取时的输出。

获取的状态以表格的形式输出，每一行代表一个引用的状态。每一行的形式是：

-------------------------------
 <标志> <概述> <起始> -> <结束> [<原因>]
-------------------------------

当使用 `--porcelain` 时，输出格式的目的是让机器可以解析。与人类可读的输出格式不同，它将打印到标准输出而不是标准错误。每一行都是这样的形式：

-------------------------------
<标志> <旧对象ID> <新对象ID> <本地引用>
-------------------------------

The status of up-to-date refs is shown only if the `--verbose` option is used.

In compact output mode, specified with configuration variable fetch.output, if either entire _<from>_ or _<to>_ is found in the other string, it will be substituted with `*` in the other string. For example, `master -> origin/master` becomes `master -> origin/*`.

标志::
	表示引用状态的单个字符：
（空格）;; 表示成功的快速合并；
`+`;; 表示一个成功的强制更新；
`-`;; 表示成功修剪引用；
`t`;; 表示成功更新标签；
`*`;; 表示成功获取新引用；
`!`;; 表示被拒绝或更新失败的引用；以及
`=`;; 表示一个最新的、不需要获取的引用。

概述::
	对于一个成功获取的引用，摘要以适合作为 `git log` 参数的形式显示该引用的新旧值（在大多数情况下是 `<旧>..<新>`，对于强制非快速合并是 `<旧>...<新>`）。

起始::
	被获取的远程引用的名称，减去其`refs/<类型>/`前缀。在删除的情况下，远程引用的名称是 "(none)"。

结束::
	被更新的本地引用的名称，去掉其 `refs/<类型>/` 前缀。

原因::
	一个人类可读的解释。如果是成功获取的引用，不需要解释。对于失败的引用，将描述失败的原因。

实例
--

* 更新远程追踪的分支：
+
------------------------------------------------
$ git fetch origin
------------------------------------------------
+
上述命令从远程的 `refs/heads/` 命名空间复制所有分支，并存储到本地的 `refs/remotes/origin/` 命名空间，除非使用 `remote.<仓库>.fetch` 选项来指定一个非默认的引用规范。

* 明确使用引用规范：
+
------------------------------------------------
$ git fetch origin +seen:seen maint:tmp
------------------------------------------------
+
这通过从远程存储库的分支（分别）获取 `seen` 和 `maint` 来更新（或根据需要创建）本地存储库中的分支 `seen` 和 `tmp`。
+
即使不快进，`seen` 分支也会被更新，因为它的前缀是加号；`tmp` 则不会。

* 窥视一个远程的分支，而不需要在你的本地版本库中配置远程：
+
------------------------------------------------
$ git fetch git://git.kernel.org/pub/scm/git/git.git maint
$ git log FETCH_HEAD
------------------------------------------------
+
第一条命令从 `git://git.kernel.org/pub/scm/git.git` 的存储库中获取 `maint` 分支，第二条命令使用 `FETCH_HEAD` 用 linkgit:git-log[1] 来检查该分支。 取出的对象最终会被 git 内置的内务管理删除（见 linkgit:git-gc[1]）。

include::transfer-data-leaks.adoc[]

配置
--

include::includes/cmd-config-section-all.adoc[]

include::config/fetch.adoc[]

漏洞
--
Using `--recurse-submodules` can only fetch new commits in submodules that are present locally e.g. in `$GIT_DIR/modules/`. If the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by `git submodule update`. This is expected to be fixed in a future Git version.

参见
--
linkgit:git-pull[1]

GIT
---
属于 linkgit:git[1] 文档
