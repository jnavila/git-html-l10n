承诺限制
~~~~

除了使用描述中解释的特殊符号指定应列出的提交范围，还可以应用额外的提交限制。

使用更多的选项通常会进一步限制输出（例如，`--since=<date1>`限制在比`<date1>`新的提交，与`--grep=<pattern>`一起使用会进一步限制在日志信息中有一行符合`<pattern>`的提交），除非另有说明。

请注意，这些都是在提交排序和格式化选项之前应用的，如`--反转`。

-<数>::
-n <number>::
--max-count=<number>::
	限制输出的提交数量。

--skip=<number>::
	在开始显示提交输出之前，跳过'数'的提交。

--since=<date>::
--after=<日期>::
	显示比某一特定日期更近的提交。

--since-as-filter=<date>::
	Show all commits more recent than a specific date. This visits all commits in the range, rather than stopping at the first commit which is older than a specific date.

--until=<日期>::
--before=<date>::
	显示超过特定日期的提交。

ifdef::git-rev-list[]
--max-age=<timestamp>::
--min-age=<timestamp>::
	将提交的结果限制在指定的时间范围内。
endif::git-rev-list[]

--author=<pattern>::
--committer=<pattern>::
	将提交文件的输出限制在作者/提交人标题行符合指定模式（正则表达式）的文件。 如果有多个`--author=<pattern>`，则会选择作者符合任何一个给定模式的提交（对于多个`--committer=<pattern>`也是如此）。

--grep-reflog=<pattern>::
	将提交文件的输出限制在有符合指定模式（正则表达式）的reflog条目的提交文件。如果有多个 `--grep-reflog`，则会选择那些 reflog 信息符合任何指定模式的提交。 除非使用了`--walk-reflogs`，否则使用此选项是错误的。

--grep=<pattern>::
	将提交结果限制在日志信息与指定模式（正则表达式）相匹配的提交。 如果有多个`--grep=<pattern>`，则会选择那些日志信息与任何指定模式相匹配的提交（但见`--all-match`）。
ifndef::git-rev-list[]
+
当`--笔记`生效时，笔记中的信息被匹配，就像它是日志信息的一部分。
endif::git-rev-list[]

--all-match::
	将输出的提交限制在符合所有给定`--grep`的提交，而不是至少符合一个的提交。

--invert-grep::
	限定输出的提交信息与`--grep=<pattern>指定的模式不匹配。

-i::
--regexp-ignore-case::
	匹配正则表达式的限制模式，不考虑字母大小写。

--basic-regexp::
	将限制性模式视为基本的正则表达式；这是默认的。

-E::
--extended-regexp::
	将限制性模式视为扩展的正则表达式，而不是默认的基本正则表达式。

-F::
--fixed-strings::
	将限制性模式视为固定字符串（不要将模式解释为正则表达式）。

-P::
--perl-regexp::
	将限制性模式视为与Perl兼容的正则表达式。
+
对这些类型的正则表达式的支持是一个可选的编译时依赖。如果Git在编译时没有对它们的支持，提供这个选项将导致它死亡。

--remove-empty::
	当一个给定的路径从树上消失时停止。

--merges::
	只打印合并后的提交。这与`--min-parents=2`完全相同。

--no-merges::
	不打印有一个以上父级的提交。这与`--max-parents=1`完全相同。

--min-parents=<number>::
--max-parents=<number>::
--no-min-parents::
--no-max-parents::
	只显示至少（或最多）有那么多父提交的提交。特别是，`--max-parents=1`等同于`--no-merges`，`--min-parents=2`等同于`--merges`。 `--max-parents=0`给出所有根提交，`--min-parents=3`给出所有章鱼合并。
+
`--no-min-parents` and `--no-max-parents` reset these limits (to no limit) again. Equivalent forms are `--min-parents=0` (any commit has 0 or more parents) and `--max-parents=-1` (negative numbers denote no upper limit).

--first-parent::
	When finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.
ifdef::git-log[]
+
这个选项也改变了合并提交的默认差异格式为 "first-parent"，详见"-diff-merges=first-parent"。
endif::git-log[]

--exclude-first-parent-only::
	When finding commits to exclude (with a '{caret}'), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.

--not::
	颠倒"{caret}"前缀（或没有前缀）对所有后续修订指定符的意义，直到下一个`--not`。

--all::
	假设`refs/`中的所有参考文献，连同`HEAD`一起，在命令行中被列为'<commit>'。

--支部[=<模式>]::
	假设`refs/heads`中的所有 refs 在命令行中被列为 '<commit>'。如果给出了'<pattern>'，将分支限制在与给定的shell glob相匹配的分支。如果pattern缺少'?'、'{asterisk}'或'['，则末尾的'/{asterisk}'是暗示的。

--tags[=<pattern>]::
	假设`refs/tags`中的所有参考文献在命令行中被列为'<commit>'。如果给出了'<pattern>'，将标签限制在与给定的shell glob相匹配的标签。如果pattern缺少'?'、'{asterisk}'或'['，则暗示最后的'/{asterisk}'。

--remotes[=<pattern>]::
	假设`refs/remotes`中的所有 refs 在命令行中被列为 '<commit>'。如果给出了'<pattern>'，将远程跟踪分支限制在与给定的shell glob相匹配的分支。 如果pattern缺少'?'、'{asterisk}'或'['，则末尾的'/{asterisk}'是暗示的。

--glob=<glob-pattern>::
	假设所有与shell glob '<glob-pattern>相匹配的refs在命令行中被列为'<commit>'。前面的'refs/'，如果缺少的话会自动预加。如果模式中缺少'?'、'{asterisk}'或'['，则在结尾处隐含'/{asterisk}'。

--exclude=<glob-pattern>（排除）。::

	不包括匹配"<glob-pattern>"的参考文献，否则下一个`--all`、`--branches`、`--tags`、`--remotes`或`--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、`---branches`、`---tags`、`---remotes`或`---glob`选项（其他选项或参数不清除累积模式）。
+
当应用于"--分支"、"--标签 "或"--远程 "时，给出的模式不应该以 "refs/heads"、"refs/tags "或 "refs/remotes "开头，而当应用于"--glob "或 "all "时，必须以 "refs/"开头。如果打算使用尾部的"/{asterisk}"，必须明确给出。

--reflog::
	假设reflogs提到的所有对象都在命令行中被列为`<commit>`。

--alternate-refs::
	假设所有提到的作为备用仓库的参考提示的对象都列在命令行上。备用资源库是任何资源库，其对象目录在`objects/info/alternates`中指定。 包含的对象集可以通过`core.alternateRefsCommand`等修改。见linkgit:git-config[1]。

--single-worktree::
	默认情况下，当有多个工作树时，所有工作树都会被以下选项检查（见linkgit:git-worktree[1]）：`--all`，`--reflog`和`--indexed-objects`。 这个选项强制它们只检查当前的工作树。

--ignore-missing::
	在看到输入中无效的对象名称时，假装没有给出坏的输入。

ifndef::git-rev-list[]
--bisect::
	假设坏的二分法参考文献`refs/bisect/bad`被列出，并且在命令行中假设它后面是`--not`和好的二分法参考文献`refs/bisect/good-*`。
endif::git-rev-list[]

--stdin::
	除了命令行上列出的'<commit>'之外，还要从标准输入中读取它们。如果看到`--`分隔符，就停止读取提交，开始读取路径以限制结果。

ifdef::git-rev-list[]
--quiet::
	不要打印任何东西到标准输出。 这种形式主要是为了让调用者测试退出状态，看看一系列的对象是否完全连接（或没有）。 它比将stdout重定向到`/dev/null`要快，因为输出不需要被格式化。

--disk-usage::
	抑制正常输出；相反，打印所选提交或对象用于磁盘存储的字节数之和。这相当于用管道将输出写入 `git cat-file --batch-check='%(objectsize:disk)'，只是它的运行速度要快得多（尤其是在使用 `--use-bitmap-index'时）。参见 linkgit:git-cat-file[1] 中的 `CAVEATS` 部分，了解 "磁盘存储 "的限制。
endif::git-rev-list[]

--cherry-mark::
	就像`--cherry-pick`（见下文），但用`=`标记同等的提交，而不是省略，用`+`标记不同等的提交。

--cherry-pick::
	当提交的集合有对称差异时，省略任何与 "另一边 "的另一个提交相同的提交。
+
例如，如果你有两个分支，`A`和`B`，通常的方法是用`--左--右`列出其中一边的所有提交（见下面关于`--左--右`选项的描述）。然而，它显示的是从另一个分支中偷梁换柱的提交（例如，"3rd on b "可能是从分支A中偷梁换柱的）。有了这个选项，这样的提交对将从输出中排除。

--left-only::
--right-only::
	只列出对称性差异各自一侧的提交，即只列出那些通过"--左--右 "标记的"<"或">"。
+
例如，`--cherry-pick --right-only A...B`省略了`B`中那些在`A`中的提交或与`A`中的提交相等的补丁。换句话说，它列出了 "git cherry A B "的 "+"的提交。 更准确地说，`--cherry-pick --right-only --no-merges`可以得到准确的列表。

--cherry::
	`--right-only --cherry-mark --no-merges`的同义词；有助于将输出限制在我们这边的提交，并标记那些已经应用到分叉历史的另一边的提交，`git log --cherry upstream...mybranch`，类似于`git cherry upstream mybranch`。

-g::
--walk-reflogs::
	不走提交祖先链，而走从最近的提交到更早的提交的reflog条目。 使用这个选项时，你不能指定要排除的提交（也就是说，不能使用'{caret}commit'、'commit1...commit2'和'commit1/...commit2'的符号）。
+
在`--pretty`格式下，除了`oneline`和`reference`（由于明显的原因），这将导致输出有两行额外的信息来自reflog。 输出中的reflog代号可以显示为`ref@{Nth}`（其中`Nth`是reflog中的逆序索引）或`ref@{timestamp}`（带有该条目的时间戳），取决于一些规则。
+
--
1. 如果起点被指定为`ref@{Nth}`，显示索引格式。
+
2. 如果起点被指定为`ref@{now}`，显示时间戳格式。
+
3. 如果两者都没有使用，但在命令行中给出了`--date`，则按照`--date`所要求的格式显示时间戳。
+
4. 否则，显示索引格式。
--
+
在`--pretty=oneline`下，提交信息的前缀是同一行中的这些信息。 这个选项不能与 `--reverse`结合使用。 参见 linkgit:git-reflog[1]。
+
在`--pretty=reference`下，这些信息将完全不显示。

--merge::
	在合并失败后，显示触及有冲突的文件且不存在于所有要合并的头的参考文件。

--boundary::
	输出排除的边界提交。边界提交的前缀是"-"。

ifdef::git-rev-list[]
--use-bitmap-index::

	尝试使用包位图索引（如果有的话）来加快遍历的速度。注意，当使用`--对象`进行遍历时，树和blobs不会打印出它们的相关路径。

--progress=<header>。::
	在考虑对象时在stderr上显示进度报告。`<标题>`文本将在每次进度更新时打印。
endif::git-rev-list[]

简化历史
~~~~

有时你只对历史的一部分感兴趣，例如修改某个<路径>的提交。但 "历史简化 "有两部分，一部分是选择提交，另一部分是如何做，因为有各种策略来简化历史。

以下选项选择要显示的提交。

<paths>::
	修改给定<路径>的提交会被选中。

--simplify-by-decoration::
	被某个分支或标签引用的提交被选中。

请注意，可以显示额外的提交，以提供一个有意义的历史。

以下选项会影响简化的执行方式。

Default mode::
	将历史简化为解释树的最终状态的最简单的历史。最简单的原因是，如果最终结果相同，它会修剪一些侧枝（即合并具有相同内容的分支）。

--show-pulls::
	包括默认模式下的所有提交，但也包括任何与第一个父分支不相干但与后来的父分支相干的合并提交。这种模式有助于显示 "首次引入 "某个分支的合并提交。

--full-history::
	与默认模式相同，但不修剪一些历史记录。

--dense::
	只显示所选的提交，再加上一些才有意义的历史。

--sparse::
	简化历史中的所有提交都会显示出来。

--simplify-merges::
	为`--full-history`增加了一个选项，可以从结果的历史中删除一些不必要的合并，因为没有选定的提交对这次合并有贡献。

--ancestry-path::
	当给定一个要显示的提交范围（例如 "commit1...commit2 "或 "commit2 {caret}commit1"）时，只显示直接存在于 "commit1 "和 "commit2 "之间的祖先链的提交，即既是 "commit1 "的后代，又是 "commit2 "的祖先的提交。

以下是更详细的解释。

假设你指定了`foo`作为<paths>。 我们将把修改`foo`的提交称为 !TREESAME，其余的称为 TREESAME。 (在为`foo`过滤的diff中，它们看起来分别是不同的和相同的)。

在下文中，我们将始终引用同一个历史实例来说明简化设置之间的差异。 我们假设你在这个提交图中过滤的是一个文件`foo`。
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /   /
	I     B   C   D   E   Y
	 \   /   /   /   /   /
	  `-------------'   X
-----------------------------------------------------------------------
历史A---Q的横线被认为是每次合并的第一个父本。 这些提交是

* `I`是初始提交，其中`foo`存在，内容是`asdf''，文件`quux`存在，内容是`quux''。初始提交与空树比较，所以`I`是！`TREESAME。

* 在`A`中，`foo`只包含`foo''。

* `B`包含与`A`相同的变化。 它的合并`M`是微不足道的，因此对所有父类来说是TREESAME。

* `C`没有改变`foo`，但是它的合并`N`将其改为`foobar''，所以它与任何父类都不存在TREESAME。

* `D`将`foo`设置为`baz''。它的合并项`O`将`N`和`D`的字符串合并为`foobarbaz''；也就是说，它与任何父类都不是TREESAME。

* `E`将`quux`改为`xyzzy''，其合并的`P`将这些字符串合并为`quux xyzzy''。`P'与`O'的关系是TREESAME，但与`E'不是。

* `X`是一个独立的根提交，添加了一个新文件`side`，`Y`修改了它。`Y`与`X`同为TREESAME。它的合并文件`Q`在`P`上添加了`side`，`Q`与`P`是同源，但与`Y`不是同源。

`rev-list`在历史中倒退，根据是否使用`--full-history`和/或父代重写（通过`--parents`或`--children`），包括或排除提交。以下设置是可用的。

Default mode::
	如果提交的内容与任何父类不相干，则被包括在内（当然这一点可以改变，见下面的`--sparse`）。 如果该提交是一个合并，并且它与一个父类是同源的，则只跟随该父类。 (即使有几个TREESAME父类，也只跟随其中一个。) 否则，跟随所有父类。
+
This results in:
+
-----------------------------------------------------------------------
	  .-A---N---O
	 /     /   /
	I---------D
-----------------------------------------------------------------------
+
请注意，如果有TREESAME父类的话，只遵循TREESAME父类的规则，将`B'完全排除在考虑之外。 `C`是通过`N`考虑的，但也是TREESAME。 根提交是与空树比较的，所以`I`是!!TREESAME。
+
父/子关系只有在`--父母`的情况下才能看到，但这并不影响在默认模式下选择的提交，所以我们显示了父行。

--full-history without parent rewriting::
	这种模式与默认模式有一点不同：总是跟随一个合并的所有父本，即使它与其中一个父本是TREESAME。 即使合并的一方有多个提交被包括在内，这也不意味着合并本身也是如此在这个例子中，我们得到
+
-----------------------------------------------------------------------
	I  A  B  N  D  O  P  Q
-----------------------------------------------------------------------
+
`M'被排除在外，因为它与父母都是TREESAME。 `E'、`C'和`B'都走了，但只有`B'是！"TREESAME"，所以其他的都没有出现。
+
请注意，如果没有父子重写，其实是不可能谈论提交之间的父子关系的，所以我们显示它们是不相连的。

--full-history with parent rewriting::
	普通的提交只有当它们是！TREESAME时才会被包括在内（尽管这一点可以改变，见下面的`--sparse`）。
+
合并总是被包括在内。 然而，他们的父级列表会被重写。沿着每个父级，修剪掉那些不包括自己的提交。 这样做的结果是
+
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /
	I     B   /   D   /
	 \   /   /   /   /
	  `-------------'
-----------------------------------------------------------------------
+
与上面的`--full-history`相比，没有重写。 请注意，`E`被修剪掉了，因为它是TREESAME，但是P的父列表被改写为包含`E`的父`I`。 同样的情况发生在`C`和`N`，以及`X`、`Y`和`Q`。

除了上述设置外，你还可以改变TRESAME是否会影响收录。

--dense::
	如果不与任何父类有TREESAME关系，则包括走过的承诺。

--sparse::
	所有走过的提交都包括在内。
+
请注意，如果没有`--full-history`，这仍然可以简化合并：如果父代之一是TREESAME，我们只跟随这个父代，所以合并的其他方面永远不会被走。

--simplify-merges::
	首先，按照`--full-history`与父级改写的相同方式建立一个历史图（见上文）。
+
然后根据以下规则将每个提交的`C'简化为最终历史中的替换`C'。
+
--
* 将 "C "设为 "C"。
+
* 将`C'`的每个父类`P'替换成其简化的`P'`。 在这个过程中，放弃那些是其他父类的祖先的父类，或者是根部提交TREESAME的空树，并删除重复的父类，但注意不要放弃所有我们是TREESAME的父类。
+
* 如果在这次父级改写之后，`C'`是一个根或合并提交（有0个或>1个父级），一个边界提交，或！TREESAME，那么它将被保留。 否则，它将被替换为其唯一的父类。
--
+
通过与`--full-history`的父级改写进行比较，可以最好地显示其效果。 这个例子变成了。
+
-----------------------------------------------------------------------
	  .-A---M---N---O
	 /     /       /
	I     B       D
	 \   /       /
	  `---------'
-----------------------------------------------------------------------
+
注意`N'、`P'和`Q'与`--full-history'的主要区别。
+
--
* `N`的父列表中删除了`I`，因为它是另一个父`M`的一个祖先。 但是，`N`仍然存在，因为它是!TREESAME。
+
* `P`的父级列表也同样删除了`I`。 然后`P`被完全删除，因为它有一个父本，并且是TREESAME。
+
* `Q`的父列表中有`Y`简化为`X`。然后`X`被删除，因为它是一个TREESAME根。然后`Q`被完全删除，因为它有一个父级，是TREESAME。
--

还有一种简化模式可用。

--ancestry-path::
	将显示的提交限制在给定提交范围内 "from "和 "to "提交之间的直接祖先链上。也就是说，只显示 "to "提交的祖先和 "from "提交的后代的提交。
+
作为一个用例，请考虑以下提交历史。
+
-----------------------------------------------------------------------
	    D--E-------F
	   / \ \
	  B---C---G---H---I---J
	 / \
	A-------K---------------L--M
-----------------------------------------------------------------------
+
有规律的 "D...M "会计算出作为`M`的祖先的提交集合，但不包括作为`D`的祖先的提交。这对了解`M'的历史在`D'之后发生了什么很有用，也就是说`M'有什么东西是`D'没有的'。这个例子中的结果是所有的提交，除了`A`和`B`（当然还有`D`本身）。
+
然而，当我们想找出`M'中哪些提交被`D'引入的错误所污染而需要修复时，我们可能只想查看'D...M'中实际上是`D'的后代的子集，即排除`C'和`K'。这正是`--ancestry-path`选项的作用。应用于'D...M'范围，它的结果是：
+
-----------------------------------------------------------------------
		E-------F
		 \ \
		  G--H--I--J
			       \
				L--M
-----------------------------------------------------------------------

在讨论另一个选项，`--显示--推力'之前，我们需要创建一个新的历史实例。

用户在查看简化历史时经常遇到的一个问题是，他们知道的对某个文件的修改提交并没有出现在该文件的简化历史中。让我们演示一个新的例子，并说明`--full-history`和`--simplify-merges`等选项在这种情况下是如何工作的。

-----------------------------------------------------------------------
	  .-A---M-----C--N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`-Z'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `---Y--'
-----------------------------------------------------------------------

在这个例子中，假设`I`创建了`file.txt`，并被`A`、`B`和`X`以不同方式修改。单亲提交的`C`、`Z`和`Y`没有修改`file.txt`。合并提交 "M "是通过解决合并冲突而产生的，包括了 "A "和 "B "的修改，因此与其中任何一个都不是同源的。然而，合并提交`R`是通过忽略`M`处的`file.txt`的内容，而只采用`X`处的`file.txt`的内容而产生的。因此，`R`与`X`是同源的，但不是`M`。最后，创建`N'的自然合并决议是取`file.txt`在`R'的内容，所以`N'与`R'是同源的，但不是`C'。 合并提交的 "O "和 "P "与它们的第一代父母是同源的，但与它们的第二代父母 "Z "和 "Y "则不是同源的。

当使用默认模式时，`N'和`R'都有一个TREESAME父级，所以这些边被走，其他的被忽略。由此产生的历史图是。

-----------------------------------------------------------------------
	I--X
-----------------------------------------------------------------------

当使用`--full-history`时，Git会行走每条边。这将发现提交`A`和`B`以及合并`M`，但也将揭示合并提交`O`和`P`。通过父级改写，得到的图是。

-----------------------------------------------------------------------
	  .-A---M--------N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`--'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `------'
-----------------------------------------------------------------------

这里，合并提交`O`和`P`带来了额外的噪音，因为它们实际上并没有对`file.txt`做出改变。他们只是合并了一个基于 "file.txt "旧版本的主题。这是在使用工作流程的仓库中常见的问题，在工作流程中，许多贡献者并行工作，并沿着一个主干合并他们的主题分支：不相关的合并出现在`--full-history`结果中。

当使用`--简化合并`选项时，提交的`O`和`P`从结果中消失。这是因为 "O "和 "P "重写的第二父本可以从它们的第一父本到达。这些边被移除，然后这些提交看起来就像与它们的父类一样的单亲提交。这也发生在提交`N`上，导致历史视图如下。

-----------------------------------------------------------------------
	  .-A---M--.
	 /     /    \
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------

在这个视图中，我们看到了所有来自`A`，`B`和`X`的重要单亲变化。我们还可以看到仔细解决的合并`M`和不那么仔细解决的合并`R`。这些信息通常足以确定为什么`A`和`B`的提交在默认视图中从历史中 "消失 "了。然而，这种方法也有一些问题。

第一个问题是性能。与之前的任何选项不同，`--简化合并'选项需要在返回一个结果之前走完整个提交历史。这可能使该选项难以用于非常大的仓库。

第二个问题是审计的问题。当许多贡献者在同一个版本库中工作时，哪些合并提交将一个变化引入到一个重要的分支是很重要的。上面有问题的合并`R`不可能是用来合并到一个重要分支的合并提交。相反，`N'是用来将`R'和`X'合并到重要分支的。这个提交可能有关于为什么`X'会覆盖`A'和`B'的修改的信息，在其提交信息中。

--show-pulls::
	除了在默认历史中显示的提交之外，还要显示每一个与第一个父本不相同但与后来的父本相同的合并提交。
+
当一个合并提交被`--show-pulls`包含时，该合并被视为从另一个分支 "拉 "来的修改。在这个例子中使用`--show-pulls`时（没有其他选项），得到的图表是。
+
-----------------------------------------------------------------------
	I--X--R--N
-----------------------------------------------------------------------
+
这里，合并后的提交`R`和`N`被包括在内，因为它们分别将提交`X`和`R`拉到了基础分支。这些合并是`A`和`B`的提交没有出现在默认历史中的原因。
+
当`--show-pulls`与`--simplify-merges`配对时，该图包括所有必要的信息。
+
-----------------------------------------------------------------------
	  .-A---M--.   N
	 /     /    \ /
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------
+
请注意，由于`M`可以从`R`到达，从`N`到`M`的边被简化掉了。然而，`N`仍然作为一个重要的提交出现在历史中，因为它把`R`的修改 "拉 "进了主分支。

`--按装饰简化'选项允许你只查看历史拓扑的全貌，省略那些没有被标签引用的提交。 如果(1)提交被标签引用，或者(2)提交改变了命令行上给出的路径内容，则被标记为！TREESAME（换句话说，按照上述历史简化规则保留）。 所有其他的提交都被标记为TREESAME（会被简化掉）。

ifndef::git-shortlog[]
ifdef::git-rev-list[]
剖腹产助手
~~~~~

--bisect::
	将输出限制在一个提交对象上，该对象大致在包含和排除的提交之间。请注意，坏的分界参考`refs/bisect/bad`会被添加到包含的提交中（如果它存在的话），好的分界参考`refs/bisect/good-*`会被添加到排除的提交中（如果它们存在的话）。因此，假设`refs/bisect/`中没有参考文献，如果
+
-----------------------------------------------------------------------
	$ git rev-list --bisect foo ^bar ^baz
-----------------------------------------------------------------------
+
输出'midpoint'，即两个命令的输出。
+
-----------------------------------------------------------------------
	$ git rev-list foo ^midpoint
	$ git rev-list midpoint ^bar ^baz
-----------------------------------------------------------------------
+
的长度大致相同。 因此，找到引入回归的变化就变成了一个二进制搜索：反复生成和测试新的 "中点"，直到提交链的长度为1。

--bisect-vars::
	这与`--bisect`的计算方法相同，只是不使用`refs/bisect/`中的参考文献，而且输出的文本可以被shell评估。这几行将把中点修订的名称分配给变量`bisect_rev`，并把`bisect_rev`测试后的预期提交数分配给`bisect_nr`。如果`bisect_rev'结果是好的，预计测试的提交数量为`bisect_good'，如果`bisect_rev'结果是坏的，预计测试的提交数量为`bisect_bad'，以及我们现在正在分叉的提交数量为`bisect_all'。

--bisect-all::
	这将输出包含的提交和排除的提交之间的所有提交对象，按照它们与包含的提交和排除的提交的距离排序。`refs/bisect/`中的参考文献不被使用。离它们最远的会先显示出来。这也是`--bisect`唯一显示的对象）。
+
这很有用，因为当你因为某些原因想避免测试某些提交时（例如，它们可能无法编译），可以很容易地选择一个好的提交来测试。
+
这个选项可以和`--bisect-vars`一起使用，在这种情况下，在所有排序的提交对象之后，会有和`--bisect-vars`单独使用一样的文本。
endif::git-rev-list[]
endif::git-shortlog[]

ifndef::git-shortlog[]
承诺订购
~~~~

默认情况下，提交的内容是按时间顺序倒序显示的。

--date-order::
	在显示所有子代之前不显示父代，否则按提交时间戳顺序显示提交。

--author-date-order::
	在显示所有子代之前不显示父代，否则按作者时间戳顺序显示提交。

--topo-order::
	在显示所有子代之前不显示父代，并避免显示多行历史交错的提交。
+
例如，在这样的一个提交历史中。
+
----------------------------------------------------------------

    ---1----2----4----7
	\	       \
	 3----5----6----8---

----------------------------------------------------------------
+
其中数字表示提交时间戳的顺序，`git rev-list`和带有`--date-order`的朋友显示提交的时间戳顺序。8 7 6 5 4 3 2 1.
+
如果使用`--topo-order`，它们会显示8 6 5 3 7 4 2 1（或8 7 4 2 6 5 3 1）；一些较早的提交会显示在较新的提交之前，以避免显示两个平行开发轨道的提交混在一起。

--reverse::
	以相反的顺序输出选择显示的提交（见上面的提交限制部分）。不能与`--walk-reflogs`结合使用。
endif::git-shortlog[]

ifndef::git-shortlog[]
对象遍历
~~~~

这些选项主要是针对Git存储库的打包。

ifdef::git-rev-list[]
--objects::
	打印列出的提交对象所引用的任何对象的ID。 `--objects foo ^bar`因此意味着`给我发送所有我需要下载的对象ID，如果我有提交对象_bar_但没有_foo_的话'。

--in-commit-order::
	按照提交的顺序打印树和blob的id。树和blob的id会在它们第一次被提交者引用后打印。

--objects-edge::
	类似于 `--objects`，但也会打印被排除的提交物的 ID，前缀为 `-''字符。 这被 linkgit:git-pack-objects[1] 用来建立一个 "瘦身 "包，它基于这些被排除的提交中包含的对象，以删除的形式记录对象，以减少网络流量。

--objects-edge-aggressive::
	类似于 `--objects-edge`，但它更努力地寻找被排除的提交，代价是增加时间。 它被用来代替`--objects-edge`，为浅层仓库建立 "薄 "的包。

--indexed-objects::
	假设索引使用的所有树和blobs都列在命令行中。 注意，你可能也想使用`--objects`。

--unpacked::
	只对`---对象`有用；打印不在包中的对象ID。

--object-names::
	只对`---对象`有用；打印找到的对象ID的名称。这是默认行为。

--no-object-names::
	只对`--对象`有用；不打印找到的对象ID的名称。这与`--object-names`相反。这个标志允许输出更容易被linkgit:git-cat-file[1]等命令解析。

--filter=<filter-spec>::
	只对其中一个`--objects*`有用；从打印对象列表中省略对象（通常是blobs）。 <filter-spec>'可以是下列之一。
+
'--filter=blob:none'的形式可以省略所有的blob。
+
'--filter=blob:limit=<n>[kmg]'的形式可以省略大于n个字节或单位的blob，n可以是0。 后缀k、m和g可以用来命名KiB、MiB或GiB等单位。 例如，'blob:limit=1k'和'blob:limit=1024'是一样的。
+
'--filter=object:type=(tag|commit|tree|blob)'的形式会省略所有不属于请求类型的对象。
+
The form '--filter=sparse:oid=<blob-ish>' uses a sparse-checkout specification contained in the blob (or blob-expression) '<blob-ish>' to omit blobs that would not be required for a sparse checkout on the requested refs.
+
'--filter=tree:<depth>'的形式省略了所有从根树开始深度>=<depth>（如果一个对象在所穿越的提交中位于多个深度，则为最小深度）的blobs和树。<depth>=0 将不包括任何树或blobs，除非在命令行中明确包括（或使用-stdin时的标准输入）。<depth>=1 将只包括由<commit>或明确指定的对象所能到达的提交直接引用的树和blobs。<深度>=2与<深度>=1类似，同时也包括从明确给出的提交或树中移出的多一级的树和blobs。
+
注意，出于安全原因，想要从文件系统上的任意路径读取的'--过滤器=sparse:path=<path>'形式已经被放弃了。
+
可以指定多个'--过滤器='标志来组合过滤器。只有那些被每个过滤器接受的对象才会被包括在内。
+
The form '--filter=combine:<filter1>+<filter2>+...<filterN>' can also be used to combined several filters, but this is harder than just repeating the '--filter' flag and is usually not necessary. Filters are joined by '{plus}' and individual filters are %-encoded (i.e. URL-encoded). Besides the '{plus}' and '%' characters, the following characters are reserved and also must be encoded: `~!@#$^&*()[]{}\;",<>?`+&#39;&#96;+
as well as all characters with ASCII code &lt;= `0x20`, which includes space and newline.
+
其他任意的字符也可以被编码。例如，'combined:tree:3+blob:none'和'combined:tree%3A3+blob%3Anone'是等同的。

--no-filter::
	关掉之前的任何`--filter=`参数。

--filter-provided-objects::
	过滤明确提供的对象的列表，否则，即使它们不符合任何过滤器，也会被打印出来。只对`--filter=`有用。

--filter-print-omitted::
	只对`--filter=`有用；打印出被过滤器省略的对象的列表。 对象ID的前缀是``~''字符。

--missing=<missing-action>（缺失）。::
	一个调试选项，帮助未来的 "部分克隆 "开发。 这个选项指定了如何处理丢失的对象。
+
形式'--missing=error'要求rev-list在遇到丢失的对象时以错误方式停止。 这是默认动作。
+
'--missing=allow-any'的形式将允许在遇到缺失对象时继续进行对象遍历。 缺少的对象将被默默地从结果中省略掉。
+
'--missing=allow-promisor'的形式与'allow-any'相似，但只允许对预期的promisor缺失对象继续进行遍历。 意外的缺失对象将引发一个错误。
+
'--missing=print'的形式与'allow-any'相似，但也会打印出遗失对象的列表。 对象ID的前缀是"？"。

--exclude-promisor-objects::
	仅供内部使用。）在希望者边界预过滤对象的遍历。 这是与部分克隆一起使用的。 这比`--missing=allow-promisor`更强，因为它限制了遍历，而不仅仅是消除了关于丢失对象的错误。
endif::git-rev-list[]

--no-walk[=(sorted|unsorted)]::
	Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument `unsorted` is given, the commits are shown in the order they were given on the command line. Otherwise (if `sorted` or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with `--graph`.

--do-walk::
	覆盖之前的`--不走'。
endif::git-shortlog[]

ifndef::git-shortlog[]
承诺格式化
~~~~~

ifdef::git-rev-list[]
使用这些选项，linkgit:git-rev-list[1] 的作用类似于更专业的提交日志工具系列：linkgit:git-log[1]，linkgit:git-show[1]，和linkgit:git-whatchanged[1] 。
endif::git-rev-list[]

include::pretty-options.txt[]

--relative-date::
	`--date=relative`的同义词。

--date=<format>::
	只对以人类可读格式显示的日期生效，例如使用`--pretty`时。`log.date`配置变量为日志命令的`--date`选项设置默认值。默认情况下，日期显示在原始时区（提交者或作者的时区）。如果`-local`被附加到格式中（例如，`iso-local`），就会使用用户的本地时区。
+
--
`--date=relative`显示相对于当前时间的日期，例如：`2小时前''。`--local`选项对`--date=relative`没有影响。

`--date=local`是`--date=default-local`的一个别名。

`--date=iso`（或`--date=iso8601`）以类似ISO 8601的格式显示时间戳。 与严格的ISO 8601格式的区别是。

	- 用空格代替`T`日期/时间分隔符
	- 时间和时区之间的空间
	- 时区的小时和分钟之间没有冒号

`--date=iso-strict`（或`--date=iso8601-strict`）显示严格的ISO 8601格式的时间戳。

`--date=rfc`（或`--date=rfc2822`）显示RFC 2822格式的时间戳，经常出现在电子邮件中。

`--date=short`只显示日期，而不是时间，格式为`YYYY-MM-DD`。

`--date=raw`显示日期为自纪元以来的秒数（1970-01-01 00:00:00 UTC），后面是空格，然后是时区为UTC的偏移量（一个`+`或`-`的四位数字；前两位是小时，后两位是分钟）。也就是说，就像时间戳的格式为`strftime("%s %z")`)。 请注意，`-local`选项不影响自始至终的秒数值（它总是以UTC为单位），但会切换伴随的时区值。

`--date=human`如果时区与当前时区不匹配，则显示时区，如果匹配则不打印整个日期（即对于 "今年 "的日期，跳过打印年份，但如果是最近几天的日期，也跳过整个日期本身，我们可以只说是哪个工作日）。 对于较早的日期，小时和分钟也被省略了。

`--date=unix`显示日期为Unix纪元时间戳（自1970年以来的秒数）。 与`--raw`一样，这总是以UTC为单位，因此`--local`没有影响。

`--date=format:...` feeds the format `...` to your system `strftime`, except for %s, %z, and %Z, which are handled internally. Use `--date=format:%c` to show the date in your system locale's preferred format. See the `strftime` manual for a complete list of format placeholders. When using `-local`, the correct syntax is `--date=format-local:...`.

`--date=default`是默认格式，与`--date=rfc2822`类似，但有一些例外。
--
	- 在星期的后面没有逗号

	- 当使用本地时区时，省略了时区。

ifdef::git-rev-list[]
--header::
	以原始格式打印提交的内容；每条记录用NUL字符分隔。

--no-commit-header::
	抑制包含“提交”的标题行和在指定格式之前打印的对象 ID。这对内置格式没有影响；只有自定义格式会受到影响。

--commit-header::
	Overrides a previous `--no-commit-header`.
endif::git-rev-list[]

--parents::
	也可以打印提交的父类（以 "提交父类... "的形式）。 也可以启用父级改写，见上面的 "历史简化"。

--children::
	同时打印提交的子项（以 "提交子项... "的形式）。 也可以启用父级改写，见上面的 "历史简化"。

ifdef::git-rev-list[]
--timestamp::
	打印原始提交时间戳。
endif::git-rev-list[]

--left-right::
	标明提交可以从对称性差异的哪一边到达。 左边的提交以`<`为前缀，右边的则以`>`为前缀。 如果与"--边界 "结合，这些提交的前缀为"-"。
+
例如，如果你有这样的拓扑结构。
+
-----------------------------------------------------------------------
	     y---b---b  branch B
	    / \ /
	   /   .
	  /   / \
	 o---x---a---a  branch A
-----------------------------------------------------------------------
+
你会得到这样的输出。
+
-----------------------------------------------------------------------
	$ git rev-list --left-right --boundary --pretty=oneline A...B

	>bbbbbbb... 3rd on b
	>bbbbbbb... 2nd on b
	<aaaaaaa... 3rd on a
	<aaaaaaa... 2nd on a
	-yyyyyyy... 1st on b
	-xxxxxxx... 1st on a
-----------------------------------------------------------------------

--graph::
	在输出的左手边绘制基于文本的提交历史图表。 这可能会导致在提交之间打印出额外的行，以便正确地绘制图形历史。 不能与`--no-walk`结合使用。
+
这可以使父代改写，见上面的'历史简化'。
+
这意味着默认情况下是`--topo-order`选项，但也可以指定`--date-order`选项。

--show-linear-break[=<barrier>]::
	如果不使用 --graph，所有的历史分支都会被压扁，这就很难看出两个连续的提交并不属于一个线性分支。在这种情况下，该选项会在它们之间设置一个障碍。如果指定了"<barrier>"，就会显示这个字符串，而不是默认的。

ifdef::git-rev-list[]
--count::
	打印一个数字，说明有多少提交会被列出，并抑制所有其他输出。 当与`--左--右'一起使用时，会打印左和右的提交计数，用制表符分开。当与`--cherry-mark`一起使用时，从这些计数中省略补丁等价提交，而打印等价提交的计数，用tab分隔。
endif::git-rev-list[]
endif::git-shortlog[]
