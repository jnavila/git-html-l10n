git-mv(1)
=========

名称
--
git-mv - 移动或重命名一个文件、一个目录或一个符号链接


概述
--
[verse]
'git mv' [<options>] <source>... <destination>

描述
--
移动或重命名一个文件、目录或符号链接。

 git mv [-v] [-f] [-n] [-k] <来源> <目的地>。
 git mv [-v] [-f] [-n] [-k] <source> ...<目的地>目录

在第一种形式中，它将<source>重命名为<destination>，它必须存在并且是一个文件、符号链接或目录。 在第二种形式中，最后一个参数必须是一个现有的目录；给定的源将被移到这个目录中。

索引在成功完成后被更新，但变化仍必须被提交。

选项
--
-f::
--force::
	Force renaming or moving of a file even if the <destination> exists.
-k::
	跳过会导致错误情况的移动或重命名操作。当一个源文件既不存在也不被Git控制，或者它将覆盖一个现有的文件时，就会发生错误，除非给出`-f`。
-n::
--dry-run::
	什么都不做；只显示会发生什么

-v::
--verbose::
	当文件被移动时，报告它们的名称。

子模块
---
使用 gitfile 移动一个子模块（这意味着它们是用 1.7.8 或更新的 Git 版本克隆的）将更新 gitfile 和 core.worktree 设置以使子模块在新的位置工作。 它也会尝试更新linkgit:gitmodules[5]文件中的submodule.<name>.path设置，并将该文件放入舞台（除非使用-n）。

漏洞
--
每次超级项目更新移动一个已填充的子模块（例如，当在移动前后的提交之间切换时），一个陈旧的子模块检出将保留在旧的位置，一个空目录将出现在新的位置。要在新的位置再次填充子模块，用户将不得不在之后运行 "git submodule update"。移除舊目錄只有在使用 gitfile 時才是安全的，否則子模塊的歷史也會被刪除。当递归子模块更新被实施后，这两个步骤将被淘汰。

GIT
---
属于 linkgit:git[1] 文档
