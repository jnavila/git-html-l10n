<仓库>::
	作为获取或拉动操作的来源的 "remote" 仓库。 这个参数可以是一个 URL（见下面 <<URLS,GIT URLS>> 一节），也可以是一个远程仓库的名称（见下面 <<REMOTES,远程>> 一节）。

ifndef::git-pull[]
<组>::
	指向仓库列表的名称，作为配置文件中 remotes.<组> 的值。 (参见 linkgit:git-config[1]）。
endif::git-pull[]

<引用规范>::
	指定要获取哪些引用，以及要更新哪些本地引用。 当命令行上没有出现 <引用规范> 时，将从`remote.<仓库>.fetch` 变量中读取要获取的引用
ifndef::git-pull[]
	(参见下文 <<CRTB,配置的远程跟踪分支机构>> )。
endif::git-pull[]
ifdef::git-pull[]
	(参见 linkgit:git-fetch[1] 中
	 “配置远程跟踪分支” 一节）。
endif::git-pull[]
+
The format of a <refspec> parameter is an optional plus `+`, followed by the source <src>, followed by a colon `:`, followed by the destination <dst>. The colon can be omitted when <dst> is empty. <src> is typically a ref, or a glob pattern with a single `*` that is used to match a set of refs, but it can also be a fully spelled hex object name.
+
A <refspec> may contain a `*` in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the pattern. A pattern <refspec> must have one and only one `*` in both the <src> and <dst>. It will map refs to the destination by replacing the `*` with the contents matched from the source.
+
如果一个 引用规范的前缀是 `^`，它将被解释为一个负向引用规范。这样的引用规范不是指定要获取哪些引用或更新哪些本地引用，而是指定要排除的引用。如果一个引用至少与一个正向引用规范匹配，并且不与任何负向引用规范匹配，那么该引用将被视为匹配。负向引用规范可以用来限制引用规范匹配的范围，使其不包括特定的引用。 负向引用规范本身可以是模式引用规范。然而，它们可能只包含一个 <src>，而不指定一个 <dst>。完全拼出的十六进制对象名称也不被支持。
+
`tag <标签>`的意思与`refs/tags/<标签>:refs/tags/<标签>` 相同；它要求获取到给定标签的所有内容。
+
获取与 <src> 相匹配的远程引用，如果 <dst> 不是一个空字符串，就会尝试更新与之相匹配的本地引用。
+
该更新是否允许不使用 `--force`，取决于它被获取的引用命名空间、被获取的对象的类型，以及该更新是否被认为是一个快速合并。一般来说，获取的规则与推送的规则相同，参见 linkgit:git-push[1] 的 `<引用规范>...' 部分。以下是 "git fetch" 特殊规则的例外情况。
+
在 Git 2.20 版本之前，与使用 linkgit:git-push[1] 推送时不同，任何对 `refs/tags/*` 的更新都会被接受，在引用规范中没有 `+`（或`--force`）。在获取的时候，我们把所有来自远程的标签更新都视为强制获取。 从 Git 2.20 版本开始，获取更新 `refs/tags/*` 的方式与推送时相同。也就是说，任何在引用规范中没有 `+` 的更新都会被拒绝（或`--force`）。
+
与使用 linkgit:git-push[1] 推送时不同，任何在 `refs/{tags,heads}/*` 之外的更新都会被接受，在引用规范中没有 `+`（或 `--force`），无论是将目录树对象换成二进制文件，还是将一个提交换成另一个没有前一个提交作为祖先的提交等等。
+
与使用 linkgit:git-push[1] 推送时不同，没有任何配置可以修改这些规则，也没有类似于 `pre-receive` 的 `pre-fetch` 钩子。
+
就像用 linkgit:git-push[1] 推送一样，上面描述的所有关于不允许更新的规则都可以通过在引用规范中添加一个可选的前导词 `+` 来覆盖（或者使用 `--force` 命令行选项）。唯一的例外是，无论如何强制都不能使 `refs/heads/*` 命名空间接受一个非提交对象。
+
[NOTE]
当你想获取的远程分支已知会被定期回溯和重定向时，预计它的新提示不会是其先前提示的后代（如你上次获取时存储在远程跟踪分支中的提示）。 你应该使用 `+` 号来表示对这类分支需要进行非快速合并式更新。 没有办法确定或声明一个分支将以这种行为在仓库中提供；拉取的用户只是必须知道这是一个分支的预期使用模式。
ifdef::git-pull[]
+
[NOTE]
在 'git pull' 命令行上直接列出多个 <引用规范> 和在 <仓库> 的配置中拥有多个`remote.<仓库>.fetch` 条目以及在没有任何明确的 <引用规范> 参数的情况下运行 'git pull' 命令是有区别的。 在命令行上明确列出的 <引用规范> 在获取后总是被合并到当前分支。 换句话说，如果你列出一个以上的远程引用，'git pull' 将创建一个多路合并。 另一方面，如果你没有在命令行中列出任何明确的 <引用规范> 参数，'git pull' 将获取它在 `remote.<仓库>.fetch` 配置中发现的所有 <引用规范>，并且只将发现的第一个<引用规范> 合并到当前分支。 这是因为很少有人从远程引用中多路合并，而通过获取多个远程头来一次性跟踪多个远程头往往是有用的。
endif::git-pull[]
