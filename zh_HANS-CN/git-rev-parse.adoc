git-rev-parse(1)
================

名称
--
git-rev-parse - 挑选并调整参数


概述
--
[verse]
'git rev-parse' [<options>] <arg>...

描述
--

Many Git porcelainish commands take a mixture of flags (i.e. parameters that begin with a dash '-') and parameters meant for the underlying 'git rev-list' command they use internally and flags and parameters for the other commands they use downstream of 'git rev-list'. The primary purpose of this command is to allow calling programs to distinguish between them. There are a few other operation modes that have nothing to do with the above "help parse command line options".

除非另有说明，大多数选项和操作模式要求您在 git 仓库内部或由 git 仓库控制的个工作树中运行此命令，否则将给出致命错误。


选项
--

操作模式
~~~~

这些选项都必须在命令行中首先出现。

--parseopt::
	在选项解析模式下使用 'git rev-parse'（参见下面的 PARSEOPT 部分）。在此模式下，即使不在仓库内部或由仓库控制的工作树中，也可以使用该命令。

--sq-quote::
	Use 'git rev-parse' in shell quoting mode (see SQ-QUOTE section below). In contrast to the `--sq` option below, this mode only does quoting. Nothing else is done to command input. The command in this mode can be used outside a repository or a working tree controlled by a repository.

--parseopt 的选项
~~~~~~~~~~~~~~

--keep-dashdash::
	仅在 `--parseopt` 模式下有效。告诉选项解析器回显第一个`--` 而不是跳过它。

--stop-at-non-option::
	仅在 `--parseopt` 模式下有效。 让选项解析器在第一个非选项参数时停止。 这可用于解析本身包含选项的子命令。

--stuck-long::
	仅在 `--parseopt` 模式下有效。如果有的话，以长形式输出选项，并保留参数。

筛选选项
~~~~

--revs-only::
	不输出与 'git rev-list' 命令无关的标志和参数。

--no-revs::
	不输出用于 'git rev-list' 命令的标志和参数。

--flags::
	不输出非标志参数。

--no-flags::
	不输出标记参数。

输出选项
~~~~

--default <参数>::
	如果用户没有提供参数，则使用 `<参数>` 代替。

--prefix <参数>::
	就像从工作树的 `<参数>` 子目录调用 'git rev-parse'一样。 任何相对文件名都会被解析为以 `<参数>` 为前缀，并以这种形式打印。
+
这可用于转换在子目录中运行的命令的参数，以便在移动到仓库顶层后仍可使用。 例如：
+
----
prefix=$(git rev-parse --show-prefix)
cd "$(git rev-parse --show-toplevel)"
# rev-parse 提供 'set' 所需的 --
eval "set $(git rev-parse --sq --prefix "$prefix" -- "$@")"
----

--verify::
	验证是否正好提供了一个参数，并且该参数可以转化为原始的 20 字节 SHA-1 用于访问对象数据库。如果可以，则将其输出到标准输出；否则，出错。
+
如果您想确保输出结果确实命名了对象数据库中的对象，并且/或者可以用作您需要的特定类型的对象，您可以在参数中添加 `^{type}` 剥离运算符。 例如，`git rev-parse "$VAR^{commit}"` 将确保 `$VAR` 命名的现有对象是一个类似提交的对象（即一个提交，或一个指向提交的注释标记）。 要确保 `$VAR` 命名的是任何类型的现有对象，可以使用 `git rev-parse "$VAR^{object}"。
+
请注意，如果要验证来自不可信来源的名称，最好使用 `--end-of-options`，以免名称参数被误认为其他选项。

-q::
--quiet::
	仅在 `--verify` 模式下有效。如果第一个参数不是有效的对象名，则不输出错误信息；而是以非零状态无声退出。 成功时，有效对象名称的 SHA-1 会打印到标准输出流。

--sq::
	通常情况下，每个标志和参数的输出为一行。 该选项使输出成为单行，并适当加引号供 shell 使用。 当你希望你的参数包含空格和换行符时（例如在使用 pickaxe `-S` 和 'git diff-{asterisk}'时），这个选项很有用。与 `--sq-quote` 选项相反，命令输入仍按常规解释。

--short[=<length>]::
	与 `--verify` 模式相同，但会将对象名称缩短为至少包含 `长度` 字符的唯一前缀。最小长度为 4，默认值为配置变量 `core.abbrev` 的有效值（参见 linkgit:git-config[1]）。

--not::
	显示对象名称时，以 '{caret}' 作为前缀，并从已有前缀的对象名称中去掉 '{caret}'。

--abbrev-ref[=(strict|loose)]::
	对象名称的非含混简称。 选项 core.warnAmbiguousRefs 用于选择严格缩写模式。

--symbolic::
	通常情况下，对象名称以 SHA-1 形式输出（可能带有 '{caret}' 前缀）；该选项使其输出形式尽可能接近原始输入。

--symbolic-full-name::
	这与 --symbolic 类似，但它会省略非引用输入（即分支或标记名称；或更明确的消歧义 "heads/master" 形式，当你想命名 "master" 分支时，却有一个不幸命名为 "master" 的标记），而显示为完整的引用名称（例如 "refs/heads/master"）。

--output-object-format=(sha1|sha256|storage)::

	允许从当前仓库支持的任何对象格式输入对象 ID（oids）。

	指定 "sha1" 会进行必要的转换并返回一个 sha1 对象 ID（oid）。

	指定 "sha256" 会进行必要的转换并返回一个 sha256 对象 ID（oid）。

	指定 "storage" 会进行必要的转换并返回一个使用存储哈希算法编码的对象 ID（oid）。

对象选项
~~~~

--all::
	显示在 `refs/` 中找到的所有引用。

--branches[=<模式>]::
--tags[=<模式>]::
--remotes[=<模式>]::
	分别显示所有分支、标记或远程跟踪分支（即分别在 `refs/heads`、`refs/tags` 或 `refs/remotes`中找到的引用）。
+
如果给定了 `pattern`, 则只显示与给定 shell glob 匹配的引用。 如果模式不包含 globing 字符（ `?`、 `*` 或 `[` ），则通过添加 `/*` 将其转换为前缀匹配。

--glob=<pattern>::
	显示与 shell glob 模式 `模式` 匹配的所有引用。如果模式不以 `refs/` 开头，则会自动预输入。 如果模式不包含 globing 字符（ `?` 、 `*` 或 `[` ），则会通过添加 `/*` 将其转换为前缀匹配。

--exclude=<通配符模式>::
	不包括匹配"<glob-pattern>"的参考文献，否则下一个`--all`、`--branches`、`--tags`、`--remotes`或`--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、`---branches`、`---tags`、`---remotes`或`---glob`选项（其他选项或参数不清除累积模式）。
+
当应用于 `--branches`、 `--tags` 或 `--remotes` 时，所给出的模式不应以 `refs/heads`、`refs/tags` 或 `refs/remotes` 开头；当应用于 `--glob` 或 `--all` 选项时，必须以 `refs/` 开头。如果要使用尾部的 '/{asterisk}'，则必须明确给出。

--exclude-hidden=(fetch|receive|uploadpack)::
	通过查阅相应的 `fetch.hideRefs` 、`receive.hideRefs` 或 `uploadpack.hideRefs` 配置和 `transfer.hideRefs` 配置（参见 linkgit:git-config[1]），不要包含会被 `git-fetch` 、`git-receive-pack` 或 `git-upload-pack` 隐藏的引用。该选项会影响下一个伪引用选项 `--all` 或 `--glob`，并在处理后清除。

--disambiguate=<前缀>::
	显示名称以给定前缀开头的所有对象。 <前缀> 的长度必须至少为 4 个十六进制数字，以避免错误地列出仓库中的每个对象。

文件选项
~~~~

--local-env-vars::
	列出仓库本地的 GIT_* 环境变量（例如 GIT_DIR 或 GIT_WORK_TREE，但不包括 GIT_EDITOR）。 只列出变量名，不列出变量值，即使变量已被设置。

--path-format=(absolute|relative)::
	控制某些其他选项的行为。如果指定为绝对路径，这些选项打印的路径将是绝对和规范的。如果指定为相对路径，路径将相对于当前工作目录（如果可能）。 默认情况下，路径将与选项相关。
+
该选项可以多次指定，并且只影响命令行中该选项后面的参数，要么影响到命令行的末尾，要么影响到该选项的下一个实例。

以下选项会被 `--path-format` 修改：

--git-dir::
	如果已定义，则显示 `$GIT_DIR`。否则显示 .git 目录的路径。如果是相对路径，则显示当前工作目录的相对路径。
+
如果未定义 `$GIT_DIR`，且未检测到当前目录位于 Git 仓库或工作区中，则向标准错误流打印一条信息，并以非零状态退出。

--git-common-dir::
	如果定义了 `$GIT_COMMON_DIR`，则显示 `$GIT_COMMON_DIR` ，否则显示 `$GIT_DIR`。

--resolve-git-dir <路径>::
	检查 <路径> 是否为有效的版本库或指向有效仓库的 gitfile，并打印仓库的位置。 如果 <路径> 是 gitfile，则打印指向真实仓库的解析路径。

--git-path <路径>::
	解析 "$GIT_DIR/<路径>"，并考虑其他路径重定位变量，如 $GIT_OBJECT_DIRECTORY、$GIT_INDEX_FILE...。例如，如果 $GIT_OBJECT_DIRECTORY 设置为 /foo/bar，那么 "git rev-parse --git-path objects/abc" 就会返回 /foo/bar/abc。

--show-toplevel::
	显示工作树顶层目录的路径（默认为绝对路径）。如果没有工作区，则会报错。

--show-superproject-working-tree::
	显示使用当前仓库作为子模块的父项目工作区（如果存在）根目录的绝对路径。 如果当前仓库未被任何项目用作子模块，则不输出任何内容。

--shared-index-path::
	在分割索引模式下显示共享索引文件的路径，如果不在分割索引模式下则显示空路径。

以下选项不受 `--path-format` 影响：

--absolute-git-dir::
	类似于 `--git-dir`，但其输出始终是规范化的绝对路径。

--is-inside-git-dir::
	当当前工作目录低于仓库目录时，打印 "true"，否则打印 "false"。

--is-inside-work-tree::
	当当前工作目录位于仓库工作区内时，打印 "true"，否则打印 "false"。

--is-bare-repository::
	当仓库为裸仓库时，打印 "true"，否则打印 "false"。

--is-shallow-repository::
	当仓库是浅克隆时打印 "true"，否则打印 "false"。

--show-cdup::
	从子目录调用命令时，显示顶层目录相对于当前目录的路径（通常是 ".../" 序列或空字符串）。

--show-prefix::
	从子目录调用命令时，显示当前目录相对于顶层目录的路径。

--show-object-format[=(storage|input|output)]::
	显示用于存储在 `.git` 目录内、输入或输出的仓库的对象格式（散列算法）。对于输入，可打印多种算法，以空格分隔。 如果未指定，默认为 “存储”。

--show-ref-format::
	显示仓库使用的参考存储格式。


其他选项
~~~~

--since=<datestring>::
--after=<datestring>::
	解析日期字符串，并为 'git rev-list' 输出相应的 --max-age= 参数。

--until=<datestring>::
--before=<datestring>::
	解析日期字符串，并为 'git rev-list' 输出相应的 --min-age= 参数。

<arg>...::
	要解析的标志和参数。


include::revisions.adoc[]

PARSEOPT
--------

在 `--parseopt` 模式下，'git rev-parse' 可以帮助处理选项，为 shell 脚本带来与 C 语言内置程序相同的功能。它可以作为一个选项规范化器工作（例如分割单值和总值），有点像 `getopt(1)`。

它在标准输入端接收要解析和理解的选项说明，并在标准输出端回声一个适合 `sh(1)` `eval` 的字符串，以便用规范化参数替换参数。 如果出现错误，它会在标准错误流中输出使用情况，并以代码 129 退出。

注意：在将结果传递给 `eval` 时，请务必加上引号。 请参阅下面的示例。

输入格式
~~~~

'git rev-parse --parseopt' 输入格式完全基于文本。它由两部分组成，中间用只包含 `--` 的行隔开。分隔符前的几行（应为一行或多行）用于说明用法。 分隔符之后的行描述选项。

每行选项的格式如下：

------------
<指定选项><标记>*<参数提示>? SP+ help LF
------------

`<opt-spec>`::
	其格式是短选项字符，然后是用逗号分隔的长选项名称。两部分都不是必需的，但至少有一部分是必需的。不得包含任何 `<标记>` 字符。 `h,help` 、 `dry-run` 和 `f` 是正确的 `<指定选项>` 的例子。

`<标志>`::
	`<标志>` 是 `*`, `=`, `?` 或 `!` 其中一个。
	* 如果选项需要一个参数，则使用 `=`。

	* 使用 `?` 表示选项包含一个可选参数。你可能希望使用 `--stuck-long` 模式来明确地解析可选参数。

	* 使用 `*` 表示该选项不应列在为 `-h` 参数生成的用法中。linkgit:gitcli[7] 中记录了 `--help-all` 的用法。

	* 使用 `!` 不提供相应的否定长选项。

`<参数提示>`::
	如果指定了 `<arg-hint>`，则在帮助输出中用作参数的名称。`<arg-hint>` 以第一个空格结束。 通常使用破折号分隔多字参数提示中的单词。

去掉空格后的剩余部分将用作与该选项相关的帮助。

空行将被忽略，不符合此规范的行将用作选项组标题（以空格开头，以便有意创建此类行）。

示例
~~

------------
OPTS_SPEC="\
some-command [<选项>] <参数>...

some-command 会执行 foo 和 bar!
--
h,help! 显示帮助

foo 一些简便的选项 --foo bar= 一些很酷的选项 --bar 带着一个参数 baz=arg 其他很酷的选项 --baz 带着指定名称的参数 qux?path qux 会带上一个 path 参数，但是对它自己有意义

  一个选项组头
C?        带着一个可选参数的 C 选项

eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"
------------


使用文本
~~~~

当 `"$@"` 为上例中的 `-h`或 `--help` 时，将显示以下使用文本：

------------
usage: some-command [<选项>] <参数>...

    some-command 会执行 foo 和 bar!

    -h, --help            显示磅帮助
    --[no-]foo            一些简便的选项 --foo
    --[no-]bar ...        一些很酷的选项 --bar 带着一个参数
    --[no-]baz <arg>      另外很酷的选项 --baz 带着指定名称的参数
    --[no-]qux[=<路径>]   qux 可能会带上一个对它自己有意义的路径参数

一个选项组的头部
    -C[...]               带着一个可选参数的选项 C
------------

SQ-QUOTE
--------

在 `--sq-quote` 模式下，'git rev-parse' 会在标准输出中输出一行适合 `sh(1)` `eval` 的参数。这一行是通过将 `--sq-quote` 后面的参数规范化而生成的。除了给参数加引号之外，不会做任何其他操作。

如果希望在输出被 shell 引述之前，'git rev-parse' 仍能像往常一样解释命令输入，请参阅 `--sq` 选项。

示例
~~

------------
$ cat >your-git-script.sh <<\EOF
#!/bin/sh
args=$(git rev-parse --sq-quote "$@")   # 引用用户提供的参数
command="git frotz -n24 $args"          # 并手动将它在内部使用
					# 命令行
eval "$command"
EOF

$ sh your-git-script.sh "a b'c"
------------

实例
--

* 打印当前提交的对象名称：
+
------------
$ git rev-parse --verify HEAD
------------

* 在 $REV shell 变量中打印修订版本中的提交对象名称：
+
------------
$ git rev-parse --verify --end-of-options $REV^{commit}
------------
+
如果 $REV 为空或不是有效版本，则会出错。

* 与上述类似：
+
------------
$ git rev-parse --default master --verify --end-of-options $REV
------------
+
但如果 $REV 为空，则会打印 master 中的提交对象名称。

GIT
---
属于 linkgit:git[1] 文档
